0001   0000             ; ----------------------------------------------------------------------------
0002   0000             ; Micro-Soft Altair BASIC 3.2 (4K) - Annotated Disassembly
0003   0000             ;	
0004   0000             ; Copyright 1975, Bill Gates, Paul Allen, Monte Davidoff
0005   0000             ; Source: http://altairbasic.org/ compiled by Reuben Harris
0006   0000             ; Additional cleanup, relocation by Charles Mangin, March, 2019
0007   0000             ; Comments and IMSAI 8080 port by Bruce Hall, August 2025
0008   0000             ; ----------------------------------------------------------------------------
0009   0000             
0010   0000             ;
0011   0000             ; Introductory comments by Bruce Hall
0012   0000             ;
0013   0000             ; The Version 3.0 printout dated 09/10/75, released by Bill Gates in April 2025, contains
0014   0000             ; the following text:
0015   0000             ;
0016   0000             ;    "Originally written on the PDP-10 from February 9 to April 9.
0017   0000             ;     Bill Gates wrote the runtime stuff.
0018   0000             ;     Paul Allen wrote the non-runtime stuff.
0019   0000             ;     Monte Davidoff wrote the math package."
0020   0000             ;
0021   0000             ; Bill Gates fondly remembers Altair BASIC as "The coolest code I have ever written".
0022   0000             ;
0023   0000             ; This code is heavily commented.  Many comments I added come from altairbasic.org. 
0024   0000             ; I also added comments, where appropriate, from the original source code which was not
0025   0000             ; available at the time of disassembly.  Note that most of the labels, including names of
0026   0000             ; routines, are from the disassembly and therefore do not represent labels found in the 
0027   0000             ; original source code.  This is not at all bad, as the original labels were limited to 
0028   0000             ; 6 characters and are often less descriptive.
0029   0000             ;
0030   0000             ; The text of the program is stored in memory immediately after BASIC.  PROGRAM_BASE is a 
0031   0000             ; pointer to the start of the text.  Register pair HL is commonly used to point to the byte
0032   0000             ; of text currently being evaluated.
0033   0000             ;
0034   0000             ; Each line of a user program is tokenized, with all reserved words and operators converted
0035   0000             ; into 1-byte tokens.  Other text, such as variable names and strings, are stored as is.
0036   0000             ;
0037   0000             ; Each program line is stored in memory as follows:
0038   0000             ;   1. a pointer to the next line of text (2 bytes)
0039   0000             ;   2. the line number in binary form (2 bytes)
0040   0000             ;   3. the tokenized text, followed by a null byte
0041   0000             ;
0042   0000             ; End-of-program is marked by a double-zero.  The pointer in the last line points to this
0043   0000             ; double-zero.  
0044   0000             ;
0045   0000             ; Program variables are stored after the text, 6 bytes per variable.  The start of variable 
0046   0000             ; storage is pointed to by VAR_BASE.  Arrayed variable follow and are pointed to by 
0047   0000             ; VAR_ARRAY_BASE. The byte following all variable storage is pointed to by VAR_TOP
0048   0000             ;
0049   0000             ; A good description of the floating point representation can be found at altairbasic.org.  
0050   0000             ; Numbers are generally stored in a 4-bytes floating point format, where the mantissa is 
0051   0000             ; represented by 23 bits plus a sign bit, and the exponent is represented by 8 bits.  Numbers 
0052   0000             ; are stored in a 4-byte memory location called the floating point accumulator (FAC), on the 
0053   0000             ; stack, or in registers BCDE.  
0054   0000             ; 
0055   0000             
0056   0000             CON  .EQU 02                    ;!!! IMSAI console port
0057   0000             CONS .EQU 03                    ;!!! IMSAI console status port
0058   0000             
0059   0000              	.ORG	00
0060   0000             
0061   0000             Start	
0062   0000 F3              DI	                        ; disable interrupts
0063   0001 C3 17 0D    	JMP Init                    ; init I/O, removing unneeded functions
0064   0004                                             ; the jump location will be changed after INIT done.
0065   0004             
0066   0004 90 04       	.DW 0490h	
0067   0006 F9 07       	.DW 07F9h
0068   0008             
0069   0008             ; SyntaxCheck looks at the current character to make sure it is a specific thing
0070   0008             ; (contained in the location after the call).  If not it calls the syntax error
0071   0008             ; routine.  Otherwise it gobbles the next character and returns (by falling into NextChar)
0072   0008             ; HL ends up pointing to the character after the one which was checked    	
0073   0008             ;
0074   0008             SyntaxCheck	                    ;RST 1 @ 0008
0075   0008 7E              MOV A,M	                    ; A=Byte of BASIC program.
0076   0009 E3          	XTHL	                    ; HL=return address.
0077   000A BE          	CMP M	                    ; Compare to byte expected.
0078   000B 23          	INX H	                    ; Return address++;
0079   000C E3          	XTHL	
0080   000D C2 D0 01    	JNZ SyntaxError	            ; Error if not what was expected.
0081   0010             
0082   0010             ; NextChar returns the next character in buffer at HL, skipping over space characters. 
0083   0010             ; Condition codes are set according to what is in A: 
0084   0010             ; Carry C = Numberic (0..9) 
0085   0010             ; Zero Z = ":" or null 00h
0086   0010             ;
0087   0010             NextChar	                    ;RST 2 @ 0010
0088   0010 23              INX H	                    ; advance pointer to next character
0089   0011 7E          	MOV A,M	                    ; retrieve it
0090   0012 FE 3A       	CPI $3A	                    ; is it >= ':'?
0091   0014 D0          	RNC	                        ; alpha character, so done
0092   0015 C3 60 04    	JMP NextChar_tail           ; must eval further	
0093   0018             
0094   0018             ; OutChar prints the character to terminal, handling terminal width
0095   0018             ;
0096   0018             OutChar	                        ;RST 3 @ 0018
0097   0018 F5              PUSH PSW	
0098   0019 3A 27 00    	LDA TERMINAL_X	
0099   001C C3 6E 03    	JMP OutChar_tail	
0100   001F 00          	NOP	
0101   0020             
0102   0020             ; 16-bit compare of HL and DE registers, setting C/Z flags accordingly
0103   0020             ; Carry set for HL < DE
0104   0020             ; Zero set for HL = DE
0105   0020             ;
0106   0020             CompareHLDE                     ;RST 4 @ 0020	
0107   0020 7C              MOV A,H	
0108   0021 92          	SUB D	
0109   0022 C0          	RNZ	
0110   0023 7D          	MOV A,L	
0111   0024 93          	SUB E	
0112   0025 C9          	RET	
0113   0026             
0114   0026             ; Variables for x and y positions of the terminal output
0115   0026             ; 
0116   0026 01          TERMINAL_Y	.DB 01	            ; not used in IMSAI version
0117   0027 00          TERMINAL_X	.DB 00	            ; horizontal character position
0118   0028             
0119   0028             
0120   0028             ; Tests the state of FACCUM, returning code in A.
0121   0028             ; A=0 if FAC=0
0122   0028             ; A=1 if FAC>0
0123   0028             ; A=-1 if FAC<0 
0124   0028             ; Condition codes are set according to the value of A. 
0125   0028             ;
0126   0028             FTestSign                       ;RST 5 @ 0028	
0127   0028 3A 72 01        LDA FACCUM+3                ; look at exponent first	
0128   002B B7          	ORA A	                    ; if its zero, then FACCUM=0
0129   002C C2 D1 09    	JNZ FTestSign_tail	        ; otherwise, more to do...
0130   002F C9          	RET	
0131   0030             
0132   0030             ; Push the word HL is pointing to on stack, then incr. HL by 2.
0133   0030             ; First we write the return address to the JMP instruction at the end of the function; 
0134   0030             ; then we read the word at (HL) into BC and push it onto the stack; 
0135   0030             ; lastly jumping to the return address.  
0136   0030             ;
0137   0030             PushNextWord                    ;RST 6 @ 0030	
0138   0030 E3              XTHL	                    ; get return address into HL
0139   0031 22 3B 00    	SHLD L003A+1	            ; put it after JMP instruction below
0140   0034 E1          	POP H	                    ; get HL back
0141   0035 4E          	MOV C,M	                    ; get word stored at (HL)    
0142   0036 23          	INX H	
0143   0037 46          	MOV B,M	                    ; and move it into BC
0144   0038 23          	INX H	
0145   0039 C5          	PUSH B	                    ; push (HL) on stack
0146   003A             L003A	
0147   003A C3 3A 00        JMP L003A	                ; jump to the return address         
0148   003D             
0149   003D             KW_INLINE_FNS	                ; Function Addresses:
0150   003D DB 09           .DW Sgn	                    ; for SGN 
0151   003F 99 0A       	.DW Int	                    ; for INT
0152   0041 EF 09       	.DW Abs	                    ; for ABS
0153   0043 9A 04       	.DW FunctionCallError	    ; for FCE 
0154   0045 1A 0C       	.DW Sqr	                    ; for SQR 
0155   0047 58 0C       	.DW Rnd	                    ; for RND 
0156   0049 8B 0C       	.DW Sin	                    ; for SIN
0157   004B             
0158   004B             ; THE OPERATOR TABLE
0159   004B             ;
0160   004B             ; This table contains an operators precedence, followed by the address of the routine
0161   004B             ; to perform the operation.  The index into the operator table is made by subtracting
0162   004B             ; off the crunch value of the lowest numbered operator.  The order of operators in the
0163   004B             ; crunch list and in optable is identical.  The precedences are arbitary, except for
0164   004B             ; their comparative sizes.  Note that the precedence for unary operators such as not
0165   004B             ; and negation are set up specially without using a table
0166   004B             ;
0167   004B             KW_ARITH_OP_FNS	
0168   004B 79              .DB 79h
0169   004C 07 08       	.DW FAdd	                ; +
0170   004E 79          	.DB 79h
0171   004F 01 08       	.DW FSub	                ; -
0172   0051 7C          	.DB 7Ch 
0173   0052 DA 08       	.DW FMul	                ; *
0174   0054 7C          	.DB 7Ch 
0175   0055 26 09       	.DW FDiv	                ; /
0176   0057             
0177   0057             
0178   0057             ; THE RESERVED WORD OR "CRUNCH" LIST
0179   0057             ; 
0180   0057             ; When a command or program line is typed in it is stored in buffer.  As soon
0181   0057             ; as the whole line has been typed in, CRUNCH is called to convert all reserved words
0182   0057             ; to their crunch values.  This reduces the size of the program and speeds up execution
0183   0057             ; by allowing table dispatches to perform functions, statements, and operations.  This is
0184   0057             ; because all the statement names are stored consecutively in the crunch list.  When a 
0185   0057             ; match is found between a string of characters and a word in the crunch list the entire
0186   0057             ; text of the matched word is taken out of the input line and a reserved word token is
0187   0057             ; put in its place.  A reserved word token is always equal to 0x80 plus the position of
0188   0057             ; the matched word in the crunch list
0189   0057             ;
0190   0057             KEYWORDS	
0191   0057 45 4E C4        .DB 45h,4Eh,0C4h	        ; "END"	    80
0192   005A 46 4F D2    	.DB 46h,4Fh,0D2h	        ; "FOR"     81
0193   005D 4E 45 58 D4 	.DB 4Eh,45h,58h,0D4h	    ; "NEXT"    82
0194   0061 44 41 54 C1 	.DB 44h,41h,54h,0C1h	    ; "DATA"    83
0195   0065 49 4E 50 55 	.DB 49h,4Eh,50h,55h,0D4h	; "INPUT"   84
0195   0069 D4 
0196   006A 44 49 CD    	.DB 44h,49h,0CDh	        ; "DIM"	    85
0197   006D 52 45 41 C4 	.DB 52h,45h,41h,0C4h	    ; "READ"    86
0198   0071 4C 45 D4    	.DB 4Ch,45h,0D4h	        ; "LET"	    87
0199   0074 47 4F 54 CF 	.DB 47h,4Fh,54h,0CFh	    ; "GOTO"    88
0200   0078 52 55 CE    	.DB 52h,55h,0CEh	        ; "RUN"	    89
0201   007B 49 C6       	.DB 49h,0C6h	            ; "IF"	    8A
0202   007D 52 45 53 54 	.DB 52h,45h,53h,54h         
0203   0081 4F 52 C5        .DB 4Fh,52h,0C5h	        ; "RESTORE"	8B
0204   0084 47 4F 53 55 	.DB 47h,4Fh,53h,55h,0C2h	; "GOSUB"   8C
0204   0088 C2 
0205   0089 52 45 54 55 	.DB 52h,45h,54h,55h,52h,0CEh; "RETURN"  8D
0205   008D 52 CE 
0206   008F 52 45 CD    	.DB 52h,45h,0CDh	        ; "REM"	    8E
0207   0092 53 54 4F D0 	.DB 53h,54h,4Fh,0D0h	    ; "STOP"    8F
0208   0096 50 52 49 4E 	.DB 50h,52h,49h,4Eh,0D4h	; "PRINT"   90
0208   009A D4 
0209   009B 4C 49 53 D4 	.DB 4Ch,49h,53h,0D4h	    ; "LIST"    91
0210   009F 43 4C 45 41 	.DB 43h,4Ch,45h,41h,0D2h	; "CLEAR"   92
0210   00A3 D2 
0211   00A4 4E 45 D7    	.DB 4Eh,45h,0D7h	        ; "NEW"	    93
0212   00A7 54 41 42 A8 	.DB 54h,41h,42h,0A8h	    ; "TAB("    94
0213   00AB 54 CF       	.DB 54h,0CFh	            ; "TO"	    95
0214   00AD 54 48 45 CE 	.DB 54h,48h,45h,0CEh	    ; "THEN"    96
0215   00B1 53 54 45 D0 	.DB 53h,54h,45h,0D0h	    ; "STEP"    97
0216   00B5 AB          	.DB $AB	                    ; "+"	    98
0217   00B6 AD          	.DB $AD	                    ; "-"	    99
0218   00B7 AA          	.DB $AA	                    ; "*"	    9A
0219   00B8 AF          	.DB $AF	                    ; "/"	    9B
0220   00B9 BE          	.DB $BE	                    ; ">"	    9C
0221   00BA BD          	.DB $BD	                    ; "="	    9D
0222   00BB BC          	.DB $BC	                    ; "<"	    9E
0223   00BC 53 47 CE    	.DB 53h,47h,0CEh	        ; "SGN"	    9F
0224   00BF 49 4E D4    	.DB 49h,4Eh,0D4h	        ; "INT"	    A0
0225   00C2 41 42 D3    	.DB 41h,42h,0D3h	        ; "ABS"	    A1
0226   00C5 55 53 D2    	.DB 55h,53h,0D2h	        ; "USR"	    A2
0227   00C8 53 51 D2    	.DB 53h,51h,0D2h	        ; "SQR"	    A3
0228   00CB 52 4E C4    	.DB 52h,4Eh,0C4h        	; "RND"	    A4
0229   00CE 53 49 CE    	.DB 53h,49h,0CEh	        ; "SIN"	    A5
0230   00D1 00          	.DB $00	                    ; End of List 	 	
0231   00D2             
0232   00D2             ; STATEMENT DISPATCH ADDRESSES
0233   00D2             ; 
0234   00D2             ; When a statement is to be executed, the first character of the statement is examined
0235   00D2             ; to see if it less than the reserved word token for the lowest numbered statement name.
0236   00D2             ; If so, the "Let" code is called to treat the statement as an assignment statement.
0237   00D2             ; Otherwise a check is made to make sure the reserved word number is not too large to be 
0238   00D2             ; a statement number.  If not, the address to dispatch to is fetched from this table 
0239   00D2             ; using the reserved word number to calculate an index into the table
0240   00D2             ;
0241   00D2             KW_GENERAL_FNS	                ; Function Addresses for:
0242   00D2 F7 01           .DW Stop	                ; END
0243   00D4 D7 03       	.DW For	                    ; FOR
0244   00D6 40 06       	.DW Next	                ; NEXT
0245   00D8 F7 04       	.DW FindNextStatement	    ; DATA
0246   00DA DB 05       	.DW Input	                ; INPUT
0247   00DC 0D 07       	.DW Dim	                    ; DIM
0248   00DE ED 05       	.DW Read	                ; READ
0249   00E0 03 05       	.DW Let	                    ; LET
0250   00E2 D1 04       	.DW Goto	                ; GOTO
0251   00E4 A1 02       	.DW Run	                    ; RUN
0252   00E6 17 05       	.DW If	                    ; IF
0253   00E8 6B 04       	.DW Restore	                ; RESTORE
0254   00EA C0 04       	.DW Gosub	                ; GOSUB
0255   00EC E1 04       	.DW Return	                ; RETURN
0256   00EE F8 04       	.DW Rem	                    ; REM
0257   00F0 F7 01       	.DW Stop	                ; STOP
0258   00F2 58 05       	.DW Print	                ; PRINT
0259   00F4 90 03       	.DW List	                ; LIST
0260   00F6 A6 02       	.DW Clear	                ; CLEAR
0261   00F8 95 02       	.DW New	                    ; NEW
0262   00FA             
0263   00FA             ; ERROR MESSAGES
0264   00FA             ;
0265   00FA             ; When an error condition is detected, Reg E must be set up to indicate which error
0266   00FA             ; message is appropriate and a branch must be made to error.  The stack will be reset
0267   00FA             ; and all program content will be lost.  Variable values and the actual program remain
0268   00FA             ; intact.  Only the value of Reg E is important when the the branch is made to Error.
0269   00FA             ; E is used as an index into the error table below which gives the two-character error
0270   00FA             ; meesage that will be printed on the user's terminal
0271   00FA             ;
0272   00FA             ERROR_CODES	
0273   00FA 4E C6           .DB 4Eh,0C6h	            ; "NF"	NEXT without FOR.
0274   00FC 53 CE       	.DB 53h,0CEh	            ; "SN"	Syntax Error
0275   00FE 52 C7       	.DB 52h,0C7h	            ; "RG"	RETURN without GOSUB.
0276   0100 4F C4       	.DB 4Fh,0C4h	            ; "OD"	Out of Data
0277   0102 46 C3       	.DB 46h,0C3h	            ; "FC"	Illegal Function Call
0278   0104 4F D6       	.DB 4Fh,0D6h	            ; "OV"	Overflow.
0279   0106 4F CD       	.DB 4Fh,0CDh	            ; "OM"	Out of memory.
0280   0108 55 D3       	.DB 55h,0D3h	            ; "US"	Undefined Subroutine
0281   010A 42 D3       	.DB 42h,0D3h	            ; "BS"	Bad Subscript
0282   010C 44 C4       	.DB 44h,0C4h	            ; "DD"	Duplicate Definition
0283   010E 2F B0       	.DB 2Fh,0B0h	            ; "\0"	Division by zero.
0284   0110 49 C4       	.DB 49h,0C4h	            ; "ID"	Invalid in Direct mode.
0285   0112              	
0286   0112             ; INTERNAL VARIABLES FOLLOW
0287   0112             ;
0288   0112 2C              .DB ','	                    ; A comma, used by INPUT statement since the data pointer
0289   0113                                             ; always starts on a comma or terminator
0290   0113             LINE_BUFFER	
0291   0113 00 00 00 00     .DW 0000,0000,0000,0000h	; 72 character input buffer.  What user types is stored here
0291   0117 00 00 00 00 
0292   011B 00 00 00 00 	.DW 0000,0000,0000,0000h	;   Direct statements also execute out of here.
0292   011F 00 00 00 00 
0293   0123 00 00 00 00 	.DW 0000,0000,0000,0000h	;   Called "BUF" in original code.
0293   0127 00 00 00 00 
0294   012B 00 00 00 00 	.DW 0000,0000,0000,0000h	;
0294   012F 00 00 00 00 
0295   0133 00 00 00 00 	.DW 0000,0000,0000,0000h	;
0295   0137 00 00 00 00 
0296   013B 00 00 00 00 	.DW 0000,0000,0000,0000h	;
0296   013F 00 00 00 00 
0297   0143 00 00 00 00 	.DW 0000,0000,0000,0000h	;
0297   0147 00 00 00 00 
0298   014B 00 00 00 00 	.DW 0000,0000,0000,0000h	;
0298   014F 00 00 00 00 
0299   0153 00 00 00 00 	.DW 0000,0000,0000,0000h	;		
0299   0157 00 00 00 00 
0300   015B             
0301   015B 00          DIM_OR_EVAL	    .DB 00	        ; flag
0302   015C 00          INPUT_OR_READ	.DB 00	        ; flag
0303   015D 00 00       PROG_PTR_TEMP	.DW 0000	    ; temporary variable
0304   015F 00 00       TEMP2	        .DW 0000        ; temporary variable for formula eval, etc	
0305   0161 00 00       CURRENT_LINE	.DW 0000	    ; current line #, =FFFF for direct commands
0306   0163 1A 0F       STACK_TOP	    .DW 0F1Ah	    ; set by init according to memory size 
0307   0165 00 00       PROGRAM_BASE	.DW 0000	    ; start of user program storage
0308   0167 00 00       VAR_BASE	    .DW 0000	    ; start of variable storage area
0309   0169 00 00       VAR_ARRAY_BASE	.DW 0000	    ; start of array variable storage
0310   016B 00 00       VAR_TOP	        .DW 0000	    ; end of variable storage area   
0311   016D 00 00       DATA_PROG_PTR	.DW 0000	    ; pointer to data
0312   016F 00          FACCUM	        .DB 00          ; Lowest order of mantissa, Floating pt accumulator (FAC)
0313   0170 00                          .DB 00          ; Middle order of mantissa
0314   0171 00                          .DB 00          ; Highest order of mantissa
0315   0172 00                          .DB 00	        ; Exponent of FAC
0316   0173 00          FTEMP	        .DB 00	        
0317   0174 00 00 00 00 FBUFFER	        .DW 0000,0000   ; floating point I/O buffer, used by FOut
0318   0178 00 00 00 00 	            .DW 0000,0000
0319   017C 00 00 00 00                 .DW 0000,0000
0320   0180 00          	            .DB 00	
0321   0181             
0322   0181 20 45 52 52 szError	.DB " ERROR",0      	;" ERROR"	 
0322   0185 4F 52 00 
0323   0188 20 49 4E 20 szIn	.DB " IN ",0        	;" IN"
0323   018C 00 
0324   018D 0D 4F 4B 0D szOK	.DB 13,"OK",13,0       	;" OK"	 
0324   0191 00 
0325   0192             
0326   0192             ; Find a "FOR" entry on the stack with the variable pointer passed in DE
0327   0192             ;
0328   0192             ; Whenever a FOR is executed an 18-byte entry is pushed onto the stack.  Before this is done,
0329   0192             ; however, a check must be made to see if there are any FOR entries already on the stack
0330   0192             ; for the same loop variable.  If so, that FOR entry and all other FOR entries that were made
0331   0192             ; after it are eliminated from the stack.  This is so a program that jumps out of the middle
0332   0192             ; of a FOR loop and then restarts the loop again and again won't use up 18 bytes of stack 
0333   0192             ; every time.  The NEXT code also calls FindFor to search for a FOR entry with the loop
0334   0192             ; variable in the NEXT, at whatever point a match is found the stack is reset.  If no match
0335   0192             ; is found a "Next without For" error occurs.  GOSUB execution also puts a 6-byte entry on
0336   0192             ; stack, when a return is executed FindFor is called with a variable pointer that can't be
0337   0192             ; matched...when FindFor has run through all the FOR entries on the stack it returns and the
0338   0192             ; return code makes sure the entry that was stopped on is a GOSUB entry.  This assures that
0339   0192             ; if you GOSUB to a section of code in which a FOR loop is entered but never exited, the 
0340   0192             ; return will still be able to find the most recent GOSUB entry.  The "return" code
0341   0192             ; eliminates the GOSUB entry and all FOR entries made after the GOSUB entry.
0342   0192             ;
0343   0192             FindFor	
0344   0192 21 04 00        LXI H,0004h	                ; HL=SP+4 (ie get word
0345   0195 39          	DAD SP	                    ; just past return addr)
0346   0196 7E          	MOV A,M	                    ; what type of thing is on the stack?
0347   0197 23          	INX H	
0348   0198 FE 81       	CPI $81	                    ; is the stack entry a 'FOR'?
0349   019A C0          	RNZ	                        ; Return if not
0350   019B F7          	RST 6	                    ; PushNextWord = PUSH (HL)
0351   019C E3          	XTHL	                    ; POP HL (ie HL=(HL))
0352   019D E7          	RST 4	                    ; CompareHLDE: HL==DE?
0353   019E 01 0D 00    	LXI B,000Dh	                ; to wipe out a For entry 
0354   01A1 E1          	POP H	                    ; Restore HL
0355   01A2 C8          	RZ	                        ; if for matches, good
0356   01A3 09          	DAD B	                    ; HL+=000D
0357   01A4 C3 96 01    	JMP FindFor+4	            ; Try the next one
0358   01A7             
0359   01A7             ; Block Transfer Routine
0360   01A7             ; Make space by shoving everything forward
0361   01A7             ; HL = destination adddress
0362   01A7             ; DE = low address to be transferred
0363   01A7             ; BD = high address to be transferred
0364   01A7             ;
0365   01A7             ; A check is made to make sure a reasonable amount of space remains
0366   01A7             ; between the top of the stack and the highest locatoin
0367   01A7             ;
0368   01A7             CopyMemoryUp	
0369   01A7 CD C3 01        CALL CheckEnoughMem         ; Make sure stack won't be overrun
0370   01AA C5          	PUSH B	                    ; Exchange BC with HL.
0371   01AB E3          	XTHL	
0372   01AC C1          	POP B	
0373   01AD             CopyMemLoop	
0374   01AD E7              RST 4	                    ;HL==DE?
0375   01AE 7E          	MOV A,M	                    ; get the byte to transfer      
0376   01AF 02          	STAX B	                    ; and copy it to dest
0377   01B0 C8          	RZ	                        ; Exit if DE reached.
0378   01B1 0B          	DCX B	                    ; back up for next byte
0379   01B2 2B          	DCX H	
0380   01B3 C3 AD 01    	JMP CopyMemLoop	            ; keep copying
0381   01B6             
0382   01B6             ; Called to confirm enough space in memory for the stack
0383   01B6             ; Must be called by any routine which puts arbitary amount of stuff on the stack
0384   01B6             ; Also called by routines such as GOSUB and FOR which make permanent entries on stack
0385   01B6             ;
0386   01B6             CheckEnoughVarSpace	
0387   01B6 E5              PUSH H	                    ; save HL
0388   01B7 2A 6B 01    	LHLD VAR_TOP	
0389   01BA 06 00       	MVI B,00h	                ; BC=C*4
0390   01BC 09          	DAD B	
0391   01BD 09          	DAD B	
0392   01BE CD C3 01    	CALL CheckEnoughMem;
0393   01C1 E1          	POP H	                    ; restore HL
0394   01C2 C9          	RET	
0395   01C3             
0396   01C3             ; Call with HL = some address
0397   01C3             ; Examined to make sure a certain number of bytes remain between it at stack top.
0398   01C3             ;
0399   01C3             CheckEnoughMem	
0400   01C3 D5              PUSH D	
0401   01C4 EB          	XCHG	
0402   01C5 21 DE FF    	LXI H,$FFDE	                ; HL=-34 (extra 2 bytes for return address)
0403   01C8 39          	DAD SP	                    ; HL = stack pointer + offset
0404   01C9 E7          	RST 4	                    ; is this > entering HL
0405   01CA EB          	XCHG	                    ; restore HL from DE
0406   01CB D1          	POP D	                    ; get DE back
0407   01CC D0          	RNC	                        ; was OK?
0408   01CD                                             ; (fall through if not)
0409   01CD             OutOfMemory	
0410   01CD 1E 0C           MVI E,0Ch	                ; offset to "OM" in table
0411   01CF 01          	.DB 01	                    ; LXI B,... = jump over next 2 bytes
0412   01D0             SyntaxError	
0413   01D0 1E 02           MVI E,02h	                ; offset to "SN" in table
0414   01D2 01          	.DB 01	                    ; LXI B,... = jump over next 2 bytes
0415   01D3             DivideByZero	                ; offset to "/0" in table
0416   01D3 1E 14           MVI E,14h	
0417   01D5             
0418   01D5             ; print an error message, like "SN ERROR"
0419   01D5             ; call with Reg E = byte offset to the 2-byte error string
0420   01D5             ;
0421   01D5             Error	
0422   01D5 CD B5 02        CALL ResetStack	
0423   01D8 CD 8B 05    	CALL NewLine	
0424   01DB 21 FA 00    	LXI H,ERROR_CODES	        ; point to error code table
0425   01DE 57              MOV D,A	                    ; NewLine set A=0, so D=0            
0426   01DF 3E 3F       	MVI A,'?'	                
0427   01E1 DF          	RST 3	                    ; print '?'
0428   01E2 19          	DAD D	                    ; add offset to specific error
0429   01E3 7E          	MOV A,M	                    ; get 1st char of code
0430   01E4 DF          	RST 3	                    ; and print it
0431   01E5 D7          	RST 2	                    ; Get 2nd char of error code
0432   01E6 DF          	RST 3	                    ; and print it
0433   01E7 21 81 01    	LXI H,szError	            
0434   01EA CD 9A 05    	CALL PrintString	        ; Print " ERROR".
0435   01ED 2A 61 01    	LHLD CURRENT_LINE	        ; get current line #
0436   01F0 7C          	MOV A,H	                    ; see if in direct mode
0437   01F1 A5          	ANA L	
0438   01F2 3C          	INR A	                    ; 0 = direct mode 
0439   01F3 C4 26 0B    	CNZ PrintIN	                ; print line # in HL
0440   01F6 01          	.DB 01	                    ; LXI over Stop and fall into Main
0441   01F7             Stop	
0442   01F7 C0              RNZ	                        ; Syntax Error if args.
0443   01F8 C1          	POP B	                    ; Lose return address.
0444   01F9             
0445   01F9             
0446   01F9             ; Print "OK" and wait for user input.
0447   01F9             ; This code processes both text that must be executed immediately (like LIST) and
0448   01F9             ; text that will be stored as part of the user's program.
0449   01F9             ; Program lines are prefixed with a line number.  If one isn't found, it jumps to Exec
0450   01F9             ;
0451   01F9             Main	
0452   01F9 21 8D 01        LXI H,szOK	                ; "OK" prompt
0453   01FC CD 17 0D    	CALL Init	                ; replaced by INIT to "CALL PrintString"
0454   01FF             GetNonBlankLine	
0455   01FF 21 FF FF        LXI H,$FFFF	
0456   0202 22 61 01    	SHLD CURRENT_LINE           ; set line# = FFFF (Immediate mode)
0457   0205 CD 3C 03    	CALL InputLine              ; get input from user
0458   0208 D7          	RST 2	                    ; Look at first character
0459   0209 3C          	INR A	                    ; see if 0, setting flags
0460   020A 3D          	DCR A	 
0461   020B CA FF 01    	JZ GetNonBlankLine	        ; blank line, so try again.
0462   020E F5          	PUSH PSW	                ; save status indicator
0463   020F CD 9F 04    	CALL LineNumberFromStr	    ; read in line #
0464   0212 D5          	PUSH D	                    ; save line #
0465   0213 CD CC 02    	CALL Tokenize	            ; crunch the line!
0466   0216 47          	MOV B,A	                    ; after crunch, A=0 & BC=char count
0467   0217 D1          	POP D	                    ; restore line #
0468   0218 F1          	POP PSW	                    ; was there a line #?
0469   0219 D2 40 04    	JNC Exec	                ; if not, it was a direct statement
0470   021C             
0471   021C             StoreProgramLine	
0472   021C D5              PUSH D	                    ; Push line number
0473   021D C5          	PUSH B	                    ; Push character count
0474   021E D7          	RST 2	                    ; Get first char of line
0475   021F B7          	ORA A	                    ; Zero set if line is empty (ie removing a line)
0476   0220 F5          	PUSH PSW	                ; Preserve line-empty flag
0477   0221 CD 7D 02    	CALL FindProgramLine	    ; Get nearest program line address in BC.
0478   0224 C5          	PUSH B	                    ; Push line address.
0479   0225 D2 39 02    	JNC InsertProgramLine	    ; If line doesn't exist, insert it.
0480   0228             
0481   0228             RemoveProgramLine	
0482   0228 EB              XCHG	                    ; start at DE = Next line address.
0483   0229 2A 67 01    	LHLD VAR_BASE	            ; end point = where variables start
0484   022C             RemoveLine	
0485   022C 1A              LDAX D	                    ; Move a byte of the program remainder
0486   022D 02          	STAX B	                    ; from DE to BC
0487   022E 03          	INX B	                    ; increment pointers
0488   022F 13          	INX D	
0489   0230 E7          	RST 4	                    ; Loop until DE==VAR_BASE, ie whole
0490   0231 C2 2C 02    	JNZ RemoveLine	            ; program remainder has been moved down
0491   0234 60              MOV H,B	
0492   0235 69          	MOV L,C	                    ; Update VAR_BASE from BC (new program end)
0493   0236 22 67 01    	SHLD VAR_BASE	
0494   0239             
0495   0239             InsertProgramLine   
0496   0239 D1              POP D	                    ; Retrieve line# (from above) into DE
0497   023A F1          	POP PSW	                    ; Restore line-empty flag 
0498   023B CA 60 02    	JZ UpdateLinkedList         ; If line is empty, no need to insert
0499   023E 2A 67 01    	LHLD VAR_BASE	
0500   0241 E3          	XTHL	                    ; HL = character count from stack
0501   0242 C1          	POP B	                    ; BC = VAR_BASE
0502   0243 09          	DAD B	                    ; HL = VAR_BASE + character count
0503   0244 E5          	PUSH H	                    ; temp save updated address for variables
0504   0245 CD A7 01    	CALL CopyMemoryUp	        ; Make space for the new line.
0505   0248 E1          	POP H	                    ; retrieve updated variable address
0506   0249 22 67 01    	SHLD VAR_BASE	            ; and save it.
0507   024C EB          	XCHG	                    ; HL=Line address, DE=VAR_BASE
0508   024D 74          	MOV M,H	                    ; not program end, so create a non-zero link
0509   024E 23          	INX H	                    ; Skip over next line ptr (updated below)
0510   024F 23          	INX H	
0511   0250 D1          	POP D	                    ; DE = line number 
0512   0251 73          	MOV M,E	                    ; Write line # to program memory.
0513   0252 23          	INX H	                    
0514   0253 72          	MOV M,D	                     
0515   0254 23          	INX H	
0516   0255             
0517   0255             CopyFromBuffer	
0518   0255 11 13 01        LXI D,LINE_BUFFER	        ; Copy the line into the program.
0519   0258 1A          	LDAX D	                    ; get a byte from the input buffer                 
0520   0259 77          	MOV M,A	                    ; and move it to program memory
0521   025A 23          	INX H	                    ; increment pointers
0522   025B 13          	INX D	
0523   025C B7          	ORA A	                    ; zero marks the end
0524   025D C2 58 02    	JNZ CopyFromBuffer+3        ; loop until done
0525   0260             
0526   0260             UpdateLinkedList	
0527   0260 CD A2 02        CALL ResetAll	            ; do clear & set up stack
0528   0263 23          	INX H	
0529   0264 EB          	XCHG	
0530   0265             
0531   0265             ; CHEAD goes through program storage and fixes up all the links.
0532   0265             ; The end of each line is found by searching for the zero at the end.
0533   0265             ; A double zero link is used to detect the end of the program
0534   0265             ;
0535   0265             CHEAD	
0536   0265 62              MOV H,D	
0537   0266 6B          	MOV L,E	
0538   0267 7E          	MOV A,M	                    ; If the pointer to the next line is a null
0539   0268 23          	INX H	                    ; word then we've reached the end of the
0540   0269 B6          	ORA M	                    ; program, job is done, and we can jump back
0541   026A CA FF 01    	JZ GetNonBlankLine	        ; to let the user type in the next line.
0542   026D 23          	INX H	                    ; Skip over line number.
0543   026E 23          	INX H	
0544   026F 23          	INX H	
0545   0270 AF          	XRA A	                    ; looking for a zero in memory
0546   0271             L0271	
0547   0271 BE              CMP M	                    ; did we find it?
0548   0272 23          	INX H	                    ; bump pointer
0549   0273 C2 71 02    	JNZ L0271	                ; no, keep advancing to end of line
0550   0276 EB          	XCHG	        
0551   0277 73          	MOV M,E	                    ; do 1st byte of fixup
0552   0278 23          	INX H	                    ; advance pointer
0553   0279 72          	MOV M,D	                    ; do 2nd byte of fixup
0554   027A C3 65 02    	JMP CHEAD	                ; keep chaining until done
0555   027D             
0556   027D             ; Search the program text for the line whose # is passed in DE
0557   027D             ; There are 3 possible returns:
0558   027D             ; 1) Z set, carry not set = line not found, BC points to double zero @ end
0559   027D             ; 2) Z and carry both set = line found, BC points to line's link field
0560   027D             ; 3) non-zero, no carry   = line not found, BC points to line beyond searched line
0561   027D             ;
0562   027D             FindProgramLine	
0563   027D 2A 65 01        LHLD PROGRAM_BASE	
0564   0280 44          	MOV B,H	                    ; BC = this line
0565   0281 4D          	MOV C,L	
0566   0282 7E          	MOV A,M	                    ; If we've found two consecutive
0567   0283 23          	INX H	                    ; null bytes, then we've reached the end
0568   0284 B6          	ORA M	                    ; of the program and so return.
0569   0285 2B          	DCX H	
0570   0286 C8          	RZ	                        ; Return not found, reached of program
0571   0287 C5          	PUSH B	                    ; Push this line address
0572   0288 F7          	RST 6	                    ; Push link
0573   0289 F7          	RST 6	                    ; Push line #
0574   028A E1          	POP H	                    ; HL = this line number
0575   028B E7          	RST 4	                    ; Compare line numbers
0576   028C E1          	POP H	                    ; HL = next line address
0577   028D C1          	POP B	                    ; BC = this line address
0578   028E 3F          	CMC	
0579   028F C8          	RZ	                        ; Return carry set if line numbers match.
0580   0290 3F          	CMC
0581   0291 D0          	RNC	                        ; Return if we've reached a line number beyond one searched
0582   0292 C3 80 02    	JMP FindProgramLine+3	    ; keep looking for a match
0583   0295             
0584   0295             ; The NEW command clears the program text & variable space
0585   0295             ;
0586   0295             New	
0587   0295 C0              RNZ	 
0588   0296 2A 65 01    	LHLD PROGRAM_BASE	 
0589   0299 AF          	XRA A	                    ; put a double-zero terminator @ prog start
0590   029A 77          	MOV M,A	
0591   029B 23          	INX H	
0592   029C 77          	MOV M,A	
0593   029D 23          	INX H	 
0594   029E 22 67 01    	SHLD VAR_BASE	            ; and locate variable base right after it
0595   02A1             
0596   02A1             Run	
0597   02A1 C0              RNZ	
0598   02A2             ResetAll	
0599   02A2 2A 65 01        LHLD PROGRAM_BASE	
0600   02A5 2B          	DCX H
0601   02A6             
0602   02A6             ; Clear initializes the variable and array space
0603   02A6             ;	
0604   02A6             Clear	
0605   02A6 22 5D 01        SHLD PROG_PTR_TEMP	        ; save HL
0606   02A9 CD 6B 04    	CALL Restore	            ; restore data
0607   02AC 2A 67 01    	LHLD VAR_BASE	            ; take the variable start address
0608   02AF 22 69 01    	SHLD VAR_ARRAY_BASE	        ; and save it as start of array space
0609   02B2 22 6B 01    	SHLD VAR_TOP	            ; and and of variable storage
0610   02B5             
0611   02B5             ; Reset the stack pointer, elimanating GOSUB and FOR context.
0612   02B5             ; A dummy entry is put on the stack, so FindFor will always find a
0613   02B5             ; "non-FOR" entry at the bottom of the stack.
0614   02B5             ;
0615   02B5             ResetStack	
0616   02B5 C1              POP B	                    ; get return address
0617   02B6 2A 63 01    	LHLD STACK_TOP	            ; point HL to top of memory
0618   02B9 F9          	SPHL	                    ; initialize stack
0619   02BA AF          	XRA A	
0620   02BB 6F          	MOV L,A	
0621   02BC E5          	PUSH H	                    ; push zero (not-FOR/not-GOSUB token) on stack
0622   02BD C5          	PUSH B	                    ; restore return address
0623   02BE 2A 5D 01    	LHLD PROG_PTR_TEMP	        ; get saved HL
0624   02C1 C9          	RET	
0625   02C2             
0626   02C2             ; Prompt user with a '?" and get a line of input
0627   02C2             ;
0628   02C2             InputLineWith	
0629   02C2 3E 3F           MVI A,'?'	                
0630   02C4 DF          	RST 3	                    ; Print the '?' prompt
0631   02C5 3E 20       	MVI A,' '	                
0632   02C7 DF          	RST 3	                    ; Print ' '
0633   02C8 CD 3C 03    	CALL InputLine	            ; get user input
0634   02CB 23          	INX H	
0635   02CC             
0636   02CC             ; All reserved words are translated into single bytes with msb set.  This save space
0637   02CC             ; and time by allowing for table dispatch during execution.  Therefore all tokens
0638   02CC             ; appear in the same order as they do in the address table.
0639   02CC             ;
0640   02CC             Tokenize	
0641   02CC 0E 05           MVI C,05	                ; character count is at least 5.
0642   02CE 11 13 01    	LXI D,LINE_BUFFER	        ; at start, dest ptr = input ptr
0643   02D1 7E          	MOV A,M	                    ; get character from buffer
0644   02D2 FE 20       	CPI ' '	                    ; is it a space we want to save?
0645   02D4 CA 02 03    	JZ WriteChar	            ; yes, stuff in destination line
0646   02D7 47          	MOV B,A	                    ; get character from line
0647   02D8 FE 22       	CPI '"'	                    ; is it a quote sign?
0648   02DA CA 15 03    	JZ FreeCopy	                ; if so, go to special string handling
0649   02DD B7          	ORA A	                    ; end of line?
0650   02DE CA 29 03    	JZ Exit	                    ; yes, done tokenizing
0651   02E1 D5          	PUSH D	                    ; save destination ptr.
0652   02E2 06 00       	MVI B,00	                ; Initialise Keyword ID to 0.
0653   02E4 11 56 00    	LXI D,KEYWORDS-1	        ; point to list of keywords
0654   02E7 E5          	PUSH H	                    ; save input ptr.
0655   02E8 3E          	.DB 3Eh	                    ; LXI over get-next-char
0656   02E9             KwCompare	
0657   02E9 D7              RST 2 	                    ; get next char from buffer
0658   02EA 13          	INX D	                    ; bump destination pointer
0659   02EB 1A          	LDAX D	                    ; Get keyword char to compare with.
0660   02EC E6 7F       	ANI 7Fh	                    ; Ignore bit 7 of keyword char.
0661   02EE CA FF 02    	JZ NotAKeyword	            ; If char 0, then end of keywords reached.
0662   02F1 BE          	CMP M	                    ; Keyword char matches input char?
0663   02F2 C2 1C 03    	JNZ NextKeyword	            ; If not, jump to get next keyword.
0664   02F5 1A          	LDAX D	                    ; get keyword byte
0665   02F6 B7          	ORA A	                    ; set condition codes
0666   02F7 F2 E9 02    	JP KwCompare	            ; if sign set, keyword has been found
0667   02FA F1          	POP PSW	                    ; Remove input ptr from stack. We don't need it.
0668   02FB 78          	MOV A,B	                    ; A=Keyword ID
0669   02FC F6 80       	ORI $80	                    ; Set bit 7 (indicates a keyword)
0670   02FE F2          	.DB $F2	                    ; JP = skip over next POP H and MOV A,M
0671   02FF             NotAKeyword	
0672   02FF E1              POP H	                    ; Restore input ptr
0673   0300 7E          	MOV A,M	                    ; and get input char
0674   0301 D1          	POP D	                    ; Restore dest ptr
0675   0302             WriteChar	
0676   0302 23              INX H	                    ; Advance input ptr
0677   0303 12          	STAX D	                    ; Save char to dest
0678   0304 13          	INX D	                    ; bump dest ptr
0679   0305 0C          	INR C	                    ; bump dest character count
0680   0306 D6 8E       	SUI 8Eh	                    ; Is it the REM keyword (8E)?
0681   0308 C2 D1 02    	JNZ Tokenize+5	            ; loop if not
0682   030B 47          	MOV B,A	                    ; otherwise, just copy rest of line (B now 0)
0683   030C             
0684   030C                 ; copy input to output without tokenizing, which is needed for REM comments
0685   030C                 ; and string literals.  Reg B holds the terminating character - when this 
0686   030C                 ; char is reached the freecopy is complete and it jumps back
0687   030C             
0688   030C             FreeCopyLoop	
0689   030C 7E              MOV A,M	                    ; get input char in A
0690   030D B7          	ORA A	                    ; set condition codes
0691   030E CA 29 03    	JZ Exit	                    ; if A=0 then exit
0692   0311 B8          	CMP B	                    ; are we at end of line yet?
0693   0312 CA 02 03    	JZ WriteChar	            ; yes: go back to tokenizing
0694   0315             FreeCopy	
0695   0315 23              INX H	                    ; bump 
0696   0316 12          	STAX D	                    ; copy char to destination
0697   0317 0C          	INR C	                    ; bump char counter
0698   0318 13          	INX D	                    ; bump dest pointer
0699   0319 C3 0C 03    	JMP FreeCopyLoop	        ; keep copying from input to dest
0700   031C             
0701   031C                 ; advance keyword pointer in DE to point to the next keyword in the table
0702   031C                 ; then jump back to KwCompare to see if it matches.
0703   031C             
0704   031C             NextKeyword	
0705   031C E1              POP H	                    ; Restore input ptr
0706   031D E5          	PUSH H	                    ; keep saving it
0707   031E 04          	INR B	                    ; go to next Keyword ID
0708   031F EB          	XCHG	                    ; HL=keyword table ptr
0709   0320             NextKwLoop	
0710   0320 B6              ORA M	                    ; Loop until
0711   0321 23          	INX H	                    ; bit 7 of
0712   0322 F2 20 03    	JP NextKwLoop	            ; keyword char is set.
0713   0325 EB          	XCHG	                    ; DE=keyword ptr, HL=input ptr
0714   0326 C3 EB 02    	JMP KwCompare+2	            ; done, move to next keyword
0715   0329             
0716   0329             Exit	
0717   0329 21 12 01        LXI H,LINE_BUFFER-1	        ; restore HL to line buffer start
0718   032C 12          	STAX D	                    ; need three 0's on the end
0719   032D 13          	INX D	                    ; one for end-of-line
0720   032E 12          	STAX D	                    ; and two for a zero link
0721   032F 13          	INX D	                    ; because if this is direct statement
0722   0330 12          	STAX D	                    ; it must look like a program end.
0723   0331 C9          	RET	                        ; done tokenizing the line.  Whew!
0724   0332             
0725   0332             Backspace	
0726   0332 05              DCR B	                    ;Char count--;
0727   0333 2B          	DCX H	                    ;Input ptr--;
0728   0334 DF          	RST 3	                    ;Print backspace char.
0729   0335 C2 41 03    	JNZ InputNext	
0730   0338             
0731   0338             ResetInput	
0732   0338 DF              RST 3	                    ;RST OutCha
0733   0339 CD 8B 05    	CALL NewLine	
0734   033C             
0735   033C             ; Get a line of input from the user, handling any special characters
0736   033C             ; allow up to 72 characters in the input buffer
0737   033C             ;
0738   033C             InputLine	
0739   033C 21 13 01        LXI H,LINE_BUFFER	        ; point to line buffer
0740   033F 06 01       	MVI B,01	                ; character counter
0741   0341             InputNext	
0742   0341 CD 84 03        CALL InputChar              ; get next character
0743   0344 FE 0D       	CPI $0D	                    ; is it <cr>?
0744   0346 CA 86 05    	JZ TerminateInput	        ; done if so
0745   0349 FE 20       	CPI ' '	                    ; If < ' '
0746   034B DA 41 03    	JC InputNext	            ; or
0747   034E FE 7D       	CPI $7D	                    ; > '}'
0748   0350 D2 41 03    	JNC InputNext	            ; then loop back.
0749   0353 FE 40       	CPI '@'	                    ; if its @
0750   0355 CA 38 03    	JZ ResetInput	            ; then start fresh
0751   0358 FE 5F       	CPI '_'	                    ; if its an underscore
0752   035A CA 32 03    	JZ Backspace	            ; then do a backspace
0753   035D 4F          	MOV C,A	                    ; temp save char in C
0754   035E 78          	MOV A,B	                    ; get character count
0755   035F FE 48       	CPI 72                      ; is it 72 yet?
0756   0361 3E 07       	MVI A,07                    ; 7 = bell character	
0757   0363 D2 6A 03    	JNC L036A	                ; too many chars; ring the bell
0758   0366 79          	MOV A,C	                    ; restore char               
0759   0367 71          	MOV M,C	                    ; move it into line buffer
0760   0368 23          	INX H	                    ; point to next buffer location
0761   0369 04          	INR B	                    ; increase character count
0762   036A             L036A	
0763   036A DF              RST 3	                    ; display the character	
0764   036B C3 41 03    	JMP InputNext	            ; and get more input
0765   036E             
0766   036E             ; Prints a character to the terminal, dealing with line width. 
0767   036E             ; On entry, the char to be printed is on the stack and A holds TERMINAL_X. 
0768   036E             ; If the current line is up to the maximum width then we print a new line and 
0769   036E             ; update the terminal position. Then we print the character
0770   036E             ;
0771   036E             OutChar_tail	                ; go to next line if necessary:
0772   036E FE 48           CPI 72	                    ; 72 is default line width
0773   0370 CC 8B 05    	CZ NewLine	                ; we've reached end of line
0774   0373 3C          	INR A	                    ; not yet, so increment column count
0775   0374 32 27 00    	STA TERMINAL_X	            ; and save it
0776   0377             
0777   0377             ; The following two routines are modified for use on the IMSAI 8080,
0778   0377             ; using console I/O ports 2/3
0779   0377             ;
0780   0377             WaitTermReady	
0781   0377 DB 03           IN CONS	                    ; read console status port
0782   0379 E6 01       	ANI 01	                    ; look at Tx Ready bit only
0783   037B CA 77 03    	JZ WaitTermReady	        ; loop until ready
0784   037E F1          	POP PSW	                    ; get char to write
0785   037F E6 7F           ANI 7Fh                     ; ignore bit7
0786   0381 D3 02       	OUT CON                     ; and send it           
0787   0383 C9          	RET	
0788   0384             
0789   0384             InputChar	
0790   0384 DB 03           IN CONS	                    ; read console status port 
0791   0386 E6 02       	ANI 02	                    ; look at Rx Ready bit only 
0792   0388 CA 84 03    	JZ InputChar	            ; wait until ready
0793   038B DB 02       	IN CON	                    ; read the byte 
0794   038D E6 7F       	ANI 7Fh                     ; keep only lower 7 bits
0795   038F C9          	RET
0796   0390             
0797   0390             List	
0798   0390 CD 9F 04        CALL LineNumberFromStr	    ; get line # into DE
0799   0393 C0          	RNZ	                        ; must be terminator or error
0800   0394 C1          	POP B	                    ; get rid of return address
0801   0395 CD 7D 02    	CALL FindProgramLine	    ; find line# >= DE
0802   0398 C5          	PUSH B	                    ; save start pointer
0803   0399             ListNextLine	
0804   0399 E1              POP H	                    ; get pointer to line
0805   039A F7          	RST 6	                    ; push link onto stack
0806   039B C1          	POP B	                    ; take link off temporarily
0807   039C 78          	MOV A,B	                    
0808   039D B1          	ORA C	                    ; is it 0 = end of chain?
0809   039E CA F9 01    	JZ Main	                    ; if so, we are done
0810   03A1 CD 75 04    	CALL TestBreakKey           ; check for ctrl-C
0811   03A4 C5          	PUSH B	                    ; put link back on stack
0812   03A5 CD 8B 05    	CALL NewLine	            ; start new line
0813   03A8 F7          	RST 6	                    ; push line #
0814   03A9 E3          	XTHL	                    ; HL = line#, put HL on stack
0815   03AA CD 2E 0B    	CALL PrintInt	            ; print line# as integer
0816   03AD 3E 20       	MVI A,' '	                
0817   03AF E1          	POP H	                    ; restore pointer to start of text
0818   03B0             ListChar	
0819   03B0 DF              RST 3	                    ; space after line #	
0820   03B1 7E          	MOV A,M	                    ; get a character from line
0821   03B2 B7          	ORA A	                    ; test flags
0822   03B3 23          	INX H	                    ; bump text pointer
0823   03B4 CA 99 03    	JZ ListNextLine	            ; 0=end of line, so get start next line
0824   03B7 F2 B0 03    	JP ListChar	                ; normal character, so print it
0825   03BA D6 7F       	SUI 7Fh	                    ; its a token, so convert to keyword #
0826   03BC 4F          	MOV C,A	                    ; save keyword # in C
0827   03BD E5          	PUSH H	                    ; save current position
0828   03BE 11 57 00    	LXI D,KEYWORDS	            ; get pointer to keywords
0829   03C1 D5          	PUSH D	                    ; and save it
0830   03C2             ToNextKeyword	
0831   03C2 1A              LDAX D	                    ; get character from keyword list
0832   03C3 13          	INX D	                    ; bump pointer
0833   03C4 B7          	ORA A	                    ; test bits
0834   03C5 F2 C2 03    	JP ToNextKeyword	        ; not at end of keyword yet
0835   03C8 0D          	DCR C	                    ; decrement char
0836   03C9 E1          	POP H	                    ; pop position here
0837   03CA C2 C1 03    	JNZ ToNextKeyword-1	        ; not at end of keyword list yet
0838   03CD             PrintKeyword	                ; here when found right keyword!
0839   03CD 7E              MOV A,M	                    ; get char from keyword
0840   03CE B7          	ORA A	                    ; set condition codes
0841   03CF FA AF 03    	JM ListChar-1	
0842   03D2 DF          	RST 3	                    ; Out Char	
0843   03D3 23          	INX H	                    ; bump keyword pointer
0844   03D4 C3 CD 03    	JMP PrintKeyword	        ; print the rest of the keyword
0845   03D7             
0846   03D7             
0847   03D7             ; THE "FOR" STATEMENT
0848   03D7             ;
0849   03D7             ; A "FOR" entry on the stack has the following format:
0850   03D7             ; (1 byte)  the token
0851   03D7             ; (2 bytes) a pointer to the loop variable
0852   03D7             ; (1 byte)  a byte reflecting the sign of the increment
0853   03D7             ; (4 bytes) the step
0854   03D7             ; (4 bytes) the upper value 
0855   03D7             ; (2 bytes) the line# for the for statement
0856   03D7             ; (2 bytes) a text pointer into the for statement
0857   03D7             ; TOTAL = 16 bytes
0858   03D7             ;
0859   03D7             ; This FOR handler only gets called once.  Subsequent iterations of the loop return to the
0860   03D7             ; line following the FOR statement, not to the FOR statement itself.
0861   03D7             ;
0862   03D7             For	
0863   03D7 CD 03 05        CALL Let	                ; read the variable and assign it the
0864   03DA                                             ; correct initial value; store a pointer to
0865   03DA                                             ; the variable in (temp)
0866   03DA E3          	XTHL	                    ; save text ptr on the stack
0867   03DB CD 92 01    	CALL FindFor	            ; must have variable pointer in DE 
0868   03DE D1          	POP D	                    ; DE = text pointer
0869   03DF C2 E4 03    	JNZ L03E2	                ; if no matching entry, don't eliminate anything
0870   03E2 09          	DAD B	                    ; if "For", eliminate the matching entry 
0871   03E3                                             ; and everything following
0872   03E3 F9          	SPHL	                    ; do the eliminatation since matching entry was found
0873   03E4             L03E2	
0874   03E4 EB              XCHG	                    ; HL = text pointer
0875   03E5 0E 08       	MVI C,08	                
0876   03E7 CD B6 01    	CALL CheckEnoughVarSpace	; make sure 16 bytes available on stack
0877   03EA E5          	PUSH H	                    ; really save the text pointer
0878   03EB CD F7 04    	CALL FindNextStatement	    ; get HL that points just beyond terminator
0879   03EE E3          	XTHL	                    ; restore HL as text pointer at variable name
0880   03EF E5          	PUSH H	                    ; push pointer to end of statement onto the stack
0881   03F0 2A 61 01    	LHLD CURRENT_LINE	        ; HL = current line #
0882   03F3 E3          	XTHL	                    ; now current line # on stack & HL is text ptr
0883   03F4 CF          	RST 1	                    ; Syntax Check
0884   03F5 95          	.DB 95h	                    ; for keyword "TO"	
0885   03F6 CD 81 06    	CALL EvalExpression	        ; read the value after "TO"
0886   03F9 E5          	PUSH H	                    ; save text pointer
0887   03FA CD 14 0A    	CALL FCopyToBCDE	        ; get the stuff
0888   03FD E1          	POP H	                    ; restore text pointer
0889   03FE C5          	PUSH B	                    ; push FP result onto the stack
0890   03FF D5          	PUSH D	                     
0891   0400 01 00 81    	LXI B,8100h	                ; initialize step value to 1
0892   0403 51          	MOV D,C	
0893   0404 5A          	MOV E,D	
0894   0405 7E          	MOV A,M	                    ; get terminating character                
0895   0406 FE 97       	CPI $97	                    ; Do we have a "Step"?
0896   0408 3E 01       	MVI A,01h	                ; set up default sign
0897   040A C2 16 04    	JNZ PushStepValue	        ; skip ahead if no step
0898   040D CD 82 06    	CALL EvalExpression+1	    ; evaluate the step expression
0899   0410 E5          	PUSH H	
0900   0411 CD 14 0A    	CALL FCopyToBCDE	        ; get step value into regs
0901   0414 EF          	RST 5	                    ; FTestSign
0902   0415 E1          	POP H	
0903   0416             PushStepValue	
0904   0416 C5              PUSH B	                    ; push step value onto stack
0905   0417 D5          	PUSH D	
0906   0418 F5          	PUSH PSW	                ; save sign of step
0907   0419 33          	INX SP	                    ; as one-byte entry only
0908   041A E5          	PUSH H	
0909   041B 2A 5D 01    	LHLD PROG_PTR_TEMP	        ; retrieve ptr to variable    
0910   041E E3          	XTHL                        ; & put in stack; get back text ptr	
0911   041F             EndOfForHandler	
0912   041F 06 81           MVI B,$81	        
0913   0421 C5          	PUSH B	                    ; put the "FOR" token on stack
0914   0422 33          	INX SP	                    ; as a one-byte entry
0915   0423                                             ; continue below into "NextExec"
0916   0423             
0917   0423             ; Having executed one statement, the following code moves to the next program statement
0918   0423             ; in the line (or next line if there are no more statements in current line)
0919   0423             ;
0920   0423             ; Character pointed to by HL is either ":" or EOL.  The address of this routine is left
0921   0423             ; on the stack when a statement is executed so that it can do a RET when it is done.
0922   0423             ;
0923   0423             ; In the original source code, this function was called "NEWSTT", the new statement fetcher.
0924   0423             ;
0925   0423             ExecNext	
0926   0423 CD 75 04        CALL TestBreakKey	        ; give user a chance to break execution
0927   0426 7E          	MOV A,M	                    ; get next character in text
0928   0427 FE 3A       	CPI ':'	                    ; a colon ":" is a statement separator
0929   0429 CA 40 04    	JZ Exec	                    ; go jump to Exec to run it!
0930   042C B7          	ORA A	                    ; no statement separator found, so char should be null byte
0931   042D C2 D0 01    	JNZ SyntaxError	            ; if not null, thats a syntax error.
0932   0430 23          	INX H	                    
0933   0431 7E          	MOV A,M	                    ; get next byte, usually next line address
0934   0432 23          	INX H	
0935   0433 B6          	ORA M	                    ; and 2nd byte of next line address
0936   0434 23          	INX H	                    
0937   0435 CA F9 01    	JZ Main	                    ; both zero = program end, so return to main
0938   0438 5E          	MOV E,M	                    
0939   0439 23          	INX H	
0940   043A 56          	MOV D,M	                    ; DE = line# of next line
0941   043B EB          	XCHG	                    ; HL now line #, DE = text pointer
0942   043C 22 61 01    	SHLD CURRENT_LINE	        ; save current line #
0943   043F EB          	XCHG	                    ; restore text pointer & fall into Exec below
0944   0440             
0945   0440             
0946   0440             ; Execute a BASIC statement pointed to by HL
0947   0440             ;
0948   0440             Exec	
0949   0440 D7              RST 2	                    ; get first character of statement	
0950   0441 11 23 04    	LXI D,ExecNext	
0951   0444 D5          	PUSH D	                    ; push ExecNext so that we return to it
0952   0445 C8          	RZ	                        ; leave if this is an empty statement
0953   0446 D6 80       	SUI 80h	                    ; Check to see if we start with token.
0954   0448 DA 03 05    	JC Let	                    ; No?  It could be an implied let, like "A=2"
0955   044B FE 14       	CPI $14	                    ; if it's not a reserved word         
0956   044D D2 D0 01    	JNC SyntaxError	            ; then its a syntax error
0957   0450 07          	RLC	                        ; BC = A*2
0958   0451 4F          	MOV C,A	
0959   0452 06 00       	MVI B,00h	
0960   0454 EB          	XCHG	
0961   0455 21 D2 00    	LXI H,KW_GENERAL_FNS	    ; point to list of keyword functions
0962   0458 09          	DAD B	                    ; add in offset to desired function
0963   0459 4E          	MOV C,M	                    ; get keyword handler address in BC
0964   045A 23          	INX H	            
0965   045B 46          	MOV B,M	                        
0966   045C C5          	PUSH B	                    ; push keyword handler on stack
0967   045D EB          	XCHG	                    ; HL = program pointer
0968   045E D7          	RST 2	                    ; get next character in statement
0969   045F C9          	RET	                        ; return to keyword handler fn
0970   0460             
0971   0460             NextChar_tail	
0972   0460 FE 20           CPI ' '	                    ; is it a space?
0973   0462 CA 10 00    	JZ NextChar	                ; ignore spaces
0974   0465 FE 30       	CPI '0'	                       
0975   0467 3F          	CMC	                        ; set carry if non-numeric
0976   0468 3C          	INR A	                    ; test for null
0977   0469 3D          	DCR A	                    ; without affecting carry
0978   046A C9          	RET
0979   046B             
0980   046B             
0981   046B             ; The "RESTORE" statement
0982   046B             ;
0983   046B             ; Reset the data pointer to just before the start of the program
0984   046B             ;
0985   046B             Restore	
0986   046B EB              XCHG	
0987   046C 2A 65 01    	LHLD PROGRAM_BASE           ; point to start of program	
0988   046F 2B          	DCX H	                    ; decrement pointer    
0989   0470             L046E	
0990   0470 22 6D 01        SHLD DATA_PROG_PTR	        ; and save this as data pointer        
0991   0473 EB          	XCHG	
0992   0474 C9          	RET	
0993   0475             
0994   0475             ; !!! TestBreakKey modified for use with IMSAI 8080
0995   0475             ;
0996   0475             TestBreakKey	
0997   0475 DB 03           IN  CONS                    ; Check console status
0998   0477 E6 02       	ANI 02	                    ; look at only Rx Ready
0999   0479 C8          	RZ	                        ; exit if no key waiting
1000   047A CD 84 03    	CALL InputChar	            ; get the key
1001   047D FE 03       	CPI 3	                    ; is it Ctrl-C?
1002   047F C3 F7 01    	JMP Stop	
1003   0482             
1004   0482             ; if the characters pointed to by HL is A..Z, the carry flag is clear
1005   0482             ; carry flag set for anything else
1006   0482             ; 
1007   0482             CharIsAlpha	
1008   0482 7E              MOV A,M	                    ; get character
1009   0483 FE 41       	CPI 'A'	
1010   0485 D8          	RC	                        ; carry set if char < 'A'
1011   0486 FE 5B       	CPI 'Z'+1	
1012   0488 3F          	CMC	                        ; carry set if char > 'Z'
1013   0489 C9          	RET	
1014   048A             
1015   048A             ; Get the subscript of an array variable in an expression or DIM declaration
1016   048A             ; The subscript is returned as a positive interger in CDE
1017   048A             ;
1018   048A             GetSubscript	
1019   048A D7              RST 2	                    ; point to the next character
1020   048B CD 81 06    	CALL EvalExpression         ; get the subscript 	
1021   048E EF          	RST 5	                    ; Check the sign
1022   048F FA 9A 04    	JM FunctionCallError	    ; FC error if subscript is negative
1023   0492 3A 72 01    	LDA FACCUM+3	
1024   0495 FE 90       	CPI $90	                    ; FC error if subscript > 32767
1025   0497 DA 6E 0A    	JC FAsInteger	            ; exit to FasInteger if subscript OK
1026   049A             
1027   049A             FunctionCallError               ; FC error
1028   049A 1E 08           MVI E,08h	
1029   049C C3 D5 01    	JMP Error	
1030   049F             
1031   049F             ; Gets a line number from a string pointer at in HL. 
1032   049F             ; The integer result is returned in DE. 
1033   049F             ; Leading spaces are skipped over, and it returns on finding the first non-digit. 
1034   049F             ; The largest possible line number is 65529
1035   049F             ; (Syntax error if the value of the first four digits is more then 65529)
1036   049F             ; Returns with Z set if it found a valid number (or the string was empty), 
1037   049F             ; or NZ if the string didn't lead with a number.
1038   049F             ;
1039   049F             LineNumberFromStr	            ; gets number value in buffer into DE
1040   049F 2B              DCX H	                    ; start at beginning of line buffer
1041   04A0 11 00 00    	LXI D,0000	                ; initialize result DE = 0 
1042   04A3             NextLineNumChar	
1043   04A3 D7              RST 2	                    ; get next character in line buffer	
1044   04A4 D0          	RNC	                        ; exit on 1st non-alphanumeric
1045   04A5 E5          	PUSH H	                    ; save buffer pointer
1046   04A6 F5          	PUSH PSW	                ; save current character
1047   04A7 21 98 19    	LXI H,1998h	                ; Decimal 6552
1048   04AA E7          	RST 4	
1049   04AB DA D0 01    	JC SyntaxError              ; line number too high (>65529)	
1050   04AE 62          	MOV H,D	                    ; copy result DE to HL
1051   04AF 6B          	MOV L,E	
1052   04B0 19          	DAD D                       ; HL = result* 2	
1053   04B1 29          	DAD H	                    ; HL = result* 4
1054   04B2 19          	DAD D	                    ; HL = result* 5
1055   04B3 29          	DAD H	                    ; HL = result* 10
1056   04B4 F1          	POP PSW	                    ; retrieve character
1057   04B5 D6 30       	SUI '0'	                    ; convert to a number
1058   04B7 5F          	MOV E,A	                   
1059   04B8 16 00       	MVI D,00h	                ; put number in DE
1060   04BA 19          	DAD D	                    ; new result = old result + number
1061   04BB EB          	XCHG	                    ; put new result in DE             
1062   04BC E1          	POP H	                    ; restore buffer pointer             
1063   04BD C3 A3 04    	JMP NextLineNumChar	
1064   04C0             
1065   04C0             
1066   04C0             ; The "GOSUB" Statement
1067   04C0             ;
1068   04C0             ; A gosub entry on the stack has the following format:
1069   04C0             ; (1 byte)  Gosub Token
1070   04C0             ; (2 bytes) Line # of the gosub statement
1071   04C0             ; (2 bytes) Pointer to the text of the gosub
1072   04C0             ; TOTAL = 5 bytes
1073   04C0             ;
1074   04C0             Gosub	
1075   04C0 0E 03           MVI C,03h	
1076   04C2 CD B6 01    	CALL CheckEnoughVarSpace	; make sure there is room
1077   04C5 C1          	POP B	                    ; pop off return address
1078   04C6 E5          	PUSH H	                    ; push text pointer
1079   04C7 E5          	PUSH H	                    ; save text pointer
1080   04C8 2A 61 01    	LHLD CURRENT_LINE	        ; get current line #
1081   04CB E3          	XTHL                        ; HL = text ptr; Cur.line on stack
1082   04CC 16 8C       	MVI D,$8C	
1083   04CE D5          	PUSH D	                    ; put gosub token on stack
1084   04CF 33          	INX SP	                    ; as 1-byte entry
1085   04D0 C5          	PUSH B	                    ; restore return address, fall into GOTO
1086   04D1             
1087   04D1             
1088   04D1             ; the "GOTO" statement
1089   04D1             ;
1090   04D1             ; Sets program execution to continue from the line number argument
1091   04D1             ;
1092   04D1             Goto	
1093   04D1 CD 9F 04        CALL LineNumberFromStr	    ; DE = line # from argument
1094   04D4 C0          	RNZ	                        ; syntax error if argument isn't a number
1095   04D5 CD 7D 02    	CALL FindProgramLine	    ; BC = addr of program line with this line#
1096   04D8 60          	MOV H,B	                    ; move address to HL
1097   04D9 69          	MOV L,C	    
1098   04DA 2B          	DCX H	
1099   04DB D8          	RC	                        ; successful return if program line exists
1100   04DC 1E 0E       	MVI E,0Eh	                ; otherwise,
1101   04DE C3 D5 01    	JMP Error	                ; Undefined subroutine (US) Error
1102   04E1             
1103   04E1             ; RETURN
1104   04E1             ;
1105   04E1             ; Return program execution to the statement following the last GOSUB.
1106   04E1             ; Information on where to return is kept on the stack (see GOSUB)
1107   04E1             ;
1108   04E1             Return	
1109   04E1 C0              RNZ	                        ; no arguments allowed for Return stmt
1110   04E2 16 FF       	MVI D,$FF	                ; var pointer in DE never gets matched
1111   04E4 CD 92 01    	CALL FindFor	            ; go past all the "FOR" entries
1112   04E7 F9          	SPHL	                    ; update the stack
1113   04E8 FE 8C       	CPI $8C	                    ; did we reach the GOSUB token?
1114   04EA 1E 04       	MVI E,04h	
1115   04EC C2 D5 01    	JNZ Error	                ; Return without Gosub (RG) Error
1116   04EF E1          	POP H	                    ; pop off Gosub line# into HL
1117   04F0 22 61 01    	SHLD CURRENT_LINE	        ; and store it as current line
1118   04F3 21 23 04    	LXI H,ExecNext	            ; set return address to ExecNext
1119   04F6 E3          	XTHL	                    ; Pop program pointer to just after GOSUB stmt.
1120   04F7                                             ; Fall into FindNextStatement below 
1121   04F7                                             ; which is OK since Return has no arg.
1122   04F7             
1123   04F7             ; the "REM" Statement
1124   04F7             ; 
1125   04F7             ; FindNextStatement: Finds the end of the statement or the end of the program line
1126   04F7             ;
1127   04F7             FindNextStatement	
1128   04F7 3A              .DB 013Ah                   ; LXI B,..3A, skips over next byte 	
1129   04F8             Rem	
1130   04F8 10              .DB 10h	                    ; Bug: supposed to be '0Eh' for "MOV C,0"
1131   04F9 00          	NOP	
1132   04FA             FindNextStatementLoop	
1133   04FA 7E              MOV A,M	                    ; get the character
1134   04FB B7          	ORA A	                    ; is it end-of-line null?
1135   04FC C8          	RZ	                        ; return if so (done)  
1136   04FD B9          	CMP C	                    ; test for the other terminator
1137   04FE C8          	RZ	                        ; return if so
1138   04FF 23          	INX H	                    ; advance to next character
1139   0500 C3 FA 04    	JMP FindNextStatementLoop	; loop until done
1140   0503             
1141   0503             
1142   0503             ; The "LET" Statement
1143   0503             ;
1144   0503             ; Assigns a value to a variable
1145   0503             ;
1146   0503             Let
1147   0503 CD 12 07        CALL GetVar	                ; returns address of variable in DE
1148   0506 CF          	RST 1	                    ; Syntax Check: ensure "=" follows the variable name	
1149   0507 9D          	.DB 9Dh	                    ; "="
1150   0508             AssignVar	                    ; assign result of expression @ HL to variable @ DE
1151   0508 D5              PUSH D	                    ; save variable pointer on stack
1152   0509 CD 81 06    	CALL EvalExpression	        ; get variable value in floating pt accumulator
1153   050C E3          	XTHL	                    ; HL=pointer to value; text ptr on stack
1154   050D 22 5D 01    	SHLD PROG_PTR_TEMP	        ; save pointer for "FOR"     
1155   0510 E5          	PUSH H	                    ; save ptr to value
1156   0511 CD 20 0A    	CALL FCopyToMem	            ; store FACCUM result to variable memory
1157   0514 D1          	POP D	                    ; DE = pointer to value
1158   0515 E1          	POP H	                    ; restore text pointer into HL 
1159   0516 C9          	RET	
1160   0517             
1161   0517             ; The "IF" Statement
1162   0517             ;
1163   0517             ; (left-hand expression) (comparison operator string) (right-hand expression)
1164   0517             ;
1165   0517             ; Evaluates a condition.  The comparison operator must one or more of ">","<","=".
1166   0517             ; It converts a string of comparison operators to a 3-bit value:
1167   0517             ;    set bit 0 if ">" present in the string
1168   0517             ;    set bit 1 if "=" present in the string
1169   0517             ;    set bit 2 if "<" present in the string
1170   0517             ; Therefore ">=" sets bits 0&1 = 3.  ">>>" sets bit 0, so value is 1.  "<=>" value is 7.
1171   0517             ;
1172   0517             If	
1173   0517 CD 81 06        CALL EvalExpression	        ; get left-hand expression
1174   051A 7E          	MOV A,M	                    ; A = first char of operator
1175   051B CD F9 09    	CALL FPush	                ; push left-hand expression on stack
1176   051E 16 00       	MVI D,00	
1177   0520             GetCompareOpLoop	
1178   0520 D6 9C           SUI 9Ch	                    ; convert tokens '<' to 0, '=' to 1, '<' to 2	
1179   0522 DA 33 05    	JC GotCompareOp	            ; jump if not a comparison token           
1180   0525 FE 03       	CPI $03	                    
1181   0527 D2 33 05    	JNC GotCompareOp	        ; jump if not a comparison token
1182   052A FE 01       	CPI $01	                    ; set up bits by mapping
1183   052C 17          	RAL	                        ; 0 to 1, 1 to 2, and 2 to 4
1184   052D B2          	ORA D	                    ; OR with earlier bits
1185   052E 57          	MOV D,A	                    ; store new bits
1186   052F D7          	RST 2	                    ; get next character in text	
1187   0530 C3 20 05    	JMP GetCompareOpLoop	    ; and loop until done
1188   0533             GotCompareOp	
1189   0533 7A              MOV A,D	                    ; retrieve comparison bits
1190   0534 B7          	ORA A	                    ; set condition flags
1191   0535 CA D0 01    	JZ SyntaxError	            ; 0 = no comparison found = error
1192   0538 F5          	PUSH PSW	                ; save comparison bits on stack
1193   0539 CD 81 06    	CALL EvalExpression	        ; evaluate right-hand expression, rslt in FAC
1194   053C CF          	RST 1	                    ; SyntaxCheck: make sure "THEN" present	
1195   053D 96          	.DB 96h	                    ; KWID_THEN	
1196   053E 2B          	DCX H	
1197   053F F1          	POP PSW	            
1198   0540 C1          	POP B	
1199   0541 D1          	POP D	
1200   0542 E5          	PUSH H	                    
1201   0543 F5          	PUSH PSW	
1202   0544 CD 43 0A    	CALL FCompare	            ; compare two sides of relation stmt
1203   0547 3C          	INR A	                    ; build relational bits...
1204   0548 17          	RAL	                        ; less=4, equal=2, greater=1
1205   0549 C1          	POP B	                    ; pop off what relational operator was
1206   054A A0          	ANA B	                    ; see if we matched
1207   054B E1          	POP H	                    ; pop off text pointer
1208   054C CA F8 04    	JZ Rem	                    ; if test failed, skip the rest of line
1209   054F D7          	RST 2	                    ; pick up the first line# character
1210   0550 DA D1 04    	JC Goto	                    ; if line# found, it means implied "GOTO"
1211   0553 C3 45 04    	JMP Exec+5	                ; otherwise interpret remainder as new statement
1212   0556             
1213   0556             
1214   0556             ; The "PRINT" statement
1215   0556             ;
1216   0556             ;  Print can be an empty line, a single expression, or multiple expressions separated by
1217   0556             ;  tabulation directives (comma, semicolon, or tab keyword) 
1218   0556             ;
1219   0556 2B          	DCX H	
1220   0557 D7          	RST 2	                    ; get another character
1221   0558             Print	
1222   0558 CA 8B 05        JZ NewLine                  ; if end of line, exit via NewLine	
1223   055B C8          	RZ	
1224   055C FE 22       	CPI '"'	                    ; is char a quote? (start of string literal)
1225   055E CC 99 05    	CZ PrintString-1	        ; if so just print the string literal
1226   0561 CA 56 05    	JZ Print-2	                ; if end of line reached, then NewLine            
1227   0564 FE 94       	CPI $94	                    ; if char the TAB token, 	 
1228   0566 CA BE 05    	JZ Tab	                    ; then do the TAB function
1229   0569 E5          	PUSH H	                    ; save the text pointer
1230   056A FE 2C       	CPI ','	                    ; if char is a comma,
1231   056C CA AA 05    	JZ ToNextTabBreak	        ; then we have to move to next tab break
1232   056F FE 3B       	CPI $3B                     ; if char is a semicolon,
1233   0571 CA D6 05    	JZ ExitTab	                ; then don't need to do anything special
1234   0574 C1          	POP B	                    ; get rid of old text pointer
1235   0575 CD 81 06    	CALL EvalExpression	        ; evaluate expression to print -> FAC
1236   0578 E5          	PUSH H	                    ; save text pointer
1237   0579 CD 39 0B    	CALL FOut	                ; convert the FAC number to a string
1238   057C CD 9A 05    	CALL PrintString	        ; and print it.
1239   057F 3E 20       	MVI A,' '	                ; always end with a space
1240   0581 DF          	RST 3	                    ; out char	
1241   0582 E1          	POP H	                    ; restore text pointer
1242   0583 C3 56 05    	JMP Print-2	                ; and continue with print
1243   0586             
1244   0586             ; HL points to just beyond the last byte of a line of user input.
1245   0586             ; Here we write a null byte to terminate it, reset HL to point to start of input line buffer
1246   0586             ; then fall into NewLine
1247   0586             ;
1248   0586             TerminateInput	
1249   0586 36 00           MVI M,00h	                ; add null byte to terminate line
1250   0588 21 12 01    	LXI H,LINE_BUFFER-1	        ; reset HL to start of line buffer
1251   058B             
1252   058B             
1253   058B             ; Print carriage return + line feed (CRLF)
1254   058B             ; !!! modified for IMSAI 8080: block of orginal code commented out
1255   058B             ;
1256   058B             NewLine	
1257   058B 3E 0D           MVI A,0Dh	                ; <CR>
1258   058D 32 27 00    	STA TERMINAL_X	
1259   0590 DF          	RST 3	               	    ; send it
1260   0591 3E 0A       	MVI A,0Ah	                ; <LF>
1261   0593 DF          	RST 3	               	    ; send it
1262   0594 AF              XRA A 
1263   0595 32 27 00        STA TERMINAL_X              ; reset x posn
1264   0598 C9              RET                         ; returns with A=0
1265   0599             
1266   0599             ; the rest of this routine is ALTAIR and/or teletype specific, and not needed
1267   0599             ;	LDA TERMINAL_Y	
1268   0599             ;PrintNullLoop	
1269   0599             ;   DCR A	
1270   0599             ;	STA TERMINAL_X	
1271   0599             ;	RZ	
1272   0599             ;	PUSH PSW	
1273   0599             ;	XRA A	
1274   0599             ;	RST 3	;RST OutChar	
1275   0599             ;	POP PSW	
1276   0599             ;	JMP PrintNullLoop
1277   0599             
1278   0599             ; Print a string to the terminal, stopping on a null byte (0) or quote char
1279   0599             ;
1280   0599 23              INX H	                    ; sometimes used with PrintString
1281   059A             PrintString	
1282   059A 7E              MOV A,M	                    ; get character in string
1283   059B B7          	ORA A	                    ; is it zero?
1284   059C C8          	RZ	                        ; yes, we are done
1285   059D 23          	INX H	                    ; point to next char
1286   059E FE 22       	CPI '"'	                    ; is character a quote?
1287   05A0 C8          	RZ	                        ; if so we are done
1288   05A1 DF          	RST 3	                    ; output the character	
1289   05A2 FE 0D       	CPI $0D	                    ; is it <cr>?
1290   05A4 CC 8B 05    	CZ NewLine	                ; send newline if so
1291   05A7 C3 9A 05    	JMP PrintString	            ; repeat until done
1292   05AA             
1293   05AA             ; Calculate how many spaces are need to get us the next tab-break, then
1294   05AA             ; jump to PrintSpaces to do it.
1295   05AA             ;
1296   05AA             ToNextTabBreak	
1297   05AA 3A 27 00        LDA TERMINAL_X	            ; check current tab position
1298   05AD FE 38       	CPI $38	                    ; beyone tab break column = 56?
1299   05AF D4 8B 05    	CNC NewLine	                ; if so, just NewLine
1300   05B2 D2 D6 05    	JNC ExitTab	
1301   05B5             CalcSpaceCount	
1302   05B5 D6 0E           SUI 0Eh	                    ; get # spaces to reach next tab break:
1303   05B7 D2 B5 05    	JNC CalcSpaceCount          ; A = (14 - (A%14))-1
1304   05BA 2F          	CMA	                        
1305   05BB C3 CD 05    	JMP PrintSpaces	            ; and print required # of spaces
1306   05BE             
1307   05BE             
1308   05BE             ; the "TAB" keyword takes an integer argument which indicates
1309   05BE             ; the column to print spaces up to
1310   05BE             ;
1311   05BE             Tab	
1312   05BE CD 8A 04        CALL GetSubscript           ; get positive integer argument in E
1313   05C1 CF          	RST 1	                    ; Syntax Check	
1314   05C2 29          	.DB 29h	                    ; for closing parenthesis ')'	
1315   05C3 2B          	DCX H	
1316   05C4 E5          	PUSH H	                    ; save text pointer
1317   05C5 3A 27 00    	LDA TERMINAL_X	            ; get current position
1318   05C8 2F          	CMA	                        ; negate it
1319   05C9 83          	ADD E	                    ; #spaces needed = tab argument - curpos
1320   05CA D2 D6 05    	JNC ExitTab	                ; done
1321   05CD             PrintSpaces	                    
1322   05CD 3C              INR A	                    ; print A+1 spaces...
1323   05CE 47          	MOV B,A	                    ; counter = A+1
1324   05CF 3E 20       	MVI A,' '	                ; character to print is a space
1325   05D1             PrintSpaceLoop	
1326   05D1 DF              RST 3	                    ; print the space
1327   05D2 05          	DCR B	                    ; and loop
1328   05D3 C2 D1 05    	JNZ PrintSpaceLoop	        ; until done
1329   05D6             ExitTab	
1330   05D6 E1              POP H	                    ; restore the text pointer
1331   05D7 D7          	RST 2	                    ; get the next character in program	
1332   05D8 C3 5B 05    	JMP Print+3	                ; and return to the PRINT handler
1333   05DB             
1334   05DB             
1335   05DB             ; The "INPUT" Statement
1336   05DB             ;
1337   05DB             ; Let user input a number at a "?" prompt
1338   05DB             ;
1339   05DB             Input	
1340   05DB E5              PUSH H	                    ; save text pointer
1341   05DC 2A 61 01    	LHLD CURRENT_LINE	        ; check for direct mode by getting line#
1342   05DF 1E 16       	MVI E,16h	                ; code for illegal direct (ID) error
1343   05E1 23          	INX H	                    ; increment line # 
1344   05E2 7D          	MOV A,L	                    ; is line# now 0?
1345   05E3 B4          	ORA H	                    ; if so, we are in direct mode
1346   05E4 CA D5 01    	JZ Error	                ; and this is an ID error    
1347   05E7 CD C2 02    	CALL InputLineWith	        ; print "?" and get user input
1348   05EA C3 F2 05    	JMP L05FA+1	                ; continue below
1349   05ED             
1350   05ED             
1351   05ED             ; The "READ" Statement
1352   05ED             ;    
1353   05ED             Read	
1354   05ED E5              PUSH H	                    ; save text pointer
1355   05EE 2A 6D 01    	LHLD DATA_PROG_PTR	        ; get last data location
1356   05F1             L05FA	
1357   05F1 F6 AF           ORI $AF	                    ; make flag non-zero (=READ)
1358   05F3             	;XRA A	
1359   05F3 32 5C 01    	STA INPUT_OR_READ	        ; save flag
1360   05F6 E3          	XTHL	                    ; save data ptr on stack, HL=text pointer      
1361   05F7 01          	.DB 01	                    ; LXI B,... trick: skip next syntax check	
1362   05F8             ReadNext	
1363   05F8 CF              RST 1	                    ; SyntaxCheck	
1364   05F9 2C          	.DB 2Ch	                    ; for comma ','	
1365   05FA CD 12 07    	CALL GetVar	                ; DE = address for variable value  
1366   05FD E3          	XTHL	                    ; HL = data pointer; save text ptr on stack
1367   05FE D5          	PUSH D	                    ; save address of variable value
1368   05FF 7E          	MOV A,M	                    ; get byte of data
1369   0600 FE 2C       	CPI ','	                    ; is it a comma separator?
1370   0602 CA 17 06    	JZ GotDataItem	            ; yes, so can evaluate the data
1371   0605 B7          	ORA A	                    ; is it null line terminator?
1372   0606 C2 D0 01    	JNZ SyntaxError	            ; if not, then exit as syntax error
1373   0609 3A 5C 01    	LDA INPUT_OR_READ	        ; reading or input?
1374   060C B7          	ORA A	                    ; test the question!
1375   060D 23          	INX H	
1376   060E C2 2D 06    	JNZ NextDataLine+1	        ; reading: jump ahead to get next data item
1377   0611 3E 3F       	MVI A,'?'	                ; inputting: more inputs to process
1378   0613 DF          	RST 3	                    ; print unneeded question mark.  Oops!!	
1379   0614 CD C2 02    	CALL InputLineWith	        ; and get the next input item
1380   0617             GotDataItem	
1381   0617 D1              POP D	                    ; restore variable address
1382   0618 23          	INX H	                    ; advance data ptr to start of next data item
1383   0619 CD 08 05    	CALL AssignVar	            ; assign the data to the variable
1384   061C E3          	XTHL	                    ; HL = text ptr; push data ptr
1385   061D 2B          	DCX H	                    ; undo AssignVar's text ptr advance 
1386   061E D7          	RST 2	                    ; get next character of READ statement	
1387   061F C2 F8 05    	JNZ ReadNext	            ; if not EOL, get next data item
1388   0622 D1          	POP D	                    ; get data pointer
1389   0623 3A 5C 01    	LDA INPUT_OR_READ	        ; and flag
1390   0626 B7          	ORA A	                    ; don't update data pointer
1391   0627 C8          	RZ	                        ; if this is an INPUT statement
1392   0628 EB          	XCHG	                    ; HL = data pointer, DE = text ptr
1393   0629 C2 70 04    	JNZ L046E	                ; update data pointer
1394   062C             NextDataLine	                ; loop to find next data line
1395   062C E1              POP H	                    ; restore data pointer
1396   062D F7          	RST 6	                    ; push next word on stack (and in BC)
1397   062E 79          	MOV A,C	                    ; test BC
1398   062F B0          	ORA B	                    ; is BC=0? (address=0 or end of program)
1399   0630 1E 06       	MVI E,06h	                ; Out of Data (OD) error
1400   0632 CA D5 01    	JZ Error	                ; flag the error
1401   0635 23          	INX H	                    
1402   0636 D7          	RST 2	                    ; get next text character	
1403   0637 FE 83       	CPI $83	                    ; Is it the DATA token?	 
1404   0639 C2 2C 06    	JNZ NextDataLine	        ; if not, loop to try next program line
1405   063C C1          	POP B	                    ; discard text pointer on stack
1406   063D C3 17 06    	JMP GotDataItem	            ; handle the new data
1407   0640             
1408   0640             
1409   0640             ; the "NEXT" Statement
1410   0640             ; 
1411   0640             ; takes one argument, the name of the FOR variable
1412   0640             ;
1413   0640             Next	
1414   0640 CD 12 07        CALL GetVar	                ; DE = address of variable
1415   0643 22 5D 01    	SHLD PROG_PTR_TEMP	        ; save the text pointer (pointing to end of stmt)
1416   0646 CD 92 01    	CALL FindFor	            ; access the FOR data structure on stack
1417   0649 F9          	SPHL	                    
1418   064A D5          	PUSH D	                    ; save address of variable
1419   064B 7E          	MOV A,M	                    ; get 1st char of the FOR data
1420   064C 23          	INX H	
1421   064D F5          	PUSH PSW	
1422   064E D5          	PUSH D	                    ; push the FOR variable again
1423   064F 1E 00       	MVI E,00h                   ; Next without For (NF) error flag	
1424   0651 C2 D5 01    	JNZ Error	                ; no FOR data found, so error out
1425   0654 CD 06 0A    	CALL FLoadFromMem	        ; load next 4 bytes in FOR data (step) into FAC
1426   0657 E3          	XTHL	                    ; HL = variable addr; push FOR data ptr
1427   0658 E5          	PUSH H	                    
1428   0659 CD FB 07    	CALL FAddMem	            ; Add step number to the FOR variable
1429   065C E1          	POP H	                    ;
1430   065D CD 20 0A    	CALL FCopyToMem	            ; and save result back to FOR variable
1431   0660 E1          	POP H	                    ; ie, var = var + step
1432   0661 CD 17 0A    	CALL FLoadBCDEfromMem       ; HL = ptr to "TO" number, load into BCDE	
1433   0664 E5          	PUSH H	
1434   0665 CD 43 0A    	CALL FCompare	            ; compare updated var to "TO" value. Result in A:
1435   0668                                             ; A will be FF if var<TO, 0 if var=TO, 1 if var>TO 
1436   0668 E1          	POP H	
1437   0669 C1          	POP B	                    ; B= step direction (1=forward, FF=backward)
1438   066A 90          	SUB B	                    ; note that FOR loop is done if A-B = 0.  Cool.
1439   066B CD 17 0A    	CALL FLoadBCDEfromMem       ; get BC=text pointer, DE=line# of FOR statement	
1440   066E CA 7A 06    	JZ ForLoopIsComplete	    ; jump ahead if FOR loop is done
1441   0671 EB          	XCHG	                    ; HL = points to line #
1442   0672 22 61 01    	SHLD CURRENT_LINE	        ; save line#
1443   0675 69          	MOV L,C	                    ; load HL with text pointer (@ end of FOR stmt)
1444   0676 60          	MOV H,B	
1445   0677 C3 1F 04    	JMP EndOfForHandler	        ; done
1446   067A             ForLoopIsComplete	
1447   067A F9              SPHL	                    ; remove the FOR data from stack                 
1448   067B 2A 5D 01    	LHLD PROG_PTR_TEMP	        ; restore the text pointer
1449   067E C3 23 04    	JMP ExecNext
1450   0681             
1451   0681             ; Evaluates an expression (terms & operators), returning the result in FAC.
1452   0681             ; 
1453   0681             ; The evalator starts with HL pointing to the first char in the expression
1454   0681             ; At finish, HL points to the terminator.
1455   0681             ;
1456   0681             ; It uses the operator table to determine precedence and dispatch addr for each operator
1457   0681             ;
1458   0681             ; The temporary result on the stack has the following format:
1459   0681             ; (2 bytes) Return address on completion of the operator routine
1460   0681             ; (4 bytes) Floating point temporary result
1461   0681             ; (2 bytes) Address of the operator routine
1462   0681             ; (2 bytes) The operator precedence
1463   0681             ; TOTAL = 10 bytes
1464   0681             ;
1465   0681             EvalExpression	
1466   0681 2B              DCX H	                    ; back up character pointer
1467   0682 16 00       	MVI D,00h	                ; initial dummy precedence is 0
1468   0684 D5          	PUSH D	                    ; push it 
1469   0685 0E 01       	MVI C,01h	
1470   0687 CD B6 01    	CALL CheckEnoughVarSpace	; ensure room for recursive calls
1471   068A CD BB 06    	CALL EvalTerm	            ; evaluate the term
1472   068D 22 5F 01    	SHLD TEMP2	                ; save text pointer
1473   0690             ArithParse	
1474   0690 2A 5F 01        LHLD TEMP2	                ; load text pointer
1475   0693 C1          	POP B	                    ; pop off precedence
1476   0694 7E          	MOV A,M	                    ; get next character
1477   0695 16 00       	MVI D,00h	                ; assume no relation operators
1478   0697 D6 98       	SUI $98	                    ; is this 1 relation?
1479   0699 D8          	RC	                        ; relations all done
1480   069A FE 04       	CPI $04	                    ; is it an arithmetic (+-*/) operator?
1481   069C D0          	RNC	                        ; nope, bigger
1482   069D 5F          	MOV E,A	                    ; deal with the arithmetic ops...         
1483   069E 07          	RLC	                        ; A x 2
1484   069F 83          	ADD E	                    ; A x 3
1485   06A0 5F          	MOV E,A	                    ; DE = A x 3 = offset into fn table
1486   06A1 21 4B 00    	LXI H,KW_ARITH_OP_FNS	    ; point to operator function table
1487   06A4 19          	DAD D                       ; add offset.  Now HL = function table entry
1488   06A5 78          	MOV A,B	                    ; A = old precedence                
1489   06A6 56          	MOV D,M	                    ; D = new precedence
1490   06A7 BA          	CMP D	                    ; old - new
1491   06A8 D0          	RNC	                        ; apply old op if it has >= precedence
1492   06A9 23          	INX H	                    ; HL now points to function
1493   06AA C5          	PUSH B	                    ; save old precedence
1494   06AB 01 90 06    	LXI B,ArithParse	        ; B = operator return address
1495   06AE C5          	PUSH B	                    ; is first entry on stack
1496   06AF 4A          	MOV C,D	                    
1497   06B0 CD F9 09    	CALL FPush	                ; 2nd stack entry = FP temp result
1498   06B3 51          	MOV D,C	                    ; save precedence in D                        
1499   06B4 F7          	RST 6	                    ; push address of arithmetic fn
1500   06B5 2A 5F 01    	LHLD TEMP2	                ; restore text pointer
1501   06B8 C3 84 06    	JMP EvalExpression+3
1502   06BB             
1503   06BB             ; Evaluate a term in an expression.  
1504   06BB             ; This can be a constant, variable, function, or bracketed expression
1505   06BB             ;
1506   06BB             EvalTerm	
1507   06BB D7              RST 2	                    ; get 1st character of the term.	
1508   06BC DA AA 0A    	JC FIn	                    ; if its a digit, then get value into FAC
1509   06BF CD 82 04    	CALL CharIsAlpha	        ; an alpha char must be a variable
1510   06C2 D2 EA 06    	JNC EvalVarTerm	            ; so evaluate it as a variable
1511   06C5 FE 98       	CPI $98	                    ; if char is a leading '+',	
1512   06C7 CA BB 06    	JZ EvalTerm	                ; just ignore it and get next char
1513   06CA FE 2E       	CPI '.'	                    ; if char is a leading decimal point,
1514   06CC CA AA 0A    	JZ FIn	                    ; then eval as number, get value into FAC
1515   06CF FE 99       	CPI $99	                    ; if char is a leading '-',	
1516   06D1 CA E1 06    	JZ EvalMinusTerm	        ; then jump ahead to minus term eval
1517   06D4 D6 9F       	SUI 9Fh	                    ; if char is the ID of an inline function,
1518   06D6 D2 F4 06    	JNC EvalInlineFn	        ; then jump ahead to handle it
1519   06D9             EvalBracketed	                ; only possibility left is a bracketed expression
1520   06D9 CF              RST 1	                    ; Syntax Check 
1521   06DA 28          	.DB 28h	                    ; for opening paren '('	
1522   06DB CD 81 06    	CALL EvalExpression	        ; if found, do recursive evaluation
1523   06DE CF          	RST 1	                    ; Syntax Check 	
1524   06DF 29          	.DB 29h	                    ; for closing paren ')'	
1525   06E0 C9          	RET	
1526   06E1             EvalMinusTerm	                ; evaluate a negative term...
1527   06E1 CD BB 06        CALL EvalTerm	            ; recursive call to evalute
1528   06E4 E5          	PUSH H	
1529   06E5 CD F1 09    	CALL FNegate	            ; then negate the result
1530   06E8             PopRet 
1531   06E8 E1          	POP H	
1532   06E9 C9          	RET	
1533   06EA             EvalVarTerm	                    ; evaluate a variable...
1534   06EA CD 12 07        CALL GetVar	                ; DE = address of variable value        
1535   06ED E5          	PUSH H	
1536   06EE EB          	XCHG	                    ; now HL = address of value
1537   06EF CD 06 0A    	CALL FLoadFromMem	        ; get value into FAC
1538   06F2 E1          	POP H	
1539   06F3 C9          	RET	
1540   06F4             EvalInlineFn	
1541   06F4 06 00           MVI B,00h	
1542   06F6 07          	RLC	                        ; A x 2
1543   06F7 4F          	MOV C,A	                    ; offset BC = A x 2
1544   06F8 C5          	PUSH B	                    ; and save offset on stack
1545   06F9 D7          	RST 2	                    ; get next character
1546   06FA CD D9 06    	CALL EvalBracketed	        ; evaluate bracketed fn (ex SIN(X+2))
1547   06FD E3          	XTHL	                    ; HL=offset, put text pointer on stack
1548   06FE 11 E8 06    	LXI D,PopRet                ; Set return address to "POP H, RET"  !!! ADDED LABEL            
1549   0701 D5          	PUSH D	
1550   0702 01 3D 00    	LXI B,KW_INLINE_FNS	        ; point to inline function table
1551   0705 09          	DAD B	                    ; and add offset to get function address
1552   0706 F7          	RST 6	                    ; put function adddress on stack
1553   0707 C9          	RET	                        ; and return to it
1554   0708             
1555   0708             
1556   0708             ; DIMENSION AND VARIABLE SEARCHING
1557   0708             ;
1558   0708             ; Space is allocated for variables as they are encountered, this DIM statements must be
1559   0708             ; executed to have effect.  Six (6) bytes are allocated for each simple variable.  The
1560   0708             ; first two bytes give the name of the variable and the last four give its value. 
1561   0708             ; VAR_BASE (VARTAB in original) gives the first location where a simple variable name is
1562   0708             ; found and VAR_ARRAY_BASE (ARYTAB in original) gives the location to stop searching for simple
1563   0708             ; variables.  A FOR entry has a text pointer and a pointer to a variable value so neither the
1564   0708             ; program or the simple variables can be moved while there are active FOR entries on the 
1565   0708             ; stack.
1566   0708             ;
1567   0708             ; Adding a simple variable:
1568   0708             ;   1. Adding 6 to VAR_ARRAY_BASE and VAR_TOP
1569   0708             ;   2. Block transferring the array variables up by 6
1570   0708             ;   3. Making sure VAR_TOP is not too close to the stack
1571   0708             ;
1572   0708             ; This movement of array variables means that no pointer to an array will stay valid when
1573   0708             ; new simple variables can be encountered.  This is why array variables are not allowed
1574   0708             ; FOR loop variables.
1575   0708             ;
1576   0708             ; Setting up a new array variable merely involves building the descriptor, updating VAR_TOP,
1577   0708             ; and making sure there is still enough room between VAR_TOP and the stack.
1578   0708             ;
1579   0708             ; The format of of an array variable is:
1580   0708             ;   1.  Second character of array name
1581   0708             ;   2.  First character of array name
1582   0708             ;   3.  Number of bytes used by the values
1583   0708             ;   4.  The values
1584   0708             ;
1585   0708             ; GetVar (PTRGET in original), the routine which returns a pointer to a variable name, has
1586   0708             ; an important flag.  DIM_OR_EVAL (DIMFLG is original) indicates whether DIM
1587   0708             ; called the routine or not.  If so, no prior entry for the variable should be found, and the
1588   0708             ; index indicates how much space to set aside.  Simple variables can be be dimensioned, but
1589   0708             ; the only effect will be to set aside space for the variable if it hasn't been encountered
1590   0708             ; yet.
1591   0708             
1592   0708             ; The "DIM" Statement
1593   0708             ;
1594   0708             ; Declares in array
1595   0708             ;
1596   0708             DimContd	
1597   0708 2B              DCX H	
1598   0709 D7          	RST 2	                    ; get next program character	
1599   070A C8          	RZ	                        ; return if EOL null 
1600   070B CF          	RST 1	                    ; Syntax Check	
1601   070C 2C          	.DB 2Ch	;','	            ; for a comma
1602   070D             Dim	
1603   070D 01 08 07        LXI B,DimContd              ; set return address for DimContd, above	
1604   0710 C5          	PUSH B	                    ; push return address on stack
1605   0711 F6          	.DB $F6	                    ; ORI AF = set A to nonzero value
1606   0712             
1607   0712             ; Called with HL pointing to a variable name
1608   0712             ; Returns with DE = pointer to the variable's value
1609   0712             ; if variable is new, memory is allocated and var is initialized
1610   0712             ;
1611   0712             GetVar	        
1612   0712 AF              XRA A	                    ; A=0
1613   0713 32 5B 01    	STA DIM_OR_EVAL	            ; flag 0=GetVar, nonzero=DIM
1614   0716 46          	MOV B,M	                    ; B= 1st char of variable name 
1615   0717 CD 82 04    	CALL CharIsAlpha	        ; must be alpha
1616   071A DA D0 01    	JC SyntaxError	            ; otherwise error out
1617   071D AF          	XRA A	
1618   071E 4F          	MOV C,A	                    ; zero out C
1619   071F D7          	RST 2	                    ; get next character	
1620   0720 D2 25 07    	JNC L072E	                ; !!! ADDED LABEL. jump if not alphanumeric
1621   0723 4F          	MOV C,A	                    ; C = second char in var name    
1622   0724 D7          	RST 2	                    ; look at next character
1623   0725             L072E 
1624   0725 D6 28       	SUI '('	                    ; is it '(' for an array?
1625   0727 CA 81 07    	JZ GetArrayVar	            ; jump if so.    
1626   072A E5          	PUSH H	                    ; save text ptr on stack
1627   072B 2A 69 01    	LHLD VAR_ARRAY_BASE	        ; HL= array base
1628   072E EB          	XCHG	                    ; DE = array base
1629   072F 2A 67 01    	LHLD VAR_BASE	            ; HL = var base
1630   0732             FindVarLoop	
1631   0732 E7              RST 4	                    ; Compare HL and DE
1632   0733 CA 49 07    	JZ AllocNewVar	            ; if equal, variable not found (is new)
1633   0736 79          	MOV A,C	                    
1634   0737 96          	SUB M	                    ; is this variable the one?
1635   0738 23          	INX H	
1636   0739 C2 3E 07    	JNZ NotIt                   ; nope	
1637   073C 78          	MOV A,B	
1638   073D 96          	SUB M	                    ; try 2nd character matching
1639   073E             NotIt 
1640   073E 23              INX H	
1641   073F CA 79 07    	JZ FinPtr                   ; that was it!	
1642   0742 23          	INX H	                    ; skip over that on -- not it.
1643   0743 23          	INX H	
1644   0744 23          	INX H	
1645   0745 23          	INX H	
1646   0746 C3 32 07    	JMP FindVarLoop	
1647   0749             
1648   0749             ; Prepare to allocate a new variable.  First, check the return address to see if it is
1649   0749             ; the expression evaluator that called us, and if it is then exit without allocating.
1650   0749             ; 
1651   0749             AllocNewVar	
1652   0749 E1              POP H	                    ; HL = text pointer
1653   074A E3          	XTHL	                    ; push text ptr, HL=return addr.
1654   074B D5          	PUSH D	
1655   074C 11 ED 06    	LXI D,EvalVarTerm+3         ; DE = an EvalTerm address !!!Added Label
1656   074F E7          	RST 4	                    ; Compare HL and DE
1657   0750 D1          	POP D	
1658   0751 CA 7C 07    	JZ AlreadyAllocd            ; called by expr eval, no need to allocate	
1659   0754 E3          	XTHL	                    ; put return addr on stack, HL=text ptr.
1660   0755 E5          	PUSH H	                    ; text ptr back on stack
1661   0756 C5          	PUSH B	                    ; Preserve var name on stack
1662   0757 01 06 00    	LXI B,0006h	                ; going to insert 6 bytes...
1663   075A 2A 6B 01    	LHLD VAR_TOP	            ; current end of var storage
1664   075D E5          	PUSH H	                    ; save it
1665   075E 09          	DAD B	                    ; add on 6 bytes for new variable
1666   075F C1          	POP B	                    ; old end of storage
1667   0760 E5          	PUSH H	                    ; save new candidate for VarTop
1668   0761 CD A7 01    	CALL CopyMemoryUp	        ; move block up by 6 bytes
1669   0764 E1          	POP H	                    ; retrieve new VarTop
1670   0765 22 6B 01    	SHLD VAR_TOP	            ; and save it
1671   0768 60          	MOV H,B	                    ; now update var_array_base
1672   0769 69          	MOV L,C	                    ; to account for 6 byte move
1673   076A 22 69 01    	SHLD VAR_ARRAY_BASE	        ; and save it.
1674   076D             
1675   076D             ; initialize new variable to zero.
1676   076D             ; HL is pointing at end of new variable, so zero backwards
1677   076D             ; to DE.
1678   076D             ;
1679   076D             InitVarLoop	
1680   076D 2B              DCX H	                    ; go backwards from end of variable
1681   076E 36 00       	MVI M,00h	                ; write a zero
1682   0770 E7          	RST 4	                    ; compare HL and DE
1683   0771 C2 6D 07    	JNZ InitVarLoop	            ; loop until done
1684   0774 D1          	POP D	                    ; DE = variable name
1685   0775 73          	MOV M,E	                    ; write 1st byte of var name
1686   0776 23          	INX H	
1687   0777 72          	MOV M,D	                    ; write 2nd byte of var name
1688   0778 23          	INX H	
1689   0779             FinPtr 
1690   0779 EB              XCHG	                    ; DE = variable pointer
1691   077A E1          	POP H	                    ; restore text pointer
1692   077B C9          	RET	
1693   077C             
1694   077C             ; GetVar exit when called by EvalTerm.  Set FAC to zero.
1695   077C             ;
1696   077C             AlreadyAllocd	
1697   077C 32 72 01        STA FACCUM+3	            ; A=0 previously
1698   077F E1          	POP H	
1699   0780 C9          	RET	
1700   0781             
1701   0781             ; Accesses or allocates an array variable.  DIM_OR_EVAL flag indicates whether its a 
1702   0781             ; declaration (DIM, flag=0xEF) or just array access (Eval, flag=0).
1703   0781             ;
1704   0781             GetArrayVar	
1705   0781 C5              PUSH B	                    ; save var name on stack
1706   0782 3A 5B 01    	LDA DIM_OR_EVAL	
1707   0785 F5          	PUSH PSW	                ; save flag on stack
1708   0786 CD 8A 04    	CALL GetSubscript	        ; get array subscript in CDE
1709   0789 CF          	RST 1	                    ; Syntax Check	
1710   078A 29          	.DB 29h	                    ; for closing paren ')'	
1711   078B F1          	POP PSW	                    ; restore flag
1712   078C 32 5B 01    	STA DIM_OR_EVAL	
1713   078F E3          	XTHL	                    ; HL=var name
1714   0790 EB          	XCHG	                    ; HL=subscript; DE=var name
1715   0791 29          	DAD H	                    ; subscript x 2
1716   0792 29          	DAD H	                    ; offset = subscript x 4
1717   0793 E5          	PUSH H	                    ; push offset on stack
1718   0794 2A 69 01    	LHLD VAR_ARRAY_BASE	        ; HL = start of array storage
1719   0797 01          	.DB $01	;LXI B,....	        ; LXI trick, skip next 2 instructions
1720   0798             FindArray	
1721   0798 C1              POP B	                    ; BC = length of last variable              
1722   0799 09          	DAD B	                    ; skip over last var by adding its length
1723   079A EB          	XCHG	                    ; DE = current search point
1724   079B E5          	PUSH H	                    ; save variable name
1725   079C 2A 6B 01    	LHLD VAR_TOP	            ; HL = place to store
1726   079F E7          	RST 4	                    ; Compare HL and DE.  Are we there yet?
1727   07A0 EB          	XCHG	                    ; HL = search point
1728   07A1 D1          	POP D	                    ; pop variable name    
1729   07A2 CA C4 07    	JZ AllocArray	            ; got to end; couldn't find it
1730   07A5 F7          	RST 6	                    ; advance to next array in block...push next word
1731   07A6 E3          	XTHL	                    ; HL = var name we are examining
1732   07A7 E7          	RST 4	                    ; Compare HL and DE: Is this the variable?
1733   07A8 E1          	POP H	                    ; pop off search pointer
1734   07A9 F7          	RST 6	                    ; push length of var being examined
1735   07AA C2 98 07    	JNZ FindArray	            ; not a match, keep looking
1736   07AD 3A 5B 01    	LDA DIM_OR_EVAL	            ; is this an existing var trying to be dimensioned?
1737   07B0 B7          	ORA A	                    ; test it
1738   07B1 1E 12       	MVI E,12h	                ; Syntax Error DD
1739   07B3 C2 D5 01    	JNZ Error	
1740   07B6             L07BF	
1741   07B6 D1              POP D	                    ; pop off length of this variable
1742   07B7 1B          	DCX D	                    ; decrement length so we can use CARRY after compare
1743   07B8 E3          	XTHL	                    ; trade pointer at var with index into variable
1744   07B9 E7          	RST 4	                    ; compare HLDE.
1745   07BA 1E 10       	MVI E,10h	                ; is subscript >= number of array elements?
1746   07BC D2 D5 01    	JNC Error	                ; Bad subscript (BS) Error
1747   07BF D1          	POP D	                    ; pop off pointer to variable
1748   07C0 19          	DAD D	                    ; add it to index
1749   07C1 D1          	POP D	                    ; pop off text pointer
1750   07C2 EB          	XCHG	                    ; HL = text pointer; DE = variable pointer
1751   07C3 C9          	RET	
1752   07C4             
1753   07C4             ; Allocate space for an array.  
1754   07C4             ; Here, DE=array name and HL points to where it will be stored.
1755   07C4             AllocArray	
1756   07C4 73              MOV M,E	                    ; store array name 1st char
1757   07C5 23          	INX H	
1758   07C6 72          	MOV M,D	                    ; store array name 2nd char
1759   07C7 23          	INX H	
1760   07C8 11 2C 00    	LXI D,002Ch	                ; default size
1761   07CB 3A 5B 01    	LDA DIM_OR_EVAL	            ; are we dimensioning?
1762   07CE B7          	ORA A	                    ; test it
1763   07CF CA D8 07    	JZ NotDim                   ; jump if just evaluating
1764   07D2 D1          	POP D	                    ; we're DIM, so pop off index
1765   07D3 D5          	PUSH D	                    ; and put it back on
1766   07D4 13          	INX D	                    ; add 4
1767   07D5 13          	INX D	
1768   07D6 13          	INX D	
1769   07D7 13          	INX D	
1770   07D8             NotDim	
1771   07D8 D5              PUSH D	
1772   07D9 73          	MOV M,E	                    ; save array size LSB
1773   07DA 23          	INX H	
1774   07DB 72          	MOV M,D	                    ; save array size MSB
1775   07DC 23          	INX H	
1776   07DD E5          	PUSH H	
1777   07DE 19          	DAD D	                    ; add array size to pointer
1778   07DF CD C3 01    	CALL CheckEnoughMem	        ; make sure dont run into stack
1779   07E2 22 6B 01    	SHLD VAR_TOP	            ; save HL as new storage end
1780   07E5 D1          	POP D	
1781   07E6             InitElements	                ; init all array elements to 0
1782   07E6 2B              DCX H	
1783   07E7 36 00       	MVI M,00h	                ; write a zero
1784   07E9 E7          	RST 4	                    ; compare HL and DE
1785   07EA C2 E6 07    	JNZ InitElements	        ; keep going until all elements are 0
1786   07ED C3 B6 07    	JMP L07BF	
1787   07F0             
1788   07F0             
1789   07F0             ; ================================================================================
1790   07F0             ;             FLOATING POINT MATH PACKAGE
1791   07F0             ; ================================================================================
1792   07F0             
1793   07F0             ; Converts integer word in AB to a floating-point number.
1794   07F0             ; Interestingly, this code is never used.
1795   07F0             ;
1796   07F0             FWordToFloat	
1797   07F0 50              MOV D,B	
1798   07F1 1E 00       	MVI E,00h	
1799   07F3 06 90       	MVI B,90h	                ;exponent=2^16
1800   07F5 C3 E1 09    	JMP FCharToFloat+5	
1801   07F8             
1802   07F8             FAddOneHalf	                    ; add 0.5 to FAC
1803   07F8 21 04 0C        LXI H,ONE_HALF	            ; 0.5
1804   07FB             FAddMem	
1805   07FB CD 17 0A        CALL FLoadBCDEfromMem	    ; get argument into registers    
1806   07FE C3 09 08    	JMP FAdd+2                  ; do the addition
1807   0801             
1808   0801             ; Subtraction = addition with second term negated
1809   0801             FSub	
1810   0801 C1              POP B	                    ; Get lhs in BCDE.
1811   0802 D1          	POP D	
1812   0803 CD F1 09    	CALL FNegate	            ; Negate second argument
1813   0806 21          	.DB $21	                    ; LXI trick, skip to FAdd + 2.
1814   0807             
1815   0807             
1816   0807             ; Addition.  (FAC = ARG + FAC)
1817   0807             ; The steps for adding two numbers (lhs,rhs) is
1818   0807             ;
1819   0807             ;  1. handle special cases where either side is 0
1820   0807             ;  2. Denormalize the mantissas
1821   0807             ;  3. Align the two numbers
1822   0807             ;  4. Add the mantissas
1823   0807             ;  5. Normalize the result & store in FAC
1824   0807             ;
1825   0807             FAdd	
1826   0807 C1              POP B	                    ; Get lhs in BCDE.
1827   0808 D1          	POP D	            
1828   0809 78          	MOV A,B	                    ; If lhs=0 then we don't need
1829   080A B7          	ORA A	                    ; to do anything and can just
1830   080B C8          	RZ	                        ; exit.
1831   080C 3A 72 01    	LDA FACCUM+3	            ; If rhs=0 then exit via a copy
1832   080F B7          	ORA A	                    ; of lhs to FAC.
1833   0810 CA 09 0A    	JZ FLoadFromBCDE	
1834   0813 90          	SUB B	                    ; A=rhs.exponent-lhs.exponent.
1835   0814 D2 23 08    	JNC L082C	                ; If rhs' exponent >= lhs'exponent, jump ahead.
1836   0817 2F          	CMA	                        ; Two's complement the exponent
1837   0818 3C          	INR A	                    ; difference, so it's correct.
1838   0819 EB          	XCHG	
1839   081A CD F9 09    	CALL FPush	                ; Push old rhs
1840   081D EB          	XCHG	;
1841   081E CD 09 0A    	CALL FLoadFromBCDE	        ; rhs = old lhs
1842   0821 C1          	POP B	                    ; lhs = old rhs.
1843   0822 D1          	POP D	
1844   0823             L082C	
1845   0823 F5              PUSH PSW	                ; Preserve exponent diff
1846   0824 CD 2E 0A    	CALL FUnpackMantissas	
1847   0827 67          	MOV H,A	                    ; H=sign relationship
1848   0828 F1          	POP PSW	                    ; A=exponent diff.
1849   0829 CD C0 08    	CALL FMantissaRtMult        ; Shift lhs mantissa right by (exponent diff) places.
1850   082C B4          	ORA H	                    ; A=0 after last call, so this tests
1851   082D 21 6F 01    	LXI H,FACCUM	            ; the sign relationship.
1852   0830 F2 44 08    	JP FSubMantissas	        ; Jump ahead if we need to subtract.
1853   0833 CD A0 08    	CALL FAddMantissas	
1854   0836 D2 75 08    	JNC FRoundUp	            ; Jump ahead if that didn't overflow.
1855   0839 23          	INX H	                    ; Flip the sign in FTEMP_SIGN.
1856   083A 34          	INR M	
1857   083B CA 9B 08    	JZ Overflow	                ; Error out if exponent overflowed.
1858   083E CD CD 08    	CALL FMantissaRtOnce        ; Shift mantissa one place right
1859   0841 C3 75 08    	JMP FRoundUp	            ; Jump ahead.
1860   0844             FSubMantissas	
1861   0844 AF              XRA A
1862   0845 90          	SUB B	                    ; B=0-B
1863   0846 47          	MOV B,A	
1864   0847 7E          	MOV A,M	                    ; A=(FAC)       
1865   0848 9B          	SBB E	                    
1866   0849 5F          	MOV E,A	                    ; E=(FAC)-E
1867   084A 23          	INX H	
1868   084B 7E          	MOV A,M	                    ; A=(FAC+1)                   
1869   084C 9A          	SBB D	
1870   084D 57          	MOV D,A	                    ; D=(FAC+1)-D
1871   084E 23          	INX H	
1872   084F 7E          	MOV A,M	                    ; A=(FAC+2)                   
1873   0850 99          	SBB C	
1874   0851 4F          	MOV C,A	                    ; C=(FAC+2)-C
1875   0852             
1876   0852             ; Normalize the Mantissa in CDEB, rounded up to CDE, and stored in FAC
1877   0852             ;
1878   0852             FNormalize	
1879   0852 DC AC 08        CC FNegateInt
1880   0855 26 00        	MVI H,00h
1881   0857 79          	MOV A,C	                    ; Test most-significant bit of mantissa
1882   0858 B7          	ORA A	                    ; and jump ahead if it's 1.
1883   0859 FA 75 08    	JM FRoundUp	
1884   085C             
1885   085C                 ; Normalize the mantissa, shifting it left until bit23 is set
1886   085C             
1887   085C             NormLoop	
1888   085C FE E0           CPI $E0	                    ; If we've shifted 32 times,
1889   085E CA B5 09    	JZ FZero	                ; then the number is 0.
1890   0861 25          	DCR H	                    ; -1, then -2, etc.    
1891   0862 78          	MOV A,B	                    ; Left-shift extra mantissa byte
1892   0863 87          	ADD A	                    ; shift in a zero 
1893   0864 47          	MOV B,A	 
1894   0865 CD 87 08    	CALL FMantissaLeft	        ; Left-shift mantissa
1895   0868 7C          	MOV A,H	                    ; get the shift count
1896   0869 F2 5C 08    	JP NormLoop	                ; Loop until bit23 set (msb of reg C)
1897   086C             
1898   086C                 ; Adjust the exponent by the number of left-shifts done to the mantissa
1899   086C             
1900   086C 21 72 01    	LXI H,FACCUM+3              ; get current exponent	
1901   086F 86          	ADD M	                    ; add negative number
1902   0870 77          	MOV M,A                     ; Since A was a -ve number, that certainly should
1903   0871 D2 B5 09    	JNC FZero	                ; have carried, hence the extra check for zero.
1904   0874 C8          	RZ	                        
1905   0875             
1906   0875             ; Round result in CDEB and put number in FAC
1907   0875             ; Round up or down depending on MSB of B
1908   0875             ;
1909   0875             FRoundUp	
1910   0875 78              MOV A,B	                    ; see if we should round up
1911   0876 21 72 01    	LXI H,FACCUM+3	
1912   0879 B7          	ORA A	                    ; If bit 7 of the extra mantissa byte
1913   087A FC 91 08    	CM FMantissaInc	            ; is set, then round up the mantissa.
1914   087D 46          	MOV B,M	                    ; B=exponent
1915   087E 23          	INX H	                    ; point to sign
1916   087F 7E          	MOV A,M	                    ; get sign in A
1917   0880 E6 80       	ANI $80	                    ; get rid of unwanted bits
1918   0882 A9          	XRA C	                    ; pack sign and HO
1919   0883 4F          	MOV C,A	                    ; save it in C
1920   0884 C3 09 0A    	JMP FLoadFromBCDE	        ; save number in BCDE to FAC.
1921   0887             
1922   0887             ; Shift the mantissa in CDE left by one bit
1923   0887             ;
1924   0887             FMantissaLeft	
1925   0887 7B              MOV A,E	                    ; do Reg E (lowest order) first
1926   0888 17          	RAL	                        ; shift left with carry
1927   0889 5F          	MOV E,A	                    ; save E
1928   088A 7A          	MOV A,D	                    ; now do Reg D
1929   088B 17          	RAL	                        ; shift left with carry
1930   088C 57          	MOV D,A	                    ; and save D
1931   088D 79          	MOV A,C	                    ; now do C (Highest Order)
1932   088E 8F          	ADC A	                    ; shift left with carry
1933   088F 4F          	MOV C,A	                    ; and save C
1934   0890 C9          	RET
1935   0891             
1936   0891             ; Increment mantissa in CDE and handle overflow	
1937   0891             ;
1938   0891             FMantissaInc                    
1939   0891 1C              INR E	                    ; add one to the lower order
1940   0892 C0          	RNZ	                        ; all done if it is not zero
1941   0893 14          	INR D	                    ; add one to next highest order
1942   0894 C0          	RNZ	                        ; all done if no overflow
1943   0895 0C          	INR C	
1944   0896 C0          	RNZ	
1945   0897 0E 80       	MVI C,80h	                ; Mantissa overflowed to zero, so set it
1946   0899 34          	INR M	                    ; to 1 and increment the exponent.
1947   089A C0          	RNZ	                        ; And if the exponent overflows...
1948   089B             Overflow	
1949   089B 1E 0A           MVI E,0Ah	
1950   089D C3 D5 01    	JMP Error
1951   08A0             
1952   08A0             ; Add mantissa pointed to by HL to the one in CDE
1953   08A0             ;
1954   08A0             FAddMantissas	                
1955   08A0 7E              MOV A,M	
1956   08A1 83          	ADD E	                    ; do reg E (LO) first
1957   08A2 5F          	MOV E,A	
1958   08A3 23          	INX H	
1959   08A4 7E          	MOV A,M	
1960   08A5 8A          	ADC D	                    ; do reg D, next highest order
1961   08A6 57          	MOV D,A	
1962   08A7 23          	INX H	
1963   08A8 7E          	MOV A,M	
1964   08A9 89          	ADC C	                    ; and finally reg C, highest order
1965   08AA 4F          	MOV C,A	
1966   08AB C9          	RET	
1967   08AC             
1968   08AC             ; Negate the 32-bit integer in CDEB by subtracting it from zero.
1969   08AC             ; It also flips the sign in FTEMP.
1970   08AC             ; Called by FAsInteger and FAdd.
1971   08AC             ;
1972   08AC             FNegateInt	
1973   08AC 21 73 01        LXI H,FTEMP	
1974   08AF 7E          	MOV A,M	
1975   08B0 2F          	CMA	
1976   08B1 77          	MOV M,A	
1977   08B2 AF          	XRA A	
1978   08B3 6F          	MOV L,A	
1979   08B4 90          	SUB B	
1980   08B5 47          	MOV B,A	
1981   08B6 7D          	MOV A,L	
1982   08B7 9B          	SBB E	
1983   08B8 5F          	MOV E,A	
1984   08B9 7D          	MOV A,L	
1985   08BA 9A          	SBB D	
1986   08BB 57          	MOV D,A	
1987   08BC 7D          	MOV A,L	
1988   08BD 99          	SBB C	
1989   08BE 4F          	MOV C,A	
1990   08BF C9          	RET	
1991   08C0             
1992   08C0             ; Shift the mantissa in CDE by 'A' places.
1993   08C0             ; Note that lost bits end up in B
1994   08C0             ;
1995   08C0             FMantissaRtMult	
1996   08C0 06 00           MVI B,00h	                ; Initialise extra mantissa byte
1997   08C2 3C          	INR A	
1998   08C3 6F          	MOV L,A	
1999   08C4             RtMultLoop	
2000   08C4 AF              XRA A	
2001   08C5 2D          	DCR L	
2002   08C6 C8          	RZ	
2003   08C7 CD CD 08    	CALL FMantissaRtOnce	
2004   08CA C3 C4 08    	JMP RtMultLoop	
2005   08CD             
2006   08CD             ; Shift the mantissa in CDE one bit right
2007   08CD             ;
2008   08CD             FMantissaRtOnce	
2009   08CD 79              MOV A,C	
2010   08CE 1F          	RAR	
2011   08CF 4F          	MOV C,A	
2012   08D0 7A          	MOV A,D	
2013   08D1 1F          	RAR	
2014   08D2 57          	MOV D,A	
2015   08D3 7B          	MOV A,E	
2016   08D4 1F          	RAR	
2017   08D5 5F          	MOV E,A	
2018   08D6 78          	MOV A,B	                    ; NB: B is the extra
2019   08D7 1F          	RAR	                        ; mantissa byte.
2020   08D8 47          	MOV B,A	
2021   08D9 C9          	RET	
2022   08DA             
2023   08DA             ; Multiplication
2024   08DA             ;
2025   08DA             ; The steps for multiplying two numbers (lhr,rhs) is:
2026   08DA             ;  1. Exit if rhs=0
2027   08DA             ;  2. Add the lhs and rhs exponents
2028   08DA             ;  3. Initialize result mantissa to 0
2029   08DA             ;  4. Get rightmost bit of rhs
2030   08DA             ;  5. If this bit is set then add the lsh mantissa to result mantissa
2031   08DA             ;  6. Shift result mantissa one bit to the right
2032   08DA             ;  7. Get next bit of rhs mantissa.  If not done, loop back to #5
2033   08DA             ;  8. When all 24 bits done, Normalize the result.
2034   08DA             ;
2035   08DA             FMul	
2036   08DA C1              POP B	                    ; Get lhs in BCDE
2037   08DB D1          	POP D	
2038   08DC EF          	RST 5	                    ; FTestSign	If rhs==0 then exit
2039   08DD C8          	RZ	
2040   08DE 2E 00       	MVI L,00h	                ; L=0 to signify exponent add
2041   08E0 CD 92 09    	CALL FExponentAdd	
2042   08E3 79          	MOV A,C	
2043   08E4 32 0E 09    	STA FMulInnerLoop+13	
2044   08E7 EB          	XCHG	
2045   08E8 22 09 09    	SHLD FMulInnerLoop+8	
2046   08EB 01 00 00    	LXI B,0000h	
2047   08EE 50          	MOV D,B	
2048   08EF 58          	MOV E,B	
2049   08F0 21 55 08    	LXI H,FNormalize+3	
2050   08F3 E5          	PUSH H	
2051   08F4 21 FC 08    	LXI H,FMulOuterLoop	
2052   08F7 E5          	PUSH H	
2053   08F8 E5          	PUSH H	
2054   08F9 21 6F 01    	LXI H,FACCUM	
2055   08FC             FMulOuterLoop	
2056   08FC 7E              MOV A,M	                    ; A=FAC mantissa byte
2057   08FD 23          	INX H	
2058   08FE E5          	PUSH H	                    ; Preserve FAC ptr
2059   08FF 2E 08       	MVI L,08h	                ; 8 bits to do
2060   0901             FMulInnerLoop	
2061   0901 1F              RAR	                        ; Test lowest bit of mantissa byte
2062   0902 67          	MOV H,A	                    ; Preserve mantissa byte
2063   0903 79          	MOV A,C	                    ; A=result mantissa's high byte
2064   0904 D2 10 09    	JNC L0919	                ; If that bit of multiplicand was 0, 
2065   0907                                             ; then skip over adding mantissas.
2066   0907 E5          	PUSH H	
2067   0908 21 00 00    	LXI H,0000h	
2068   090B 19          	DAD D	
2069   090C D1          	POP D	
2070   090D CE 00       	ACI 00	                    ; A=result mantissa high byte. This gets back to C
2071   090F EB          	XCHG	                    ; in the call to FMantissaRtOnce+1.
2072   0910             L0919	
2073   0910 CD CE 08        CALL FMantissaRtOnce+1	
2074   0913 2D          	DCR L	
2075   0914 7C          	MOV A,H	                    ; Restore mantissa byte and
2076   0915 C2 01 09    	JNZ FMulInnerLoop	        ; jump back if L is not yet 0.
2077   0918             PopHLandReturn	
2078   0918 E1              POP H	                    ; Restore FAC ptr
2079   0919 C9          	RET	
2080   091A             
2081   091A             ; Divide by Ten.  Used in FOut to bring the number into range before printing
2082   091A             ;
2083   091A             FDivByTen	
2084   091A CD F9 09        CALL FPush	                ; save number
2085   091D 01 20 84    	LXI B,8420h	                ; BCDE=(float)10;
2086   0920 11 00 00    	LXI D,0000h	
2087   0923 CD 09 0A    	CALL FLoadFromBCDE	                    
2088   0926             
2089   0926             FDiv	
2090   0926 C1              POP B	 
2091   0927 D1          	POP D	
2092   0928 EF          	RST 5	                    ; check for division by zero 
2093   0929 CA D3 01    	JZ DivideByZero	            ; not so fast
2094   092C 2E FF       	MVI L,$FF	                ; subtract exponents, L is flag
2095   092E CD 92 09    	CALL FExponentAdd	
2096   0931 34          	INR M	                    ; add 2 to exponent to correct scaling
2097   0932 34          	INR M	                    
2098   0933 2B          	DCX H	                    ; point to highest order of FAC
2099   0934 7E          	MOV A,M	                    ; get MSB
2100   0935 32 57 09    	STA FDivA+1                 ; and save it.
2101   0938 2B          	DCX H	                    ; point to middle order byte
2102   0939 7E          	MOV A,M	
2103   093A 32 53 09    	STA FDivB+1                 ; put it where nothing will hurt it
2104   093D 2B          	DCX H	                    ; point to lowest order byte
2105   093E 7E          	MOV A,M	                    
2106   093F 32 4F 09    	STA FDivC+1	                ; and save LO
2107   0942             
2108   0942             ; The numerator will be kept in BHL.  The quotient will be formed in CDE.
2109   0942             ; To get a bit of the quotient, we first save BHL on the stack, then
2110   0942             ; subtract the denominator that we saved in memory.  The carry indicates
2111   0942             ; whether or not BHL was bigger than the denominator.  If BHL was bigger, 
2112   0942             ; the next bit of the quotient is a 1.  To get the old BHL off the stack,
2113   0942             ; we pop them into the PSW.  If the denominaor was bigger, the next bit of
2114   0942             ; the quotient is 9, and we get the old BHL back by popping it off the 
2115   0942             ; stack.  We have to keep an extra bit of the quotient in FDIVG+1 in case the
2116   0942             ; denominator was bigger, then BHL will get shifted left.  If the MSB of
2117   0942             ; B was one, it has to be stored somewhere, so we store in FDIVG+1.   Then 
2118   0942             ; the next time through the loop BHL will look bigger because it has an
2119   0942             ; extra HO bit in FDIVG+1.  We are done dividing when the MSB of C is a one.
2120   0942             ; This occures when we have calculated 24 bits of the quotient.  When we jump
2121   0942             ; to Round, the 25tgh bit of the quotient determines whether we round or not.
2122   0942             ; It is in the MSB of A.  If initially the denominator is bigger then the 
2123   0942             ; numerator, the first bit of the quotient will be zero.  This mean we
2124   0942             ; will go through the divide loop 26 times, since it stops on the 25th bit
2125   0942             ; after the first non-zero bit of the exponent.  So, this quotient will look
2126   0942             ; shifted left one from the quotient of two numbers in which the numerator is
2127   0942             ; bigger.  This can occur only on the first time through the loop, so CDE
2128   0942             ; are all zero.  So, if we finish the loop in CDE are all zero, then we
2129   0942             ; must decrement the exponent to correct for this.
2130   0942             
2131   0942 41          	MOV B,C	                    ; get number in BHL
2132   0943 EB          	XCHG	
2133   0944 AF          	XRA A	                    ; zero CDE and highest order
2134   0945 4F          	MOV C,A	
2135   0946 57          	MOV D,A	
2136   0947 5F          	MOV E,A	
2137   0948 32 5A 09    	STA FDivG+1	
2138   094B             FDivLoop	
2139   094B E5              PUSH H	                    ; save LO's of number
2140   094C C5          	PUSH B	                    ; save HO of number
2141   094D 7D          	MOV A,L	                    ; subtract number that was in FAC
2142   094E             FDivC:
2143   094E D6 00       	SUI 00h	                    ; subtract LO
2144   0950 6F          	MOV L,A	                    ; and save it
2145   0951 7C          	MOV A,H	                    
2146   0952             FDivB:
2147   0952 DE 00       	SBI 00	                    ; subtract MO (Middle Order)
2148   0954 67          	MOV H,A	                    ; and save it
2149   0955 78          	MOV A,B	
2150   0956             FDivA: 
2151   0956 DE 00           SBI 00	                    ; subtract HO
2152   0958 47          	MOV B,A	                    ; and save it
2153   0959             FDivG:
2154   0959 3E 00       	MVI A,00h	                ; get highest order
2155   095B DE 00       	SBI 00	                    ; subtract the carry from it
2156   095D 3F          	CMC	                        ; set carry to correspond to next quotient bit
2157   095E D2 68 09    	JNC FDiv2	                ; get old number bvack if subtracted too much
2158   0961 32 5A 09    	STA FDivG+1                 ; update highest order	
2159   0964 F1          	POP PSW	                    ; the subtraction was good
2160   0965 F1          	POP PSW	                    ; get previous number off stack
2161   0966 37          	STC	                        ; next bit in quotient is a one
2162   0967 D2          	.DB $D2	;JNC ....	        ; jnc around next 2 bytes
2163   0968             FDiv2:
2164   0968 C1              POP B	                    ; we subtracted too much
2165   0969 E1          	POP H	                    ; get old number back
2166   096A 79          	MOV A,C	                    ; are we done?
2167   096B 3C          	INR A	                    ; set sign flag without affecting carry
2168   096C 3D          	DCR A	                    
2169   096D 1F          	RAR	                        ; put carry in MSB
2170   096E FA 76 08    	JM FRoundUp+1	            ; we are done
2171   0971 17          	RAL	                        ; we arent done, get old carry back
2172   0972 CD 87 08    	CALL FMantissaLeft	        ; rotate everything left one
2173   0975 29          	DAD H	                    ; rotate a zero into right end of number
2174   0976 78          	MOV A,B	                    ; the HO byte, finally!
2175   0977 17          	RAL	
2176   0978 47          	MOV B,A	
2177   0979 3A 5A 09    	LDA FDivG+1                 ; rotate the highest order	
2178   097C 17          	RAL	
2179   097D 32 5A 09    	STA FDivG+1	
2180   0980 79          	MOV A,C	                    ; +1 to exponent if the 1st subtraction
2181   0981 B2          	ORA D	                    ; did not work
2182   0982 B3          	ORA E	
2183   0983 C2 4B 09    	JNZ FDivLoop	            ; this isn't the case
2184   0986 E5          	PUSH H	                    ; save part of number
2185   0987 21 72 01    	LXI H,FACCUM+3	            ; get pointer to FAC
2186   098A 35          	DCR M	                    ; decrement exponent
2187   098B E1          	POP H	                    ; get number back
2188   098C C2 4B 09    	JNZ FDivLoop	            ; divide more if no overflow occured
2189   098F C3 9B 08    	JMP Overflow	            ; oops, overflow!
2190   0992             
2191   0992             ; This code is called by FMul and FDiv.  It's main job is to add (for FMul) or subtract
2192   0992             ; (for FDiv) the binary exponents of the two arguments.
2193   0992             ; on entry, L=0 for additon/Multiplication and L=FF for subtraction/Division
2194   0992             ;
2195   0992             FExponentAdd	
2196   0992 78              MOV A,B	                    ; BCDE=0?
2197   0993 B7          	ORA A	                    ; test it
2198   0994 CA B1 09    	JZ MulDv2                   ; if it is, zero FAC & we are done
2199   0997 7D          	MOV A,L	                    ; A=0 for add, FF for subtract.
2200   0998 21 72 01    	LXI H,FACCUM+3	            ; get pointer to exponent
2201   099B AE          	XRA M	                    ; get FAC exponent
2202   099C 80          	ADD B	                    ; Add in register exponent
2203   099D 47          	MOV B,A	                    ; save it
2204   099E 1F          	RAR	                        ; check for overflow
2205   099F A8          	XRA B	                    ; overflow if sign is same as carry
2206   09A0 78          	MOV A,B	                    ; get sum
2207   09A1 F2 B0 09    	JP MulDv1                   ; we have an overflow!
2208   09A4 C6 80       	ADI $80	                    ; add exponent bias     
2209   09A6 77          	MOV M,A	                    ; and save it in the FAC
2210   09A7 CA 18 09    	JZ PopHLandReturn	        ; we have underflow!
2211   09AA CD 2E 0A    	CALL FUnpackMantissas	    ; unpack the arguments
2212   09AD 77          	MOV M,A	                    ; save the new sign
2213   09AE 2B          	DCX H	                    ; point to exponent
2214   09AF C9          	RET                         ; all done, leave HO in A
2215   09B0             MulDv1:	
2216   09B0 B7          	ORA A	                    ; is error overflow or underflow?
2217   09B1             MulDv2:
2218   09B1 E1          	POP H	                    ; get old return addr off stack
2219   09B2 FA 9B 08    	JM Overflow                 ; Overflow!	
2220   09B5                                             ; Underflow.. fall into FZero below
2221   09B5             
2222   09B5             ; set the floating point accumulator to zero.
2223   09B5             ; Zero is stored in a special way: the exponent is zero'd without bias
2224   09B5             ;
2225   09B5             FZero	
2226   09B5 AF              XRA A	                    ; A=0
2227   09B6 32 72 01    	STA FACCUM+3	            ; set exponent=0, that means FAC=0.
2228   09B9 C9          	RET	
2229   09BA             
2230   09BA             ; Multiply FAC by ten, as fast as possible
2231   09BA             ;
2232   09BA             FMulByTen	
2233   09BA CD 14 0A        CALL FCopyToBCDE	        ; get number into registers
2234   09BD 78          	MOV A,B	                    ; get exponent
2235   09BE B7          	ORA A	                    ; result zero if arg is zero...
2236   09BF C8          	RZ	                        ; and it is
2237   09C0 C6 02       	ADI 02	                    ; adding 2 to exponent = multiply by 4
2238   09C2 DA 9B 08    	JC Overflow	                ; oops, overflow
2239   09C5 47          	MOV B,A	                    ; restore exponent
2240   09C6 CD 09 08    	CALL FAdd+2	                ; add in orginal number = multiply by 5    
2241   09C9 21 72 01    	LXI H,FACCUM+3	            ; point to exponent again
2242   09CC 34          	INR M	                    ; +1 exponent = doubling = overall multiply by 10
2243   09CD C0          	RNZ	                        ; all done if no overflow
2244   09CE C3 9B 08    	JMP Overflow	            ; overflow
2245   09D1             
2246   09D1             ; When FAC is non-zero, RST FTestSign jumps here to get the sign as an integer
2247   09D1             ; returns 01 = positive, FF=regative
2248   09D1             ;
2249   09D1             FTestSign_tail	
2250   09D1 3A 71 01        LDA FACCUM+2                ; look at MSB of mantissas	
2251   09D4 FE          	.DB $FE	                    ; skip over next instruction
2252   09D5             InvSignToInt	
2253   09D5 2F              CMA	                        ; inverts sign bit in A
2254   09D6             SignToInt	
2255   09D6 17              RAL	                        ; rotate sign bit (bit7) into carry
2256   09D7 9F          	SBB A	                    ; FF if carry set, 0 otherwise
2257   09D8 C0          	RNZ	                        ; returns if sign bit was set 
2258   09D9 3C          	INR A	                    ; change A=0 to A=1, setting flags
2259   09DA C9          	RET	
2260   09DB             
2261   09DB             ; Returns an integer that indicates FAC's sign.
2262   09DB             ; First, call FTestSign which gets answer in A, then fall into
2263   09DB             ; FCharToFloat to get that answer back into the FAC
2264   09DB             ;
2265   09DB             Sgn	
2266   09DB EF              RST 5	                    ; FTestSign	
2267   09DC             
2268   09DC             ; Convert a signed byte in A to a floating-point number in FAC
2269   09DC             ;
2270   09DC             FCharToFloat	
2271   09DC 06 88           MVI B,88h	                ; set exponent correctly
2272   09DE 11 00 00    	LXI D,0000h	                ; zero DE
2273   09E1 21 72 01    	LXI H,FACCUM+3              ; get pointer to FAC
2274   09E4 4F          	MOV C,A	                    ; registers now have A as unnormalized FP number
2275   09E5 70          	MOV M,B	                    ; set FAC exponent to 2^8
2276   09E6 06 00       	MVI B,00h	                ; zero overflow byte
2277   09E8 23          	INX H	                    ; point to FTEMP
2278   09E9 36 80       	MVI M,80h	                ; set it to x80 in prep for FNormalize
2279   09EB 17          	RAL	                        ; put sign flag into carry 
2280   09EC C3 52 08    	JMP FNormalize              ; go float the number
2281   09EF             
2282   09EF             ; Absolute function:  FAC = |FAC|
2283   09EF             ;
2284   09EF             Abs	
2285   09EF EF              RST 5	                    ; FTestSign	
2286   09F0 F0          	RP                          ; if FAC positive, we are done
2287   09F1             
2288   09F1             FNegate	                        ; negate sign in FAC
2289   09F1 21 71 01        LXI H,FACCUM+2	
2290   09F4 7E          	MOV A,M	                    ; get MSB into A
2291   09F5 EE 80       	XRI $80	                    ; flip the sign bit
2292   09F7 77          	MOV M,A	                    ; and save it
2293   09F8 C9          	RET	
2294   09F9             
2295   09F9             ; Push the Floating point accumulator on the stack
2296   09F9             ;
2297   09F9             FPush	
2298   09F9 EB              XCHG                        ; save HL	
2299   09FA 2A 6F 01    	LHLD FACCUM	                ; get LO's
2300   09FD E3          	XTHL	                    ; swap LO's and return addr
2301   09FE E5          	PUSH H	                    ; put ret addr back on stack
2302   09FF 2A 71 01    	LHLD FACCUM+2	            ; get HO's
2303   0A02 E3          	XTHL	                    ; switch HO's and return addr
2304   0A03 E5          	PUSH H	                    ; put ret addr back on stack
2305   0A04 EB          	XCHG	                    ; get old HL back
2306   0A05 C9          	RET	                        ; all done
2307   0A06             
2308   0A06             ; Move number from memory (HL) into FAC
2309   0A06             ;
2310   0A06             FLoadFromMem	
2311   0A06 CD 17 0A        CALL FLoadBCDEfromMem	    ; get number into registers
2312   0A09             FLoadFromBCDE	
2313   0A09 EB              XCHG	                    ; put DE part of mantissa (LO's) in HL
2314   0A0A 22 6F 01    	SHLD FACCUM	                ; store it in FAC
2315   0A0D 60          	MOV H,B	                    ; get BV part of mantiissa (HO's) in HL
2316   0A0E 69          	MOV L,C	                    
2317   0A0F 22 71 01    	SHLD FACCUM+2	            ; store it at FACCUM+2
2318   0A12 EB          	XCHG	                    ; get old HL back
2319   0A13 C9          	RET	
2320   0A14             
2321   0A14             FCopyToBCDE	
2322   0A14 21 6F 01        LXI H,FACCUM                ; point to FAC	
2323   0A17             FLoadBCDEfromMem	
2324   0A17 5E              MOV E,M	                    ; get LO
2325   0A18 23          	INX H	                    ; point to MO
2326   0A19 56          	MOV D,M	                    ; get MO
2327   0A1A 23          	INX H	                    ; point to HO
2328   0A1B 4E          	MOV C,M	                    ; get HO
2329   0A1C 23          	INX H	                    ; point to exponent
2330   0A1D 46          	MOV B,M	                    ; get exponent
2331   0A1E             IncHLReturn	
2332   0A1E 23              INX H	                    ; point to beginning of next number
2333   0A1F C9          	RET	                        ; and done
2334   0A20             
2335   0A20             ; Move number from FAC to memory (HL)
2336   0A20             ;
2337   0A20             FCopyToMem	
2338   0A20 11 6F 01        LXI D,FACCUM	            ; get pointer to FAC
2339   0A23 06 04       	MVI B,04h	                ; count 4 bytes to copy
2340   0A25             FCopyLoop	
2341   0A25 1A              LDAX D	                    ; get byte from FAC
2342   0A26 77          	MOV M,A	                    ; and store in in memory
2343   0A27 13          	INX D	                    ; increment pointers
2344   0A28 23          	INX H	
2345   0A29 05          	DCR B	                    ; decrement counter
2346   0A2A C2 25 0A    	JNZ FCopyLoop	            ; loop until done
2347   0A2D C9          	RET	
2348   0A2E             
2349   0A2E             ; The numbers in the BCDE and in the FAC are unpacked, with the assumed '1' in the mantissas
2350   0A2E             ; restored.  A XOR combination of both (register and FAC) sign bits is stored in
2351   0A2E             ; FTEMP_SIGN.  On return, A is positive if the signs were different and negative if the
2352   0A2E             ; signs were the same.
2353   0A2E             ;
2354   0A2E             FUnpackMantissas	
2355   0A2E 21 71 01        LXI H,FACCUM+2	            ; point to HO/sign
2356   0A31 7E          	MOV A,M	                    ; get HO/sign
2357   0A32 07          	RLC	                        ; Move FAC's sign to bit 0.
2358   0A33 37          	STC	                        ; Set MSB of FAC mantissa,
2359   0A34 1F          	RAR	                        ; FAC's sign is now in carry.
2360   0A35 77          	MOV M,A	
2361   0A36 3F          	CMC	                        ; Negate FAC's sign.
2362   0A37 1F          	RAR	                        ; Bit 7 of A is now FAC's sign.
2363   0A38 23          	INX H	                    ; Store negated FAC sign @ FTEMP_SIGN.
2364   0A39 23          	INX H	
2365   0A3A 77          	MOV M,A	
2366   0A3B 79          	MOV A,C	
2367   0A3C 07          	RLC	                        ; Set MSB of BCDE mantissa,
2368   0A3D 37          	STC	                        ; BCDE's sign is now in carry.
2369   0A3E 1F          	RAR	
2370   0A3F 4F          	MOV C,A	
2371   0A40 1F          	RAR	                        ; Bit 7 of A is now BCDE's sign
2372   0A41 AE          	XRA M	                    ; XORed with FTEMP_SIGN.
2373   0A42 C9          	RET	
2374   0A43             
2375   0A43             ; Compares FACCUM to BCDE, with the result being returned in A as follows :
2376   0A43             ; FACCUM > BCDE, A = 0x01.
2377   0A43             ; FACCUM < BCDE, A = 0xFF.
2378   0A43             ; FACCUM = BCDE, A = 0.   
2379   0A43             ;    
2380   0A43             FCompare	
2381   0A43 78              MOV A,B	                    
2382   0A44 B7          	ORA A	                    ; is BCDE is zero (B=0)?        
2383   0A45 CA 28 00    	JZ FTestSign	            ; if so, no need to compare
2384   0A48 21 D5 09    	LXI H,InvSignToInt	     
2385   0A4B E5          	PUSH H	                    ; set return addr to InvSignToInt
2386   0A4C EF          	RST 5	                    ; Test FACCUM's sign
2387   0A4D 79          	MOV A,C	
2388   0A4E C8          	RZ	
2389   0A4F 21 71 01    	LXI H,FACCUM+2	
2390   0A52 AE          	XRA M	
2391   0A53 79          	MOV A,C	
2392   0A54 F8          	RM	
2393   0A55 CD 5B 0A    	CALL FIsEqual               ; test for equality
2394   0A58 1F              RAR                         ; get carry into A bit 7	
2395   0A59 A9          	XRA C	
2396   0A5A C9          	RET	
2397   0A5B             
2398   0A5B             ; Test for equality between FAC and BCDE
2399   0A5B             ;
2400   0A5B             FIsEqual	
2401   0A5B 23              INX H	                    ; point to exponent
2402   0A5C 78          	MOV A,B	                    ; and exponent of argument
2403   0A5D BE          	CMP M	                    ; compare the two
2404   0A5E C0          	RNZ	                        ; numbers are different
2405   0A5F 2B          	DCX H	                    ; point to HO
2406   0A60 79          	MOV A,C	                    ; get HO of arg
2407   0A61 BE          	CMP M	                    ; compare with HO of FAC
2408   0A62 C0          	RNZ	                        ; they are different
2409   0A63 2B          	DCX H	                    ; point to MO of FAC
2410   0A64 7A          	MOV A,D	                    ; get MO of arg
2411   0A65 BE          	CMP M	                    ; compare with MO of FAC
2412   0A66 C0          	RNZ	                        ; they are different
2413   0A67 2B          	DCX H	                    ; point to LO of FAC
2414   0A68 7B          	MOV A,E	                    ; get MO of argument
2415   0A69 96          	SUB M	                    ; subtract LO of FAC
2416   0A6A C0          	RNZ	                        ; numbers are different
2417   0A6B E1          	POP H	                    ; BCDE=FAC, so drop 1st return addr
2418   0A6C E1          	POP H	                    ; and second return addr
2419   0A6D C9          	RET	                        ; Return to caller of FCompare instead
2420   0A6E             
2421   0A6E             ; Return the integer part of FAC in CDE
2422   0A6E             ;
2423   0A6E             ; The hard case is negative non-integers.  To handle this, if the number is negative,
2424   0A6E             ; we regard the 3-byte mantissa as a 3-byte integer and subtract one.  Then all the
2425   0A6E             ; fractional bits are shifted out by shifting the mantissa right.  Then, if the number is
2426   0A6E             ; negative, we add one.  So, if we had a negative integer, all the bits to the right of the
2427   0A6E             ; binary point were zero.  So the net effect is we have the original number in CDE.  If the
2428   0A6E             ; number is a negative non-integer, there is at least one non-zero bit to the right of the
2429   0A6E             ; binary point, so the net effect is that we get the absolute value of int(fac) in CDE.
2430   0A6E             ; CDE is then negated if the orginal number was negative so the result will be signed.
2431   0A6E             ;
2432   0A6E             FAsInteger	
2433   0A6E 47              MOV B,A	                    ; set BCDE = 0
2434   0A6F 4F          	MOV C,A	
2435   0A70 57          	MOV D,A	
2436   0A71 5F          	MOV E,A	
2437   0A72 B7          	ORA A	                    ; if A=0
2438   0A73 C8          	RZ	                        ; special case done
2439   0A74 E5          	PUSH H	                    ; save HL on stack
2440   0A75 CD 14 0A    	CALL FCopyToBCDE	        ; copy FAC to BCDE
2441   0A78 CD 2E 0A    	CALL FUnpackMantissas	    ; restore assumed '1' bit
2442   0A7B AE          	XRA M	                    ; Get sign back
2443   0A7C 67          	MOV H,A	                    ; save the sign in H
2444   0A7D FC 92 0A    	CM FMantissaDec             ; subtract 1 from LO if number is negative            	
2445   0A80 3E 98       	MVI A,98h	                ; see how many we have to shift to change
2446   0A82 90          	SUB B	                    ;   the number to an integer
2447   0A83 CD C0 08    	CALL FMantissaRtMult	    ; shift number to get rid of fractional bits
2448   0A86 7C          	MOV A,H	                    ; get sign
2449   0A87 17          	RAL	                        ; put sign in carry bit so it will not be changed
2450   0A88 DC 91 08    	CC FMantissaInc	            ; if number was negative, add one
2451   0A8B 06 00       	MVI B,00h	                ; forget the bits we shifted out
2452   0A8D DC AC 08    	CC FNegateInt	            ; negate number if it was negative because
2453   0A90                                             ; wanted a signed mantissa
2454   0A90 E1          	POP H	                    ; get old HL back
2455   0A91 C9          	RET	
2456   0A92             
2457   0A92             ; Decrement the mantissa in CDE
2458   0A92             ;
2459   0A92             FMantissaDec	
2460   0A92 1B              DCX D	                    ; start by subtracting 1 from DE
2461   0A93 7A          	MOV A,D	                    ; we have to subtract one from C if
2462   0A94 A3          	ANA E	                    ; D and E are both FF...
2463   0A95 3C          	INR A	                    ; see if they both were FF
2464   0A96 C0          	RNZ	                        ; they were not, we are done
2465   0A97 0D          	DCR C	                    ; they were, so subtract one from C
2466   0A98 C9          	RET
2467   0A99             
2468   0A99             ; Remove the fractional part of FAC
2469   0A99             ;
2470   0A99             Int	    
2471   0A99 21 72 01        LXI H,FACCUM+3	            ; point to FAC exponent
2472   0A9C 7E          	MOV A,M                     ; get it	
2473   0A9D FE 98       	CPI $98	                    ; is it >= 2^24?
2474   0A9F D0          	RNC	                        ; too big to hold fraction; already an int
2475   0AA0 CD 6E 0A    	CALL FAsInteger	            ; convert FAC to integer in CDE.  HL points to exponent
2476   0AA3 36 98       	MVI M,98h	                ; change exponent to 2^24
2477   0AA5 79          	MOV A,C	                    
2478   0AA6 17          	RAL	
2479   0AA7 C3 52 08    	JMP FNormalize
2480   0AAA             
2481   0AAA             ; Reads a string and converts it to a floating point number in FAC.
2482   0AAA             ;
2483   0AAA             ; At Entry, HL points to the first character in the text buffer and the first char is
2484   0AAA             ; also in A.  We pack the digits into the FAC as an integer and keep track of where
2485   0AAA             ; the decimal point is.  C=FF if we have not seen a decimal point, C=0 if we have.
2486   0AAA             ; B is the number of digits after the decimal point.  At the end, B and the exponent (in E)
2487   0AAA             ; are used to determine how many times we multiply or divide by ten to get the
2488   0AAA             ; correct number.
2489   0AAA             ;
2490   0AAA             FIn	
2491   0AAA 2B              DCX H	
2492   0AAB CD B5 09    	CALL FZero	                ; start with FAC=0
2493   0AAE 47          	MOV B,A	                    ; B=count of fractional digits
2494   0AAF 57          	MOV D,A	                    ; D=exponent sign (FF for minus, 01 for plus)
2495   0AB0 5F          	MOV E,A	                    ; E=exponent
2496   0AB1 2F          	CMA	                        ; C= decimal point flag ($FF for no, $00 for yes)
2497   0AB2 4F          	MOV C,A	
2498   0AB3             FInLoop	
2499   0AB3 D7              RST 2	                    ; get the next char in string	
2500   0AB4 DA FB 0A    	JC ProcessDigit	            ; if its a digit, process it below
2501   0AB7 FE 2E       	CPI '.'	                    ; is it a decimal point?
2502   0AB9 CA DB 0A    	JZ L0AE4	                ; yes, handle below
2503   0ABC FE 45       	CPI 'E'	                    ; only other choice is 'E' for exponent
2504   0ABE C2 DF 0A    	JNZ ScaleResult	            ; if not that, end of number has been reached
2505   0AC1             GetExponent	
2506   0AC1 D7              RST 2	                    ; get first character of exponent (after E)	
2507   0AC2 15          	DCR D	                    ; set sign of exponent flag
2508   0AC3 FE 99       	CPI $99	                    ; is it a negative exponent?
2509   0AC5 CA CF 0A    	JZ NextExponentDigit	    ; yes
2510   0AC8 14          	INR D	                    ; no, so reset flag
2511   0AC9 FE 98       	CPI $98	                    ; ignore "+"
2512   0ACB CA CF 0A    	JZ NextExponentDigit	
2513   0ACE 2B          	DCX H	                    ; check if last char was a digit
2514   0ACF             NextExponentDigit	
2515   0ACF D7              RST 2	                    ; get next character	
2516   0AD0 DA 1A 0B    	JC DoExponentDigit	        ; is it a digit?
2517   0AD3 14          	INR D	                    ; no, so exponent all in
2518   0AD4 C2 DF 0A    	JNZ ScaleResult	            ; set its sign
2519   0AD7 AF          	XRA A	
2520   0AD8 93          	SUB E	
2521   0AD9 5F          	MOV E,A	
2522   0ADA 0C          	INR C	                    ; make sure C is not FF
2523   0ADB             
2524   0ADB                 ; here to check if we have seen 2 deciment points and set the 
2525   0ADB                 ; decimal point flag
2526   0ADB             L0AE4	
2527   0ADB 0C              INR C	                    ; decimal points - set flage
2528   0ADC CA B3 0A    	JZ FInLoop	                ; continue scanning characters
2529   0ADF             
2530   0ADF                 ; here to multiply or divide by 10 the correct number of times
2531   0ADF                 ; we have already read in all the digits
2532   0ADF             ScaleResult	
2533   0ADF E5              PUSH H	                    ; save pointer for later
2534   0AE0 7B          	MOV A,E	                    ; get exponent
2535   0AE1 90          	SUB B	                    ; exp = exp - # of decimal places
2536   0AE2             DecimalLoop	
2537   0AE2 F4 F3 0A        CP DecimalShiftUp	        ; x10 if exponent is positive
2538   0AE5 F2 EE 0A    	JP DecimalLoopEnd	        ; /10 if exponent is negative
2539   0AE8 F5          	PUSH PSW	                ; save exponent
2540   0AE9 CD 1A 09    	CALL FDivByTen	            ; divide number by 10
2541   0AEC F1          	POP PSW	                    ; get back exponent
2542   0AED 3C          	INR A	                    ; increment it
2543   0AEE             DecimalLoopEnd	
2544   0AEE C2 E2 0A        JNZ DecimalLoop	            ; loop if not done
2545   0AF1 E1          	POP H	                    ; restore text pointer
2546   0AF2 C9          	RET	
2547   0AF3             
2548   0AF3             ; Helper function for shifting the result decimally up one place
2549   0AF3             ; We do this only if A (holding exponent) not zero.  Adjust exponent in A.
2550   0AF3             ;
2551   0AF3             DecimalShiftUp	
2552   0AF3 C8              RZ	                        ; dont do if exponent is zero
2553   0AF4 F5          	PUSH PSW	                ; save exponent
2554   0AF5 CD BA 09    	CALL FMulByTen	            ; muliply result X 10
2555   0AF8 F1          	POP PSW	                    ; restore A (the exponent)
2556   0AF9 3D          	DCR A	                    ; and decrement it
2557   0AFA C9          	RET
2558   0AFB             
2559   0AFB             ; Pack the next digit of the number into the FAC
2560   0AFB             ; We multiply the FAC by ten and add in the digit.
2561   0AFB             ;
2562   0AFB             ProcessDigit	
2563   0AFB D5              PUSH D	                    ; save exponent information
2564   0AFC 57          	MOV D,A	                    ; protect digit from below
2565   0AFD 78          	MOV A,B	                    ; increment decimal place count
2566   0AFE 89          	ADC C	                    ;  if past the decimal point
2567   0AFF 47          	MOV B,A	
2568   0B00 C5          	PUSH B	                    ; save necessary data
2569   0B01 E5          	PUSH H	
2570   0B02 D5          	PUSH D	
2571   0B03 CD BA 09    	CALL FMulByTen	            ; muliply old number by 10
2572   0B06 F1          	POP PSW	                    ; get digit to add
2573   0B07 D6 30       	SUI '0'	                    ; convert ASCII digit to binary
2574   0B09 CD F9 09    	CALL FPush	                ; put FAC on stack
2575   0B0C CD DC 09    	CALL FCharToFloat	        ; convert to floating point    
2576   0B0F C1          	POP B	                    ; recall old FAC into BCDE
2577   0B10 D1          	POP D	
2578   0B11 CD 09 08    	CALL FAdd+2	                ; add in new digit
2579   0B14 E1          	POP H	                    ; recall data
2580   0B15 C1          	POP B	
2581   0B16 D1          	POP D	
2582   0B17 C3 B3 0A    	JMP FInLoop	                ; get next character
2583   0B1A             
2584   0B1A             ; Handle an exponent digit by multiplying current exponent in E by 10,
2585   0B1A             ; then adding the digit value to it
2586   0B1A             ; 
2587   0B1A             DoExponentDigit	
2588   0B1A 7B              MOV A,E	                    ; get exponent
2589   0B1B 07          	RLC	                        ; exp x 2
2590   0B1C 07          	RLC	                        ; exp x 4
2591   0B1D 83          	ADD E	                    ; exp x 5 by adding one
2592   0B1E 07          	RLC	                        ; exp x 10
2593   0B1F 86          	ADD M	                    ; add current (ASCII) digit
2594   0B20 D6 30       	SUI '0'	                    ; convert ASCII to binary
2595   0B22 5F          	MOV E,A	                    ; save new exponent value
2596   0B23 C3 CF 0A    	JMP NextExponentDigit	    ; and continue processing
2597   0B26             
2598   0B26             ; Prints "IN " and then falls into PrintInt
2599   0B26             ; Use by error handling code to print things like "SN ERROR IN 50"
2600   0B26             ;
2601   0B26             PrintIN	
2602   0B26 E5              PUSH H                      ; save line number	
2603   0B27 21 88 01    	LXI H,szIn	                ; point to "IN " string
2604   0B2A CD 9A 05    	CALL PrintString	        ; print it
2605   0B2D E1          	POP H	                    ; restore line number
2606   0B2E             
2607   0B2E             ; Prints an Integer
2608   0B2E             ; Promotes the integer in HL to a floating pointer number in FAC, sets the
2609   0B2E             ; return address to PrintSz-1, and falls into FOout.
2610   0B2E             ; The integer starts off occupying the least significant bits of the mantissa in CDE.
2611   0B2E             ; The exponent is set to 24, yielding an unnormalized but valid FP value
2612   0B2E             ;
2613   0B2E             PrintInt	
2614   0B2E EB              XCHG	                    ; DE=integer
2615   0B2F AF          	XRA A	                    ; A=0 (ends up in C)
2616   0B30 06 98       	MVI B,98h	                ; B (exponent) = 24
2617   0B32 CD E1 09    	CALL FCharToFloat+5	        ; convert to floating point number
2618   0B35 21 99 05    	LXI H,PrintString-1	
2619   0B38 E5          	PUSH H	                    ; push return address on stack
2620   0B39                                             ; and fall into FOut
2621   0B39             
2622   0B39             ; FOUT: Print a floating point number to the terminal
2623   0B39             ;
2624   0B39             FOut	
2625   0B39 21 74 01        LXI H,FBUFFER	            ; HL points to start of character buffer
2626   0B3C E5          	PUSH H	                    ; save it
2627   0B3D EF          	RST 5	                    ; Get sign of number	
2628   0B3E 36 20       	MVI M,' '	                ; print a space if positive
2629   0B40 F2 45 0B    	JP DoZero	
2630   0B43 36 2D       	MVI M,'-'	                ; print a minus sign of negative
2631   0B45             DoZero	
2632   0B45 23              INX H	                    ; increment pointer to next char
2633   0B46 36 30       	MVI M,'0'	                ; put 0 in buffer in case number is zero
2634   0B48 CA EF 0B    	JZ NullTerm-3	            ; do it if number is zero
2635   0B4B E5          	PUSH H	                    ; save buffer pointer
2636   0B4C FC F1 09    	CM FNegate	                ; negate number if negative
2637   0B4F             
2638   0B4F                 ; Here we get the FAC in the range 100,000 - 999,999 and round it to an integer.
2639   0B4F                 ; We keep a count of how many times we multiply or divide by ten so we know what
2640   0B4F                 ; the exponent will be.  The FAC is then converted to an integer in CDE.  We use
2641   0B4F                 ; a table of powers of ten to calculate each digit.
2642   0B4F                 ; This algorithm is used for speed.
2643   0B4F             
2644   0B4F AF          	XRA A	                    ; zero out exponent counter
2645   0B50 F5          	PUSH PSW	                ; put ten's exponent count on stack
2646   0B51 CD F5 0B    	CALL ToUnder1000000	        ; see if number is too big or too small
2647   0B54             ToOver100000	
2648   0B54 01 43 91        LXI B,9143h	                ; BCDE=(float)100,000.
2649   0B57 11 F8 4F    	LXI D,4FF8h	
2650   0B5A CD 43 0A    	CALL FCompare	            ; If FACCUM >= 100,000
2651   0B5D 3C          	INR A                       ; !!! (conv FF to 0, 0 to 1, 1 to 2)    
2652   0B5E C2 72 0B        JNZ  PrepareToPrint         ; !!! Number is in range
2653   0B61                 ;JPO PrepareToPrint	        ; ORIGINAL CODE modified to work in Z80 mode
2654   0B61 F1          	POP PSW	                    ; restore exponent counter
2655   0B62 CD F4 0A    	CALL DecimalShiftUp+1	    ; multipy by ten to get it in range
2656   0B65 F5          	PUSH PSW	                ; save exp counter
2657   0B66 C3 54 0B    	JMP ToOver100000	        ; see if number is now in range
2658   0B69             L0B71	
2659   0B69 CD 1A 09        CALL FDivByTen	            ; number too big so divide by ten
2660   0B6C F1          	POP PSW	
2661   0B6D 3C          	INR A	                    ; add one to exponent
2662   0B6E F5          	PUSH PSW	
2663   0B6F CD F5 0B    	CALL ToUnder1000000	        ; is number less than 1,000,000?
2664   0B72             
2665   0B72                 ; now number is in printing range, ie
2666   0B72                 ; all digits to be printed are the integer part
2667   0B72             
2668   0B72             PrepareToPrint	
2669   0B72 CD F8 07        CALL FAddOneHalf	        ; round number to nearest integer
2670   0B75 3C          	INR A	                    ; make reg A non-zero, since number is positive and non-zero
2671   0B76                                             ; round will exit with the HO in A, so the MSB will always
2672   0B76                                             ; be zero and adding one will never cause reg A to be zero
2673   0B76 CD 6E 0A    	CALL FAsInteger	            ; get integer part in CDE
2674   0B79 CD 09 0A    	CALL FLoadFromBCDE	
2675   0B7C 01 06 02    	LXI B,0206h	                ; set decimal point count for E notation
2676   0B7F F1          	POP PSW	                    ; get exponent counter
2677   0B80 81          	ADD C	                    ; and add in C=digit count=6
2678   0B81 FA 8D 0B    	JM L0B95	                ; print E notation if answer <1
2679   0B84 FE 07       	CPI $07	
2680   0B86 D2 8D 0B    	JNC L0B95	                ; print E notation if > 999,999
2681   0B89 3C          	INR A	
2682   0B8A 47          	MOV B,A	                    ; B = decimal point count
2683   0B8B 3E 01       	MVI A,01h	                ; set fixed point flag, the exponent is zero
2684   0B8D             L0B95	
2685   0B8D 3D              DCR A	
2686   0B8E E1          	POP H	                    ; HL=output buffer
2687   0B8F F5          	PUSH PSW	                ; Preserve exponent adjustment (and preserve zero flag used to indicate scientific notation wanted).
2688   0B90 11 08 0C    	LXI D,DECIMAL_POWERS	    ; store loc of largest power of ten
2689   0B93             
2690   0B93                 ; This is the outer loop of printing, where each ASCII digit is calculated in turn.  
2691   0B93                 ; We start by writing the decimal point, but we only advance HL to keep it if B=0,
2692   0B93                 ; which means that the decimal point has been reached
2693   0B93             
2694   0B93             NextDigit	
2695   0B93 05              DCR B	                    ; see if it is time to print a decimal point
2696   0B94 36 2E       	MVI M,'.'	                ; put a decimal point in the buffer
2697   0B96 CC 1E 0A    	CZ IncHLReturn	            ; increment buffer pointer if it is time
2698   0B99 C5          	PUSH B	                    ; save flags
2699   0B9A E5          	PUSH H	                    ; save character pointer
2700   0B9B D5          	PUSH D	                    ; save power of ten pointer
2701   0B9C CD 14 0A    	CALL FCopyToBCDE	        ; get number in CDE
2702   0B9F E1          	POP H	                    ; get power of ten pointer
2703   0BA0 06 2F       	MVI B,'0'-1	                ; B = next digit to be printer
2704   0BA2             
2705   0BA2                 ; Work out the digit corresponding to the current decimal power. 
2706   0BA2                 ; We do this by subtracting the decimal power (eg 100) from CDE until it overflows, 
2707   0BA2                 ; and incrementing the ASCII digit value in B each time. When it overflows, 
2708   0BA2                 ; we have our digit. And when it overflows, we call FAddMantissas to undo the 
2709   0BA2                 ; last subtraction which was one step too far.
2710   0BA2             
2711   0BA2             DigitLoop	
2712   0BA2 04              INR B	                    ; add one to digit
2713   0BA3 7B          	MOV A,E	                
2714   0BA4 96          	SUB M	                    ; subtract LO    
2715   0BA5 5F          	MOV E,A	
2716   0BA6 23          	INX H	                    ; point to next byte of power of ten
2717   0BA7 7A          	MOV A,D	
2718   0BA8 9E          	SBB M	                    ; subtract MO
2719   0BA9 57          	MOV D,A	
2720   0BAA 23          	INX H	
2721   0BAB 79          	MOV A,C	
2722   0BAC 9E          	SBB M	                    ; subract HO
2723   0BAD 4F          	MOV C,A	
2724   0BAE 2B          	DCX H	                    ; point to beginning of power of ten
2725   0BAF 2B          	DCX H	
2726   0BB0 D2 A2 0B    	JNC DigitLoop	            ; subtract again if result was positive
2727   0BB3 CD A0 08    	CALL FAddMantissas	        ; it wasn't, add power of ten back in
2728   0BB6 23          	INX H	                    ; increment pointer to next power of ten
2729   0BB7 CD 09 0A    	CALL FLoadFromBCDE          ; save CDE in FAC
2730   0BBA             
2731   0BBA                 ; Write out the digit.  Loop back if there are more to do
2732   0BBA             
2733   0BBA EB          	XCHG                        ; DE = power of ten pointer      	
2734   0BBB E1          	POP H	                    ; HL = output buffer pointer
2735   0BBC 70          	MOV M,B	                    ; put ASCII digit in the output buffer
2736   0BBD 23          	INX H	                    ; advance buffer pointer
2737   0BBE C1          	POP B	                    ; get counters off stack
2738   0BBF 0D          	DCR C	                    ; was that the last digit?
2739   0BC0 C2 93 0B        JNZ NextDigit               ; do more if not
2740   0BC3 05          	DCR B	                    ; see if decimal point goes after last digit
2741   0BC4 CA D3 0B    	JZ L0BDB                    ; it does, we have no zeroes to suppress
2742   0BC7             
2743   0BC7                 ; suppress the trailing zeroes
2744   0BC7             
2745   0BC7             L0BCF	
2746   0BC7 2B              DCX H	                    ; go back to last character
2747   0BC8 7E          	MOV A,M	                    ; get it
2748   0BC9 FE 30       	CPI '0'	                    ; ignore trailing zeroes
2749   0BCB CA C7 0B    	JZ L0BCF	                ; until all done
2750   0BCE             
2751   0BCE                 ; suppress decimal point if we have an integer
2752   0BCE             
2753   0BCE FE 2E       	CPI '.'	                    ; ignore dp before trailing zeroes
2754   0BD0 C4 1E 0A    	CNZ IncHLReturn	            ; if no dp, move ptr to next position
2755   0BD3             L0BDB	
2756   0BD3 F1              POP PSW	                    ; get decimal exponent
2757   0BD4 CA F2 0B    	JZ NullTerm	                ; return if number was in fixed point format
2758   0BD7             
2759   0BD7                 ; scientific format: write the exponent part
2760   0BD7             
2761   0BD7 36 45       	MVI M,'E'	                ; put an 'E' in the buffer
2762   0BD9 23          	INX H	                    ; put sign of exponent in buffer
2763   0BDA 36 2B       	MVI M,'+'	                ; Write '+' if exponent if positive
2764   0BDC F2 E3 0B    	JP L0BEB	
2765   0BDF 36 2D       	MVI M,'-'	                ; Write '-' if it's negative, also
2766   0BE1 2F          	CMA	                        ; negate (two's complement) the decimal exponent
2767   0BE2 3C          	INR A	                    ; so printing it will work.
2768   0BE3             
2769   0BE3                 ; Work out the 1st digit of exponent in B.
2770   0BE3                 ; Done by usual method of subtracting 10 until it overflows
2771   0BE3             
2772   0BE3             L0BEB	
2773   0BE3 06 2F           MVI B,'0'-1	                ; initialize ten's digit count
2774   0BE5             ExpDigitLoop	
2775   0BE5 04              INR B	                    ; increment digit
2776   0BE6 D6 0A       	SUI 0Ah	                    ; subtract 10
2777   0BE8 D2 E5 0B    	JNC ExpDigitLoop	        ; do it again if result was positive
2778   0BEB C6 3A       	ADI 3Ah	                    ; add back 10 and convert to ASCII
2779   0BED 23          	INX H	                    
2780   0BEE 70          	MOV M,B	                    ; put ten's digit of exponent in buffer
2781   0BEF 23           	INX H	                    
2782   0BF0 77          	MOV M,A	                    ; put one's digit of exponent in buffer
2783   0BF1 23          	INX H	
2784   0BF2             NullTerm	
2785   0BF2 71              MOV M,C	                    ; put null byte at end of buffer
2786   0BF3 E1          	POP H                       ; exit with HL pointing to string
2787   0BF4 C9          	RET	                        ;
2788   0BF5             
2789   0BF5             ; Divides the FACCUM by ten until its less than 1M.
2790   0BF5             ToUnder1000000
2791   0BF5 01 74 94        LXI B,9474h	
2792   0BF8 11 F7 23    	LXI D,23F7h	                ; BCDE 947423F7 = (float)1,000,000
2793   0BFB CD 43 0A    	CALL FCompare               ; if FACCUM bigger than 1M?	(Z=0, YES=01, NO=FF)
2794   0BFE E1          	POP H	                    ; retrieve return address
2795   0BFF 3D              DCR A                       ; !!!
2796   0C00 CA 69 0B        JZ  L0B71                   ; !!! remove parity check operation  
2797   0C03             	; JPE L0B71	                ; ORIGINAL CODE number too big, divide by 10 
2798   0C03 E9          	PCHL                        ; number OK so return
2799   0C04             
2800   0C04             ONE_HALF	
2801   0C04 00 00 00 80     .DB $00,$00,$00,$80	        ; DD 0.5	 
2802   0C08             DECIMAL_POWERS	
2803   0C08 A0 86 01        .DB $A0,$86,$01	            ; DT 100,000	 
2804   0C0B 10 27 00    	.DB $10,$27,$00	            ; DT 10,000	 
2805   0C0E E8 03 00    	.DB $E8,$03,$00	            ; DT 1000	 
2806   0C11 64 00 00    	.DB $64,$00,$00	            ; DT 100	 
2807   0C14 0A 00 00    	.DB $0A,$00,$00	            ; DT 10	 
2808   0C17 01 00 00    	.DB $01,$00,$00	            ; DT 1	
2809   0C1A             
2810   0C1A             
2811   0C1A             ; THE SQUARE ROOT FUNCTION   X = SQR(A)
2812   0C1A             ;
2813   0C1A             ; First we scale the argument to between 0.5 and 2 by looking at the exponent 
2814   0C1A             ; and using sqr(M x 2^(2*N)) = 2^N * SQR(M)
2815   0C1A             ; Then Newton's method is used to compute SQR(M).  The exponent is save to scale
2816   0C1A             ; the result at the end. 
2817   0C1A             ;
2818   0C1A             ; Newton's method for square root:
2819   0C1A             ;    X(0)   = A 
2820   0C1A             ;    X(n+1) = (X(n) + A/X(n))/2
2821   0C1A             ;
2822   0C1A             Sqr	
2823   0C1A EF              RST 5	                    ; FTestSign - check for error condition	
2824   0C1B FA 9A 04    	JM FunctionCallError        ; cant take sqr of negative number
2825   0C1E C8          	RZ	                        ; sqr(0) = 0
2826   0C1F 21 72 01    	LXI H,FACCUM+3	            ; scale argument between 0.5 andf 2
2827   0C22 7E          	MOV A,M	                    ; get exponent
2828   0C23 1F          	RAR	                        ; get exponent of scale factor
2829   0C24                                             ; use sqr(M x 2^(2*N)) = 2^N * SQR(M)
2830   0C24 F5          	PUSH PSW                    ; save it
2831   0C25 E5          	PUSH H	                    ; save pointer to exponent
2832   0C26 3E 40       	MVI A,40h	                ; set exponent of scaled down number
2833   0C28 17          	RAL	
2834   0C29 77          	MOV M,A	                    ; replace it
2835   0C2A 21 74 01    	LXI H,FBUFFER	            
2836   0C2D CD 20 0A    	CALL FCopyToMem	            ; save A
2837   0C30 3E 04       	MVI A,04h	                ; set iteration count
2838   0C32             SqrLoop	
2839   0C32 F5              PUSH PSW	                ; save count
2840   0C33 CD F9 09    	CALL FPush	                ; save X(n)
2841   0C36 21 74 01    	LXI H,FBUFFER	            
2842   0C39 CD 17 0A    	CALL FLoadBCDEfromMem	    ; get A in the registers
2843   0C3C CD 28 09    	CALL FDiv+2	                ; compute A/X(n)
2844   0C3F C1          	POP B	
2845   0C40 D1          	POP D	
2846   0C41 CD 09 08    	CALL FAdd+2	                ; add in X(n)
2847   0C44 01 00 80    	LXI B,8000h	                ; set up BCDE with 0.5
2848   0C47 51          	MOV D,C	
2849   0C48 59          	MOV E,C	
2850   0C49 CD DC 08    	CALL FMul+2	                ; multiply by 0.5, same as divide by 2
2851   0C4C F1          	POP PSW	                    ; get iteration count
2852   0C4D 3D          	DCR A	                    ; are we done?
2853   0C4E C2 32 0C    	JNZ SqrLoop	                ; no, do more iterations
2854   0C51 E1          	POP H	                    ; yes, set exponent of answer
2855   0C52 F1          	POP PSW	                    ; get scale factor
2856   0C53 C6 C0       	ADI $C0	                    ; convert it to an exponent
2857   0C55 86          	ADD M	                    ; add exponent in
2858   0C56 77          	MOV M,A	                    ; replace exponent
2859   0C57 C9          	RET	
2860   0C58             
2861   0C58             
2862   0C58             ; PSEUDO-RANDOM NUMBER GENERATOR
2863   0C58             ;
2864   0C58             ; If argument is zero, it returns the last number generated
2865   0C58             ; If argument is negative, a new sequence of random number is started using the arg.
2866   0C58             ; 
2867   0C58             ; To form the next random number in the sequence, we multiply the previous random
2868   0C58             ; number by a constant, and add in another constant.  Then the high- and low- order
2869   0C58             ; bytes are swapped, the exponent is put where it will be shifted in by normal, and the
2870   0C58             ; exponent in the FAC set so that the result will be less than one.  This is then normalized
2871   0C58             ; and saved for the next time.  The HO and LO bytes are swapped so we have a random chance
2872   0C58             ; of setting a number less than or greater than 0.5
2873   0C58             ;
2874   0C58             Rnd	
2875   0C58 EF              RST 5	                    ; FTestSign - get sign of the argument	
2876   0C59 FA 75 0C    	JM L0C7C	                ; start new sequence of negative
2877   0C5C 21 8A 0C    	LXI H,RND_SEED	            ; get last number generated
2878   0C5F CD 06 0A    	CALL FLoadFromMem	
2879   0C62 C8          	RZ	                        ; return last number if argument is 0
2880   0C63 01 35 98    	LXI B,9835h	                ; load BCDE with constant A
2881   0C66 11 7A 44    	LXI D,447Ah	
2882   0C69 CD DC 08    	CALL FMul+2	                ; multiply by constant A (x 11,879,546)
2883   0C6C 01 28 68    	LXI B,$6828	                ; load BCDE with constant B            
2884   0C6F 11 46 B1    	LXI D,$B146	
2885   0C72 CD 09 08    	CALL FAdd+2	                ; add in constant B (+ 0.0000003927678)
2886   0C75             L0C7C	
2887   0C75 CD 14 0A        CALL FCopyToBCDE	        ; switch HO and LO bytes as follows...
2888   0C78 7B          	MOV A,E	                    ; get LO
2889   0C79 59          	MOV E,C	                    ; put HO in LO byte
2890   0C7A 4F          	MOV C,A	                    ; put LO in HO byte
2891   0C7B 36 80       	MVI M,80h	                ; make result positive
2892   0C7D 2B          	DCX H	                    ; get pointer to exponent
2893   0C7E 46          	MOV B,M	                    ; put exponent in overflow position
2894   0C7F 36 80       	MVI M,80h	                ; set exp so result will be btwn 0 and 1
2895   0C81 CD 55 08    	CALL FNormalize+3	        ; normalize the result
2896   0C84 21 8A 0C    	LXI H,RND_SEED	    
2897   0C87 C3 20 0A    	JMP FCopyToMem              ; save result as seed for next time
2898   0C8A             
2899   0C8A 80          RND_SEED	.DB 52C74F80h	
2900   0C8B             
2901   0C8B             
2902   0C8B             ; THE SIN FUNCTION:   A = SIN(X)
2903   0C8B             ;
2904   0C8B             ; Idea: use identities to get FAC in Quadrants I or IV.
2905   0C8B             ; The FAC is divided by 2*pi and the integer part is ignored because
2906   0C8B             ; SIN(X + 2*pi) = SIN(X).  Then the argument can be compared with pi/2 by 
2907   0C8B             ; comparing the result of the division with pi/2/(2*pi) = 1/4.
2908   0C8B             ; An approximation polynomial is then used to compute SIN(x).
2909   0C8B             ;
2910   0C8B             Sin	
2911   0C8B CD F9 09        CALL FPush	                ; push argument
2912   0C8E 01 49 83    	LXI B,8349h	                ; BCDE = 2*pi
2913   0C91 11 DB 0F    	LXI D,0FDBh	
2914   0C94 CD 09 0A    	CALL FLoadFromBCDE	       
2915   0C97 C1          	POP B	
2916   0C98 D1          	POP D	
2917   0C99 CD 28 09    	CALL FDiv+2	                ; result = x/2pi, now between 0 and 1
2918   0C9C CD F9 09    	CALL FPush	                ; disregard integer part since SIN is
2919   0C9F CD 99 0A    	CALL Int	                ;   perodic with period 2*pi
2920   0CA2 C1          	POP B	
2921   0CA3 D1          	POP D	
2922   0CA4 CD 03 08    	CALL FSub+2	;=u-INT(u)
2923   0CA7 01 00 7F    	LXI B,7F00h	                ; BCDE = 0.25
2924   0CAA 51          	MOV D,C	
2925   0CAB 59          	MOV E,C	
2926   0CAC CD 03 08    	CALL FSub+2	                ; subtract 0.25           
2927   0CAF EF          	RST 5	                    ; FTestSign	to see what quadrant we are in
2928   0CB0 37          	STC	                        ; set Quadrant I flag
2929   0CB1 F2 B9 0C    	JP NegateIfPositive	        ; Quadrant I, get back original X
2930   0CB4 CD F8 07    	CALL FAddOneHalf	        ; Add 0.5
2931   0CB7 EF          	RST 5	
2932   0CB8 B7          	ORA A	                    ; clear carry
2933   0CB9             NegateIfPositive	
2934   0CB9 F5              PUSH PSW	                ; save quadrant flag
2935   0CBA F4 F1 09    	CP FNegate	                ; negate if in Quadrants I, II, or III
2936   0CBD 01 00 7F    	LXI B,7F00h	                ; BCDE = 0.25
2937   0CC0 51          	MOV D,C	
2938   0CC1 59          	MOV E,C	
2939   0CC2 CD 09 08    	CALL FAdd+2	                ; In Quadrants II, III so add 0.25
2940   0CC5 F1          	POP PSW	                    ; get Quadrant flag
2941   0CC6 D4 F1 09    	CNC FNegate	                ; negate if in Quadrants II, III, or IV
2942   0CC9 CD F9 09    	CALL FPush	                ; save X
2943   0CCC CD 14 0A    	CALL FCopyToBCDE	
2944   0CCF CD DC 08    	CALL FMul+2	                ; square X (X = X*X)
2945   0CD2 CD F9 09    	CALL FPush	                ; save X^2
2946   0CD5 21 F9 0C    	LXI H,TAYLOR_SERIES	
2947   0CD8 CD 06 0A    	CALL FLoadFromMem	        ; move 1st constant into FAC
2948   0CDB C1          	POP B	                    ; get X^2
2949   0CDC D1          	POP D	
2950   0CDD 3E 04       	MVI A,04h	                ; get degree
2951   0CDF             TaylorLoop	
2952   0CDF F5              PUSH PSW	                ; save #terms remaining
2953   0CE0 D5          	PUSH D	                    ; save x^2
2954   0CE1 C5          	PUSH B	
2955   0CE2 E5          	PUSH H	                    ; save constant pointer
2956   0CE3 CD DC 08    	CALL FMul+2	                ; multiply by x^2
2957   0CE6 E1          	POP H	                    ; get pointer to constants
2958   0CE7 CD 17 0A    	CALL FLoadBCDEfromMem	    ; get constant into registers
2959   0CEA E5          	PUSH H	                    ; save pointer
2960   0CEB CD 09 08    	CALL FAdd+2	                ; add in constant
2961   0CEE E1          	POP H	                    ; move pointer to next constant
2962   0CEF C1          	POP B	                    ; get x^2
2963   0CF0 D1          	POP D	
2964   0CF1 F1          	POP PSW	                    ; pop #terms remaining into A.
2965   0CF2 3D          	DCR A	                    ; see if we are done
2966   0CF3 C2 DF 0C    	JNZ TaylorLoop	            ; no, do next term
2967   0CF6 C3 DA 08    	JMP FMul	                ; multiply by X and we are done
2968   0CF9             
2969   0CF9             TAYLOR_SERIES	
2970   0CF9 BA D7 1E 86     .DB $BA,$D7,$1E,$86	        ; 39.710670	 
2971   0CFD 64 26 99 87 	.DB $64,$26,$99,$87	        ; -76.574982	 
2972   0D01 58 34 23 87 	.DB $58,$34,$23,$87	        ; 81.602234	 
2973   0D05 E0 5D A5 86 	.DB $E0,$5D,$A5,$86	        ; -41.341675	 
2974   0D09 DA 0F 49 83 	.DB $DA,$0F,$49,$83	        ; 6.283185	 
2975   0D0D             L0D17	
2976   0D0D 00 00 00 00     .DB $00,$00,$00,$00,$00
2976   0D11 00 
2977   0D12 00 00 00 00     .DB $00,$00,$00,$00,$00	    
2977   0D16 00 
2978   0D17             
2979   0D17             
2980   0D17             ; THE INITIALIZATION ROUTINE
2981   0D17             ;
2982   0D17             ; The first section of this code sets up I/O configuration for the ALTAIR computer,
2983   0D17             ; and therefore is not relevant to the IMSAI 8080.  This I/O code has been commented out.
2984   0D17             ;
2985   0D17             ; Next, the amount of memory, terminal width, and optional math functions to be retained
2986   0D17             ; are ascertained from the user.  A zero is put down at the first location not used by
2987   0D17             ; the math package and PROGRAM_BASE (TXTAB in original code) is set up to point at the next
2988   0D17             ; location.  This determines where user program storage will start.  Once INIT finishes, the
2989   0D17             ; memory it uses is reclamed for program storage.  The last thing INIT does is change address
2990   0D17             ; zero to be a jump to MAIN (Ready in original code) instead of INIT.  Once this is done
2991   0D17             ; there is no way to restart INIT.
2992   0D17             
2993   0D17             Init	
2994   0D17             
2995   0D17             ; IMSAI 8080 I/O port initialzation
2996   0D17             ;
2997   0D17 3A CA 00        LDA  0CAh                   ; 7 BITS, NO PARITY, 2 STOP
2998   0D1A D3 03           OUT  CONS                   ; UART A - SET MODE 
2999   0D1C 3A 27 00        LDA  27h                    ; ENABLE TX & RX
3000   0D1F D3 03           OUT  CONS                   ; UART A - SET CONTROL
3001   0D21             
3002   0D21             ;  ALTAIR teletype and terminal port initialization follows
3003   0D21             ;  None of this is needed for IMSAI 8080 port
3004   0D21             ;
3005   0D21             ;   LXI H,$0F1A	
3006   0D21             ;	SPHL	
3007   0D21             ;	SHLD STACK_TOP	
3008   0D21             ;	IN 01	
3009   0D21             ;	MVI C,$FF	;
3010   0D21             ;	LXI D,ConfigIOcode	
3011   0D21             ;	PUSH D	
3012   0D21             ;	LDA 0FFFh	   
3013   0D21             ;	MOV B,A	
3014   0D21             ;	IN $FF
3015   0D21             ;	RAR	
3016   0D21             ;	JC L0D42-1	
3017   0D21             ;	ANI 0Ch	
3018   0D21             ;	JZ L0D42	
3019   0D21             ;	MVI B,10h	
3020   0D21             ;	MOV A,B	
3021   0D21             ;L0D42	
3022   0D21             ;    STA L0D8D-1	
3023   0D21             ;	IN $FF	
3024   0D21             ;	RAL	
3025   0D21             ;	RAL	
3026   0D21             ;	MVI B,20h	
3027   0D21             ;L0D4B	
3028   0D21             ;   LXI D,$CA02	
3029   0D21             ;	RC	
3030   0D21             ;	RAL	
3031   0D21             ;	MOV B,E	
3032   0D21             ;	DCR E	
3033   0D21             ;	RC	
3034   0D21             ;	RAL	
3035   0D21             ;	JC L0D6F	
3036   0D21             ;	MOV B,E	
3037   0D21             ;	LXI D,$C280	
3038   0D21             ;	RAL	
3039   0D21             ;	RNC	
3040   0D21             ;	RAL	
3041   0D21             ;	MVI A,03h	               ; lets send byte 01
3042   0D21             ;	CALL L0D8B	               ; OUT to port 0
3043   0D21             ;	DCR A	
3044   0D21             ;	ADC A	
3045   0D21             ;	ADD A	
3046   0D21             ;	ADD A	
3047   0D21             ;	INR A	
3048   0D21             ;	CALL L0D8B	               ; and do it again.
3049   0D21             ;	STC	
3050   0D21             ;	JMP L0D4B	
3051   0D21             ;L0D6F	
3052   0D21             ;   XRA A	
3053   0D21             ;	CALL L0D8B	
3054   0D21             ;	CALL L0D87	
3055   0D21             ;	CALL L0D87	
3056   0D21             ;	MOV C,E	
3057   0D21             ;	CMA	
3058   0D21             ;	CALL L0D87	
3059   0D21             ;	MVI A,04h	
3060   0D21             ;	DCR M	
3061   0D21             ;	CALL L0D8B	
3062   0D21             ;	DCR M	
3063   0D21             ;	DCR M	
3064   0D21             ;	DCR M	
3065   0D21             ;L0D87	
3066   0D21             ;    LXI H,L0D8D-1	
3067   0D21             ;	INR M	
3068   0D21             ;L0D8B	OUT 00	
3069   0D21             ;L0D8D	RET	
3070   0D21             
3071   0D21             ; Here, the I/O status bits are configured.  It is modifying the I/O routines, shoving values in
3072   0D21             ; for the ANI bitmasks at address <function>+3
3073   0D21             ; there is no need for this with the IMSAI.
3074   0D21             
3075   0D21             ;ConfigIOcode	
3076   0D21             ;   MOV H,D	
3077   0D21             ;	MOV L,B	
3078   0D21             ;	SHLD InputChar+3	
3079   0D21             ;	MOV A,H	
3080   0D21             ;	ANI $C8	
3081   0D21             ;	MOV H,A	
3082   0D21             ;	SHLD TestBreakKey+3	
3083   0D21             ;	XCHG	
3084   0D21             ;	SHLD WaitTermReady+3	
3085   0D21             ;	LDA L0D8D-1	
3086   0D21             ;	STA InputChar+1	
3087   0D21             ;	STA TestBreakKey+1	
3088   0D21             ;	INR A	
3089   0D21             ;	STA InputChar+8	
3090   0D21             ;	ADD C	
3091   0D21             ;	STA WaitTermReady+1	
3092   0D21             ;	INR A	
3093   0D21             ;	STA InputChar-2	
3094   0D21             
3095   0D21             ;
3096   0D21             ;  Now ask the user how much memory is present, in bytes
3097   0D21             ;
3098   0D21 21 FF FF    	LXI H,$FFFF	
3099   0D24 22 61 01    	SHLD CURRENT_LINE	        ; set immediate mode
3100   0D27 CD 8B 05    	CALL NewLine	
3101   0D2A 21 5E 0E    	LXI H,szMemorySize	        
3102   0D2D CD 9A 05    	CALL PrintString	        ; print "Memory Size?"       
3103   0D30 CD C2 02    	CALL InputLineWith          ; get user input
3104   0D33 D7          	RST 2	                    ; look at first char	
3105   0D34 B7          	ORA A	                    ; user type anything?
3106   0D35 C2 4C 0D    	JNZ L0DDE	                ; if so, handle it.
3107   0D38             
3108   0D38                 ; No answer given to the request for memory size, therefore we find the top of memory ourselves. 
3109   0D38                 ; This is done by writing alternating 0x37 and 0x36's to progressively higher addresses and 
3110   0D38                 ; reading the values back from memory. When the value read is not the value written, 
3111   0D38                 ; we know we have written past the top of memory.
3112   0D38             
3113   0D38 21 71 0E    	LXI H,UnusedMemory	        ; start where BASIC leaves off	
3114   0D3B             FindMemTopLoop	
3115   0D3B 23              INX H	                    ; go to next memory location
3116   0D3C 3E 37       	MVI A,37h	
3117   0D3E 77          	MOV M,A	                    ; write a 37h to memory
3118   0D3F BE          	CMP M	                    ; did it stick?
3119   0D40 C2 58 0D    	JNZ DoneMemSize	            ; nope, we've reached the top
3120   0D43 3D          	DCR A	                    ; now try with 36h
3121   0D44 77          	MOV M,A	                    ; write it to memory
3122   0D45 BE          	CMP M	                    ; did it stick?
3123   0D46 CA 3B 0D    	JZ FindMemTopLoop	        ; yes, so keep going
3124   0D49 C3 58 0D    	JMP DoneMemSize	            ; nope, we are done.
3125   0D4C             
3126   0D4C                 ; Memory size has been given in bytes. 
3127   0D4C                 ; Here we convert the string input to an integer value and 
3128   0D4C                 ; error if it's 0 or a non-numeric input.
3129   0D4C             
3130   0D4C             L0DDE	
3131   0D4C 21 13 01        LXI H,LINE_BUFFER	
3132   0D4F CD 9F 04    	CALL LineNumberFromStr	    ; get number up to 65529 into DE
3133   0D52 B7          	ORA A	                    ; A=0 for valid number                    
3134   0D53 C2 D0 01    	JNZ SyntaxError	            ; user didn't enter valid number
3135   0D56 EB          	XCHG	                    ; put answer in HL
3136   0D57 2B          	DCX H	                    ; HL - 1
3137   0D58             
3138   0D58             DoneMemSize	
3139   0D58 2B              DCX H	                    
3140   0D59 E5          	PUSH H	                    ; push result (last word of RAM) on stack
3141   0D5A             
3142   0D5A             ;
3143   0D5A             ; Ask the user how many columns wide their terminal is. 
3144   0D5A             ; This defaults to 72 if empty input is given.
3145   0D5A             ;
3146   0D5A             GetTerminalWidth	
3147   0D5A 21 22 0E        LXI H,szTerminalWidth	
3148   0D5D CD 9A 05    	CALL PrintString	        ; print "TERMINAL WIDTH?"
3149   0D60 CD C2 02    	CALL InputLineWith	        ; get user input
3150   0D63 D7          	RST 2	                    ; NextChar	
3151   0D64 B7          	ORA A	                    ; if no input,
3152   0D65 CA 89 0D    	JZ DoOptionalFns            ; use default 72 & jump next section
3153   0D68 21 13 01    	LXI H,LINE_BUFFER	
3154   0D6B CD 9F 04    	CALL LineNumberFromStr	    ; convert user input into integer in DE
3155   0D6E             
3156   0D6E                 ; If user-supplied terminal width is >=256 or <16 then 
3157   0D6E                 ; that's not in range so jump back to ask again
3158   0D6E             
3159   0D6E 7A          	MOV A,D	
3160   0D6F B7          	ORA A	                    ; make sure D=0 (therefore DE<256)
3161   0D70 C2 5A 0D    	JNZ GetTerminalWidth	    ; answer too high, try again
3162   0D73 7B          	MOV A,E	                    ; look at LSB of answer (in A)
3163   0D74 FE 10       	CPI $10	                    ; less than 16?
3164   0D76 DA 5A 0D    	JC GetTerminalWidth	        ; answer too low, try again
3165   0D79 32 6F 03    	STA OutChar_tail+1	        ; store user-supplied width
3166   0D7C             
3167   0D7C                 ; Calculate the column of the last tab-break and write this number 
3168   0D7C                 ; to the right place in the ToNextTabBreak function. The tab-break size is 14, so 
3169   0D7C                 ; the last tab-break is calculated as (width - ((width % 14)+14). 
3170   0D7C                 ; So for 72, the last tab brk is at column 56.
3171   0D7C                 
3172   0D7C             CalcTabBrkSize	
3173   0D7C D6 0E           SUI 0Eh	
3174   0D7E D2 7C 0D    	JNC CalcTabBrkSize	
3175   0D81 C6 1C       	ADI 1Ch	
3176   0D83 2F          	CMA	
3177   0D84 3C          	INR A	
3178   0D85 83          	ADD E	
3179   0D86 32 AE 05    	STA ToNextTabBreak+4
3180   0D89             
3181   0D89                 ; Ask the user which optional inline functions they want. 
3182   0D89                 ; If they answer Y(es) to any, they do not get an option to turn off support for later ones, 
3183   0D89                 ; ie if you say yes to SIN you have implicitly accepted RND and SQR too. 
3184   0D89                 ; If functions are turned off, the memory they occupy is reclaimed for program space 
3185   0D89                 ; (look for where PROGRAM_BASE gets set and how it is calculated).
3186   0D89                 ;
3187   0D89                 ; This code will loop up to three times: first for SIN, then RND, then SQR
3188   0D89                 ; until the user responds with a 'N'.
3189   0D89                 ; Each time, RST 6 is called three times, to advance through the three entries
3190   0D89                 ; in OPT_FN descriptor table devoted to the optional function: string, table entry, and function
3191   0D89                 ; address
3192   0D89             
3193   0D89             DoOptionalFns	
3194   0D89 21 F3 0D        LXI H,OPT_FN_DESCS	        ; point to first optional fn (SIN)
3195   0D8C             OptionalFnsLoop	
3196   0D8C F7              RST 6	                    ; push next table address on stack
3197   0D8D 11 07 0E    	LXI D,szWantSin	            ; DE = address just beyond table
3198   0D90 E7          	RST 4	                    ; compare HL & DE
3199   0D91 CA A0 0D    	JZ L0E32                    ; if same, we are done
3200   0D94             
3201   0D94                 ; Get the address of the string prompt in HL, print the prompt, get input
3202   0D94                 ; put first char of that input in A
3203   0D94             
3204   0D94 F7          	RST 6	                    ; push string prompt address on stack
3205   0D95 E3          	XTHL	                    ; now get it into HL
3206   0D96 CD 9A 05    	CALL PrintString	        ; print the prompt "WANT SIN?", etc        
3207   0D99 CD C2 02    	CALL InputLineWith	        ; get user response
3208   0D9C D7          	RST 2	                    ; look at first char only	
3209   0D9D E1          	POP H	                    ; restore HL
3210   0D9E FE 59       	CPI 'Y'	                    ; user entered Yes?
3211   0DA0             L0E32	
3212   0DA0 D1              POP D	                    ; if so, put program stor. start into DE
3213   0DA1 CA B5 0D    	JZ InitProgramBase	        ; and jump below
3214   0DA4 FE 4E       	CPI 'N'	                    ; if not Y or N, 
3215   0DA6 C2 89 0D    	JNZ DoOptionalFns	        ; then try again
3216   0DA9             
3217   0DA9                 ; user selected N=no, so get HL=addr of fun in the inline_fn table
3218   0DA9             
3219   0DA9 F7          	RST 6	                    ; pushes next entry (addr of fn in inline table) on stack                 
3220   0DAA E3          	XTHL	                    ; now get this back into HL, and put incremented pointer on stack
3221   0DAB             
3222   0DAB                 ; update the inline function table, inserting "FunctionCallError"
3223   0DAB                 ; in place of the function's real address 
3224   0DAB             
3225   0DAB 11 9A 04    	LXI D,FunctionCallError	
3226   0DAE 73          	MOV M,E	
3227   0DAF 23          	INX H	
3228   0DB0 72          	MOV M,D	
3229   0DB1 E1          	POP H	                    ; restore HL
3230   0DB2 C3 8C 0D    	JMP OptionalFnsLoop	        ; go back to handle next optional function
3231   0DB5             
3232   0DB5             ; Get here with the Program_Base in Reg DE.  Store the value.
3233   0DB5             ;
3234   0DB5             InitProgramBase	
3235   0DB5 EB              XCHG	                    ; put program_base into HL
3236   0DB6 36 00       	MVI M,00h	                ; write a 0 first
3237   0DB8 23          	INX H	
3238   0DB9 22 65 01    	SHLD PROGRAM_BASE	        ; store program_base address in variable
3239   0DBC             
3240   0DBC                 ; The location of ram_end was pushed on stack about a hundred lines of code back
3241   0DBC                 ; now retrieve into HL, and put program_base on stack.
3242   0DBC             
3243   0DBC E3          	XTHL	                    ; ram end addr in HL, PROGRAM_BASE on stack
3244   0DBD 11 1A 0F    	LXI D,0F1Ah	                ; if ram end < 0F1A then Out of Memory error
3245   0DC0 E7          	RST 4	                    ; Compare HL & DE
3246   0DC1 DA CD 01    	JC OutOfMemory	
3247   0DC4 D1          	POP D	                    ; Get PROGRAM_BASE in DE
3248   0DC5 F9          	SPHL	                    ; Set stack pointer to top of memory
3249   0DC6 22 63 01    	SHLD STACK_TOP	            ; Set STACK_TOP to top of memory
3250   0DC9             
3251   0DC9 EB          	XCHG	                    ; get PROGRAM_BASE in HL, stack top in DE
3252   0DCA CD C3 01    	CALL CheckEnoughMem	        ; base must be 32 bytes away from stack pointer
3253   0DCD             
3254   0DCD                 ; calculate bytes available as Stack_top - Program_Base - 16:
3255   0DCD             
3256   0DCD 7B          	MOV A,E	
3257   0DCE 95          	SUB L	
3258   0DCF 6F          	MOV L,A	
3259   0DD0 7A          	MOV A,D	
3260   0DD1 9C          	SBB H	
3261   0DD2 67          	MOV H,A	
3262   0DD3 01 F0 FF    	LXI B,$FFF0	                ; - 16
3263   0DD6 09          	DAD B	
3264   0DD7 CD 8B 05    	CALL NewLine
3265   0DDA CD 2E 0B    	CALL PrintInt	            ; print free bytes
3266   0DDD 21 31 0E    	LXI H,szVersionInfo	        
3267   0DE0 CD 9A 05    	CALL PrintString	        ; print version info
3268   0DE3             
3269   0DE3                 ; change code at start of MAIN to call PrintString instead of restarting
3270   0DE3             
3271   0DE3 21 9A 05    	LXI H,PrintString	        
3272   0DE6 22 FD 01    	SHLD Main+4	
3273   0DE9             
3274   0DE9 CD 96 02    	CALL New+1	                ; initialize vars for new program
3275   0DEC             
3276   0DEC                 ; Change the JMP address at start of BASIC to jump to Main instead of INIT
3277   0DEC             
3278   0DEC 21 F9 01    	LXI H,Main	                ; get pointer to MAIN
3279   0DEF 22 02 00    	SHLD Start+2	            ; and save it as new BASIC start point
3280   0DF2 E9          	PCHL                        ; Now jump to MAIN	
3281   0DF3             
3282   0DF3             ; the following table is used ONLY for DoOptionalFns routine
3283   0DF3             ;
3284   0DF3             OPT_FN_DESCS	
3285   0DF3 0D 0D           .DW L0D17	
3286   0DF5 07 0E        	.DW szWantSin	            ; SIN option string
3287   0DF7 49 00        	.DW KW_INLINE_FNS+12	    ; SIN table entry @ 0049
3288   0DF9 8B 0C        	.DW Sin	                    ; SIN function    @ 0C8B
3289   0DFB 10 0E        	.DW szWantRnd	            ; RND option string
3290   0DFD 47 00        	.DW KW_INLINE_FNS+10	    ; RND table entry @ 0047
3291   0DFF 58 0C        	.DW Rnd	                    ; RND function    @ 0C58
3292   0E01 19 0E        	.DW szWantSqr	            ; SQR option string 
3293   0E03 45 00        	.DW KW_INLINE_FNS+8	        ; SQR table entry @ 0045
3294   0E05 1A 0C        	.DW Sqr	                    ; SQR function    @ 0C1A
3295   0E07             
3296   0E07             szWantSin	
3297   0E07 57 41 4E 54     .DB "WANT SIN",0          	
3297   0E0B 20 53 49 4E 
3297   0E0F 00 
3298   0E10             szWantRnd	
3299   0E10 57 41 4E 54     .DB "WANT RND",0        	
3299   0E14 20 52 4E 44 
3299   0E18 00 
3300   0E19             szWantSqr	
3301   0E19 57 41 4E 54     .DB "WANT SQR",0        	
3301   0E1D 20 53 51 52 
3301   0E21 00 
3302   0E22             szTerminalWidth	
3303   0E22 54 45 52 4D     .DB "TERMINAL WIDTH",0
3303   0E26 49 4E 41 4C 
3303   0E2A 20 57 49 44 
3303   0E2E 54 48 00 
3304   0E31             szVersionInfo	
3305   0E31 20 42 59 54     .DB " BYTES FREE",13,13
3305   0E35 45 53 20 46 
3305   0E39 52 45 45 0D 
3305   0E3D 0D 
3306   0E3E 42 41 53 49 	.DB "BASIC VERSION 3.2",13
3306   0E42 43 20 56 45 
3306   0E46 52 53 49 4F 
3306   0E4A 4E 20 33 2E 
3306   0E4E 32 0D 
3307   0E50 5B 34 4B 20 	.DB "[4K VERSION]",13,0
3307   0E54 56 45 52 53 
3307   0E58 49 4F 4E 5D 
3307   0E5C 0D 00 
3308   0E5E             szMemorySize	
3309   0E5E 4D 45 4D 4F     .DB "MEMORY SIZE",0
3309   0E62 52 59 20 53 
3309   0E66 49 5A 45 00 
3310   0E6A             szIMSAI
3311   0E6A 76 30 33 20     .DB "v03 BH",0
3311   0E6E 42 48 00 
3312   0E71             
3313   0E71             UnusedMemory	                ; mark end of ALTAIR BASIC
3314   0E71 00              .DB 00
3315   0E72             
3316   0E72             .ENDtasm: Number of errors = 0
