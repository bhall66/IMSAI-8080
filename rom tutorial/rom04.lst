0001   0000             ;
0002   0000             ;   Title:   rom04asm
0003   0000             ;  Author:   Bruce E. Hall, w8bh
0004   0000             ;    Date:   05 Jul 2025
0005   0000             ;      HW:   IMSAI8080 emulator by TheHighNibble
0006   0000             ;      SW:   TASM compiler using Z80 mnemonics (-80 option)
0007   0000             ;            
0008   0000             ;   Descr:   Test for disk presence, using low-level calls.
0009   0000             ;            if disk found, load cp/m boostrap into 0000-007F,
0010   0000             ;            and jump there.
0011   0000             ;            ...and... make it all CP/M compatible.
0012   0000             ;            
0013   0000             
0014   0000             DDA         .EQU    0080h       ; disk descriptor address
0015   0000             DMA         .EQU    0000h       ; disk DMA address
0016   0000             FDC         .EQU    0FDh
0017   0000             LED         .EQU    0FFh
0018   0000             
0019   0100             .ORG    0100h
0020   0100             
0021   0100 31 00 10                LD   SP,1000h       ; establish local stack
0022   0103 CD 80 01                CALL initSIO        ; initialize serial ports 2 & 22h
0023   0106 21 96 01                LD   HL,st0
0024   0109 CD 8D 01                CALL putStr         ; print title message
0025   010C CD 4A 01                CALL initDD         ; establish disk descriptor
0026   010F             
0027   010F 21 AB 01    j02:        LD   HL,st1
0028   0112 CD 8D 01                CALL putStr         ; print "Press any key: "
0029   0115 CD 40 01                CALL waitCh         ; wait for user input 
0030   0118 FE 03                   CP   3              ; was it Ctrl-C?
0031   011A CA 37 01                JP   Z,cboot        ; yes, so return via cold boot 
0032   011D CD 6E 01                CALL fdExec         ; try a read disk command
0033   0120 D6 01                   SUB  1              ; disk read success=1?
0034   0122 C2 2E 01                JP   NZ,j03         ; nope, so flag & try again
0035   0125 21 C6 01                LD   HL,st3
0036   0128 CD 8D 01                CALL putStr         ; print "booting from Drive A"
0037   012B C3 00 00                JP   0000h          ; jump to bootstrap code!
0038   012E 21 BB 01    j03:        LD   HL,st2        
0039   0131 CD 8D 01                CALL putStr         ; print "disk not found"
0040   0134 C3 0F 01                JP   j02            ; loop
0041   0137             
0042   0137 2A 01 00    cboot:      LD   HL,(0001)      ; get warm boot address
0043   013A 01 03 00                LD   BC,3           ; cold boot = wb - 3
0044   013D ED 42                   SBC  HL,BC          
0045   013F E9                      JP   (HL)           ; jump to cold boot
0046   0140             
0047   0140             
0048   0140 DB 03       waitCh:     IN   A,(3)          ; check status
0049   0142 E6 02                   AND  2              ; look @ ready bit only
0050   0144 CA 40 01                JP   Z,waitCh       ; wait for a character
0051   0147 DB 02                   IN   A,(2)          ; read the character
0052   0149 C9                      RET 
0053   014A             
0054   014A             
0055   014A 21 E2 01    initDD:     LD   HL,cmdStr      ; copy "Read Disk0/Tr0/Sec1" to descriptor
0056   014D 11 80 00                LD   DE,DDA
0057   0150 01 07 00                LD   BC,7
0058   0153 ED B0                   LDIR
0059   0155 21 00 00                LD   HL,DMA         ; get DMA address
0060   0158 7D                      LD   A,L 
0061   0159 32 85 00                LD   (DDA+5),A      ; add in LSB of DMA to descriptor
0062   015C 7C                      LD   A,H 
0063   015D 32 86 00                LD   (DDA+6),A      ; add in MSB of DMA to descriptor
0064   0160             
0065   0160 3E 10                   LD   A,10h          ; command 10h = point to disk descriptor
0066   0162 D3 FD                   OUT  (FDC),A 
0067   0164 21 80 00                LD   HL,DDA         ; get descriptor address
0068   0167 7D                      LD   A,L            ; address LSB
0069   0168 D3 FD                   OUT  (FDC),A 
0070   016A 7C                      LD   A,H            ; address MSB 
0071   016B D3 FD                   OUT  (FDC),A 
0072   016D C9                      RET 
0073   016E             
0074   016E AF          fdExec:     XOR  A              ; command 0 = use descriptor 
0075   016F 32 81 00                LD   (DDA+1),A      ; erase any previous result
0076   0172 D3 FD                   OUT  (FDC),A        ; execute the command string
0077   0174 3A 81 00    j01:        LD   A,(DDA+1)      ; look at result code
0078   0177 B7                      OR   A              ; still zero?
0079   0178 CA 74 01                JP   Z,j01          ; wait until response received
0080   017B 2F                      CPL                 
0081   017C D3 FF                   OUT  (LED),A        ; show result on FP LEDs.
0082   017E 2F                      CPL                 ; restore value
0083   017F C9                      RET 
0084   0180             
0085   0180             
0086   0180 3E CA       initSIO:    LD   A,0CAh         ; 7 BITS, NO PARITY, 2 STOP
0087   0182 D3 03                   OUT  (3),A          ; UART A - SET MODE 
0088   0184 D3 23                   OUT  (23h),A        ; UART B - SET MODE
0089   0186 3E 27                   LD   A,027H         ; ENABLE TX & RX
0090   0188 D3 03                   OUT  (3),A          ; UART A - SET CONTROL
0091   018A D3 23                   OUT  (23h),A        ; UART B - SET CONTROL
0092   018C C9                      RET
0093   018D             
0094   018D             ; putStr write a null-terminated ASCII string, pointed to by HL, 
0095   018D             ; to the console
0096   018D             ;
0097   018D 7E          putStr:     LD      A,(HL)      ; load next char in string      
0098   018E B7                      OR      A           ; is it end-of-string NULL?
0099   018F C8                      RET     Z           ; if so, we are done
0100   0190 D3 02                   OUT     (2),A       ; send char to output devices
0101   0192 23                      INC     HL          ; point to next character in string
0102   0193 C3 8D 01                JP      putStr      ; and loop until done
0103   0196             
0104   0196             
0105   0196 44 69 73 6B st0:        .db "Disk in Drive A?",13,10,13,10,0
0105   019A 20 69 6E 20 
0105   019E 44 72 69 76 
0105   01A2 65 20 41 3F 
0105   01A6 0D 0A 0D 0A 
0105   01AA 00 
0106   01AB 50 72 65 73 st1:        .db "Press any key: ",0
0106   01AF 73 20 61 6E 
0106   01B3 79 20 6B 65 
0106   01B7 79 3A 20 00 
0107   01BB 6E 6F 20 64 st2:        .db "no disk.",13,10,0
0107   01BF 69 73 6B 2E 
0107   01C3 0D 0A 00 
0108   01C6 0D 0A 42 6F st3:        .db 13,10,"Booting from drive A...",13,10,0
0108   01CA 6F 74 69 6E 
0108   01CE 67 20 66 72 
0108   01D2 6F 6D 20 64 
0108   01D6 72 69 76 65 
0108   01DA 20 41 2E 2E 
0108   01DE 2E 0D 0A 00 
0109   01E2 21 00 00 00 cmdStr      .db 21h,00,00,00,01,00,00h
0109   01E6 01 00 00 
0110   01E9             
0111   01E9             .ENDtasm: Number of errors = 0
