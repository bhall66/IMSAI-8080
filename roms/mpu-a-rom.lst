0001   0000             ;
0002   0000             ;   Title:   mpu-a-rom.asm
0003   0000             ;  Author:   Bruce E. Hall, w8bh
0004   0000             ;    Date:   04 Jul 2025
0005   0000             ;      HW:   IMSAI8080 emulator by TheHighNibble
0006   0000             ;      SW:   TASM compiler using Z80 mnemonics (-80 option)
0007   0000             ;            
0008   0000             ;   Descr:   This file represents a hand disassembly of the MPU-A-ROM.hex
0009   0000             ;            source file, which is found on the z80pack GitHub repository.
0010   0000             ;            
0011   0000             ;            All labels, equates, and comments are mine.      
0012   0000             ;           
0013   0000             ;            Assemble using "TASM -80 -o20 mpu-a-rom.asm"
0014   0000             ;            to reproduce the source file.
0015   0000             ;
0016   0000             
0017   0000             CONIO      .EQU  2              ; console I/O
0018   0000             CONSTAT    .EQU  3              ; console status
0019   0000             MMU        .EQU  0F3h           ; memory management unit port
0020   0000             FDC        .EQU  0FDh           ; floppy disk controller port
0021   0000             WP         .EQU  0FEh           ; memory write protect port
0022   0000             
0023   0000             FDCMD      .EQU  0              ; offset for floppy disk unit/command byte
0024   0000             FDRES      .EQU  1              ; offset for floppy disk result code
0025   0000             FDTRK      .EQU  3              ; offset for floppy disk track# (byte)
0026   0000             FDSEC      .EQU  4              ; offset for floppy disk sector# (byte)
0027   0000             FDDMA      .EQU  5              ; offset for floppy disk DMA buffer address
0028   0000             
0029   0000             MPAGE      .EQU  0A800h         ; base address for memory (variables)
0030   0000             m01        .EQU  MPAGE + 0E3h   ; scrachpad used for ASCII dump & disk descriptor
0031   0000             m02        .EQU  MPAGE + 0F4h   ; Floppy controller type (1, 2, or 4)
0032   0000             m03        .EQU  MPAGE + 0F5h   ; video driver init stuff
0033   0000             m04        .EQU  MPAGE + 0F6h   ; input devices (1=UART,2=PARALLEL,4=SYSTEM SERIAL)
0034   0000             m05        .EQU  MPAGE + 0F7h   ; output devices (1=UART,2=PARALLEL,4=SYSTEM SERIAL)
0035   0000             m06        .EQU  MPAGE + 0F8h   ; contains address where direct I/O is done
0036   0000             m07        .EQU  MPAGE + 0FAh   ; direct I/O operations done here (2 byte I/O + return)
0037   0000             m08        .EQU  MPAGE + 0FDh   ; contains character to be output, or FDC cmd
0038   0000             m09        .EQU  MPAGE + 0FEh   ; address of FDC disk descriptor (0080h)
0039   0000             
0040   0000             VIOPAGE    .EQU  0F800h         ; VIO ROM address
0041   0000             VIOINIT    .EQU  VIOPAGE        ; VIO initialization address
0042   0000             VIOOUT     .EQU  VIOPAGE + 03h  ; VIO character output address
0043   0000             VIOSTART   .EQU  VIOPAGE + 06h  ; VIO entry point
0044   0000             VIOSIG     .EQU  VIOPAGE + 7FDh ; VIO firmware signature "VIO" 
0045   0000             
0046   0000             TIMER0     .EQU  0D100h         ; timer0 address
0047   0000             TIMCTRL    .EQU  0D103h         ; timer control register
0048   0000             
0049   0000             
0050   D800                 .ORG    0D800H
0051   D800             
0052   D800 3E 40               LD   A,40H
0053   D802 D3 F3               OUT  (MMU),A            ; turn off ROM at 0000-07FF
0054   D804 C3 10 D8            JP   j01                ; jump vector for start
0055   D807 C3 84 DD            JP   getCh              ; jump vector for getCh
0056   D80A C3 AF DD            JP   putCh              ; jump vector for putCh
0057   D80D C3 2F DA            JP   j04                ; jump vector for memory dump (addr in HL, count in BC)
0058   D810 AF          j01:    XOR  A
0059   D811 32 F5 A8            LD   (m03),A 
0060   D814 D3 FE               OUT  (WP),A             ; unprotect page0 memory where DMA lives
0061   D816 31 E3 D0            LD   SP,0D0E3h          ; put SP in MPU-B RAM, above timers?
0062   D819 21 80 00            LD   HL,0080h           ; store default disk descriptor address
0063   D81C 22 FE A8            LD   (m09),HL           ; at m09
0064   D81F CD 8F D8            CALL diskOK             ; check disk status (1=disk present)
0065   D822 3D                  DEC  A 
0066   D823 CA E1 D8            JP   Z,bootFD           ; disk present, so boot with jump to 0000.
0067   D826 AF                  XOR  A                  ; no disk, so continue loading monitor
0068   D827 32 F7 A8            LD   (m05),A            ; init m05 = 0
0069   D82A 3A F5 A8            LD   A,(m03)
0070   D82D 3C                  INC  A 
0071   D82E CA 39 D8            JP   Z,j07 
0072   D831 CD 19 DD            CALL vidOK              ; is video driver present?
0073   D834 3E 10               LD   A,10h              ; will set m05 = 10h
0074   D836 CA 4A D8            JP   Z,j09              ; yes, initialize the driver.
0075   D839 3E FF       j07:    LD   A,0FFh             ; no, to try with WP
0076   D83B D3 FE               OUT  (WP),A 
0077   D83D CD 19 DD            CALL vidOK              ; test again: is video driver present?
0078   D840 C2 50 D8            JP   NZ,j10             ; no, jump
0079   D843 3E FF               LD   A,0FFh             ; yes, so initialize it
0080   D845 32 F5 A8            LD   (m03),A            ; set m03 = FFh
0081   D848 3E 20               LD   A,20h
0082   D84A 32 F7 A8    j09:    LD   (m05),A            ; set m05 = 20h
0083   D84D CD 00 F8            CALL VIOINIT            ; and initialize the driver.
0084   D850 21 FA A8    j10:    LD   HL,m07             ; address where direct I/O done
0085   D853 22 F8 A8            LD   (m06),HL           ; store this address in m06
0086   D856 3E AE               LD   A,0AEh 
0087   D858 D3 03               OUT  (CONSTAT),A        ; send UART mode = AE
0088   D85A 3E 27               LD   A,27h
0089   D85C D3 03               OUT  (CONSTAT),A        ; send UART command = 27h
0090   D85E CD E8 D8            CALL testIO             ; find input device(s), determine baud rate
0091   D861 21 F3 DE            LD   HL,str4         
0092   D864 CD A2 DD            CALL putStr             ; print "IMSAI IEEE MONITOR..." message
0093   D867             
0094   D867 31 E3 D0    wboot:  LD   SP,0D0E3h 
0095   D86A 21 6A D8    j54:    LD   HL,j54             
0096   D86D E5                  PUSH HL                 ; push monitor restart address on stack
0097   D86E CD 13 DE            CALL crlf               ; start a new line
0098   D871 3E 3F               LD   A,3Fh              
0099   D873 CD AF DD            CALL putCh              ; print monitor command prompt "?"
0100   D876 CD 84 DD            CALL getCh              ; and get input character
0101   D879 21 A2 DE            LD   HL,cmdTbl          ; points table of monitor commands
0102   D87C CD E8 DD    j17:    CALL getCh2             ; get next character with processing
0103   D87F CD 2A DD            CALL lookup             ; is it a command?
0104   D882 C8                  RET  Z                  ; return if command not found
0105   D883 CD 39 DE            CALL space              ; print a space                
0106   D886 06 01               LD   B,1
0107   D888 E9                  JP   (HL)               ; handle the command request
0108   D889 21 E1 DE    cmd2:   LD   HL,cmdTbl2         ; point to start of 2nd command table
0109   D88C C3 7C D8            JP   j17                ; main program loop
0110   D88F             
0111   D88F             ;  Determine controller type, and verify disk via a read operation
0112   D88F             ;  Returning result code in reg A (code 1 = read OK, disk available)
0113   D88F             ;
0114   D88F CD D2 DB    diskOK: CALL initDD             ; create a disk descriptor
0115   D892 21 F4 A8            LD   HL,m02
0116   D895 3A F5 A8            LD   A,(m03)
0117   D898 3C                  INC  A 
0118   D899 CA AC D8            JP   Z,j19
0119   D89C 3A FD E7            LD   A,(0E7FDh)         ; load signature byte 1
0120   D89F D6 44               SUB  44h                ; is it a 'D'?
0121   D8A1 C2 AC D8            JP   NZ,j19             ; jump if no
0122   D8A4 3A FE E7            LD   A,(0E7FEh)         ; load signature byte 2
0123   D8A7 D6 49               SUB  49h                ; is it an 'I'?
0124   D8A9 CA D0 D8            JP   Z,j25              ; found it, so continue at E00C below
0125   D8AC 3E F8       j19:    LD   A,0F8h 
0126   D8AE D3 FE               OUT  (WP),A             ; unprotect F800h memory block
0127   D8B0 3A FD F7            LD   A,(0F7FDh)         ; load signature byte 1
0128   D8B3 D6 44               SUB  44h                ; is it a 'D'?
0129   D8B5 C2 CB D8            JP   NZ,j20             ; jump if no.
0130   D8B8 3A FE F7            LD   A,(0F7FEh)         ; load signature byte 2
0131   D8BB D6 49               SUB  49h                ; is it a 'I'?
0132   D8BD C2 CB D8            JP   NZ,j20             ; jump if no.
0133   D8C0 3E FF               LD   A,0FFh
0134   D8C2 32 F5 A8            LD   (m03),A 
0135   D8C5 CD 0C F0            CALL 0F00Ch             ; found it, continue at F00C
0136   D8C8 C3 D3 D8            JP   j23
0137   D8CB 36 04       j20:    LD   (HL),4             ; neither of above, so type "4"
0138   D8CD C3 F4 DB            JP   fdExec             ; execute the FD command
0139   D8D0 CD 0C E0    j25:    CALL 0E00Ch
0140   D8D3 36 02       j23:    LD   (HL),2             ; store controller type "2"
0141   D8D5 CD F4 DB            CALL fdExec             ; execute the FD command
0142   D8D8 F0                  RET  P
0143   D8D9 21 F4 A8            LD   HL,m02 
0144   D8DC 36 01               LD   (HL),1             ; store controller type "1"
0145   D8DE C3 F4 DB            JP   fdExec             ; execute the FD command
0146   D8E1             
0147   D8E1 3E C0       bootFD: LD   A,0C0h             
0148   D8E3 D3 F3               OUT  (MMU),A            ; remove ROM from memory map
0149   D8E5 C3 00 00            JP   0000h              ; cold boot time!
0150   D8E8             
0151   D8E8             ; testIO will test for the presence of I/O ports, and determine the proper baud rate
0152   D8E8             ; for the serial port.
0153   D8E8             ;
0154   D8E8 DB 14       testIO: IN   A,(14h)
0155   D8EA 21 12 DF    j63:    LD   HL,str5
0156   D8ED CD A2 DD            CALL putStr             ; print "HIT SPACE BAR" message
0157   D8F0 21 F6 A8            LD   HL,m04             ; point to input device list
0158   D8F3 AF                  XOR  A                  ; 0 = start with empty list
0159   D8F4 77                  LD  (HL),A              ; initializes device list
0160   D8F5             
0161   D8F5                     ; first, test for a specific UART mode
0162   D8F5             
0163   D8F5 CD 88 D9            CALL j26                ; put UART in synchronous mode (?)
0164   D8F8 06 00               LD   B,0                ; Reg B will track devices as they are found
0165   D8FA DB 12               IN   A,(12h)            ; look at serial port 12 input
0166   D8FC B7                  OR   A                  ; anything there?
0167   D8FD CA 01 D9            JP   Z,j27              ; yes, skip to next test
0168   D900 04                  INC  B                  ; wasn't zero, so flag this mode
0169   D901             
0170   D901                     ; the loop below waits for input on serial and parallel ports,
0171   D901                     ; marks which are found, and exits if parallel or system serial.
0172   D901             
0173   D901 CD 4E DD    j27:    CALL parIn              ; look for input on parallel port
0174   D904 C2 55 D9            JP   NZ,ppFnd           ; if found, mark as parallel & exit
0175   D907 CD 46 DD            CALL sysIn              ; try getting input from serial port 2/3
0176   D90A C2 66 D9            JP   NZ,j30             ; if only on system port, mark as device 4 & exit
0177   D90D 78                  LD   A,B 
0178   D90E B7                  OR   A 
0179   D90F CA 01 D9            JP   Z,j27              ; loop until device is found
0180   D912 CD 3E DD            CALL serIn              ; try getting input from serial port 12/13h
0181   D915 CA 01 D9            JP   Z,j27              ; loop if nothing there
0182   D918 3C          j86:    INC  A 
0183   D919 CA 01 D9            JP   Z,j27              ; loop if FFh received
0184   D91C             
0185   D91C                     ; Serial port 12h:  Automatically determine the baud rate
0186   D91C                     ; When a character is ready on the UART, measure long it takes to receive it
0187   D91C             
0188   D91C 06 00               LD   B,0                ; initialize wait-for-character counter
0189   D91E CD 3E DD    j75:    CALL serIn              ; look at serial port 12/13h
0190   D921 CA 1E D9            JP   Z,j75              ; & wait until char is ready
0191   D924 04                  INC  B                  ; char received, so count until it is received
0192   D925 B7                  OR   A                  ; has the char been received yet?
0193   D926 CA 1E D9            JP   Z,j75              ; loop until char is received
0194   D929             
0195   D929                     ; B now contains the # of above loops it took to receieve a character
0196   D929                     ; use Baud Table #1 to translate this to an approximate baud rate
0197   D929             
0198   D929 21 7C DE            LD   HL,baudT1-1        ; point to baud rate table #1
0199   D92C 23          j99:    INC  HL
0200   D92D 7E                  LD   A,(HL)             ; get a timer byte from table
0201   D92E B7                  OR   A                  ; 0= could not find baud rate
0202   D92F CA EA D8            JP   Z,j63              ; so try again from beginnning
0203   D932 B8                  CP   B                  ; compare table value to loop counter
0204   D933 23                  INC  HL                 ; point to next value in table
0205   D934 DA 2C D9            JP   C,j99              ; loop if its less than loop counter
0206   D937 7E                  LD   A,(HL)             ; otherwise get following byte in table
0207   D938 F5                  PUSH AF                 ; and save it as the correspoding baud rate
0208   D939 CD C1 D9            CALL setBaud            ; set system baud rate to A (ex: 48 = 4800 baud)
0209   D93C 06 01               LD   B,1                ; mark device "1" present
0210   D93E CD 7D D9            CALL j92                ; and add it to input & output bitmaps
0211   D941 F1                  POP  AF                 ; restore table value
0212   D942             
0213   D942                     ; finally, print the baud rate that was established.
0214   D942             
0215   D942 67                  LD   H,A                ; and save as baud rate
0216   D943 2E 00               LD   L,0
0217   D945 FE 01               CP   1                  ; is baud rate 100?
0218   D947 C2 4C D9            JP   NZ,j96
0219   D94A 2E 10               LD   L,10h              ; convert baud "100" to "110"
0220   D94C CD 31 DE    j96:    CALL pHex16             ; print value as baud rate (ex "9600")
0221   D94F 21 2F DF            LD   HL,str7
0222   D952 C3 A2 DD            JP   putStr             ; print "BAUD SERIAL" message
0223   D955             
0224   D955 06 02       ppFnd:  LD   B,2                ; Parallel port found: mark it as device '2'
0225   D957 CD 7D D9            CALL j92                ; and add it to input & output bitmaps
0226   D95A E6 30               AND  30h
0227   D95C CA 60 D9            JP   Z,j97
0228   D95F 77                  LD   (HL),A 
0229   D960 21 3D DF    j97:    LD   HL,str8
0230   D963 C3 A2 DD            JP   putStr             ; print "PARALLEL" message
0231   D966             
0232   D966 4F          j30:    LD   C,A                ; save input in C
0233   D967 DB 12               IN   A,(12h)            ; look at input from serial port 12
0234   D969 B9                  CP   C                  ; if they match,
0235   D96A CA 18 D9            JP   Z,j86              ; jump back to input loop
0236   D96D DB 14               IN   A,(14h)            ; look at input from parallel port 14
0237   D96F B9                  CP   C                  ; does it match character?
0238   D970 CA 55 D9            JP   Z,ppFnd            ; yes, so mark it as parallel & leave
0239   D973 79                  LD   A,C                ; input is from system serial; retrieve it
0240   D974 E6 7F               AND  7Fh                ; look at only the lower 7 bits
0241   D976 FE 20               CP   20h                ; is the character a ' ' (space)?
0242   D978 C2 01 D9            JP   NZ,j27             ; not a space, so return to input loop
0243   D97B 06 04               LD   B,4                ; space found, so mark as device '4'
0244   D97D             
0245   D97D             ; save the I/O device(s) in B to the input and output bitmaps 
0246   D97D 21 F6 A8    j92:    LD   HL,m04             ; get current input device bits
0247   D980 7E                  LD   A,(HL)             ; into A
0248   D981 B0                  OR   B                  ; add device(s) in B
0249   D982 77                  LD   (HL),A             ; and save bitmap back in m04
0250   D983 23                  INC  HL                 ; get output device bits
0251   D984 7E                  LD   A,(HL)             ; into A
0252   D985 B0                  OR   B                  ; and device(s) in B
0253   D986 77                  LD   (HL),A             ; and save bits back in m05
0254   D987 C9                  RET
0255   D988             
0256   D988             ; this routine puts UART in synchonous mode at a specific speed
0257   D988             ;
0258   D988 21 42 00    j26:    LD   HL,0042h           
0259   D98B CD D5 D9            CALL setT0              ; send counter value in HL to timer0 
0260   D98E CD AC D9            CALL resetU             ; reset UART
0261   D991 3E 4C               LD   A,4Ch              ; cmd byte 4Ch
0262   D993 D3 13               OUT  (13h),A            ; send reset cmd to UART          
0263   D995 3E FF               LD   A,0FFh             
0264   D997 D3 13               OUT  (13h),A 
0265   D999 D3 13               OUT  (13h),A 
0266   D99B 3E B7               LD   A,0B7h             ; command B7h =       
0267   D99D D3 13               OUT  (13h),A            ; put UART in synchronous mode
0268   D99F C9                  RET
0269   D9A0             
0270   D9A0             ; Set up serial port UART at ports 12/13h with normal settings
0271   D9A0             ;
0272   D9A0 CD AC D9    initU:  CALL resetU             ; soft reset UART
0273   D9A3 3E AE               LD   A,0AEh             ; baud=1/16 clk; 8 bits; no parity; 1.5 stop
0274   D9A5 D3 13               OUT  (13h),A            ; send command AE
0275   D9A7 3E 37               LD   A,37h              ; reset flags, RTS/DTR true; Rx/Tx enabled
0276   D9A9 D3 13               OUT  (13h),A            ; send command 37
0277   D9AB C9                  RET
0278   D9AC             
0279   D9AC             ;  Do a software reset of the serial UART at ports 12/13h
0280   D9AC             ;
0281   D9AC AF          resetU: XOR  A                  ; zero out A
0282   D9AD D3 13               OUT  (13h),A            ; prepare reset to serial UART
0283   D9AF D3 13               OUT  (13h),A 
0284   D9B1 D3 13               OUT  (13h),A 
0285   D9B3 3E 40               LD   A,40h              ; 40h = reset UART command
0286   D9B5 D3 13               OUT  (13h),A            ; do UART software reset
0287   D9B7 C9                  RET
0288   D9B8             
0289   D9B8             ; Handle the Change Baud Rate "Z" command
0290   D9B8             ;
0291   D9B8 CD 3E DE    cmdZ:   CALL getHex             ; get baud rate from user
0292   D9BB 7C                  LD   A,H 
0293   D9BC B5                  OR   L                  ; is it 0 (or no input)?
0294   D9BD CA EA D8            JP   Z,j63              ; do 2 terminal procedure 
0295   D9C0 7C                  LD   A,H                ; get upper 2 digits of baud rate into A
0296   D9C1 21 8C DE    setBaud:LD   HL,baudT2          ; point to the baud table #2
0297   D9C4 C5                  PUSH BC 
0298   D9C5 CD 2A DD            CALL lookup             ; find the baud rate & timer0 count 
0299   D9C8 C1                  POP  BC 
0300   D9C9 C4 D5 D9            CALL NZ,setT0           ; send counter value in HL to timer0
0301   D9CC C2 A0 D9            JP   NZ,initU           ; initialize UART in usual manner (8N1.5)
0302   D9CF 21 22 DF            LD   HL,str6            ; could not find baud rate, so  
0303   D9D2 C3 A2 DD            JP   putStr             ; print "Invalid Baud" message
0304   D9D5             
0305   D9D5             ; The following routine sets up timer0 with the count value in HL
0306   D9D5             ;
0307   D9D5 11 03 D1    setT0:  LD   DE,TIMCTRL         ; DE = timer mode address
0308   D9D8 EB                  EX   DE,HL 
0309   D9D9 36 36               LD   (HL),36h           ; set mode=36h (timer0, Read LSB/MSB, Mode 3, Binary)
0310   D9DB 21 00 D1            LD   HL,TIMER0          ; D100 = timer0 address
0311   D9DE 73                  LD   (HL),E             ; store LSB first
0312   D9DF 72                  LD   (HL),D             ; then store MSB
0313   D9E0 C9                  RET 
0314   D9E1             
0315   D9E1             ; Handle the Jump Memory "J" command
0316   D9E1             ;
0317   D9E1 D1          cmdJ:   POP  DE                 ; remove return address from stack
0318   D9E2             
0319   D9E2             ; Handle the Call Routine "C" command
0320   D9E2             ;
0321   D9E2 CD 3E DE    cmdC:   CALL getHex             ; get address from user
0322   D9E5 E9                  JP   (HL)               ; and go there!
0323   D9E6             
0324   D9E6             ; Handle the Kill ROM & Jump "K" command
0325   D9E6             ;
0326   D9E6 CD 3E DE    cmdK:   CALL getHex             ; get address from user
0327   D9E9 3E C0               LD   A,0C0h
0328   D9EB D3 F3               OUT  (MMU),A            ; remove ROM from memory map
0329   D9ED E9                  JP   (HL)               ; and jump to (HL)!
0330   D9EE             
0331   D9EE             ; Handle the Kill ROM & quit to VIO "Q" command
0332   D9EE             ;
0333   D9EE 3A F7 A8    cmdQ:   LD   A,(m05)            ; look at output locations
0334   D9F1 E6 30               AND  30h                ; if bits 4 & 5 are zero,
0335   D9F3 C8                  RET  Z                  ; return
0336   D9F4 3A F5 A8            LD   A,(m03)            ; get contents of m03
0337   D9F7 3C                  INC  A 
0338   D9F8 C2 FF D9            JP   NZ,j49             ; if it FF?
0339   D9FB 3E FF               LD   A,0FFh             ; if yes, fiddle with WP first
0340   D9FD D3 FE               OUT  (WP),A 
0341   D9FF 3E C0       j49:    LD   A,0C0h             
0342   DA01 D3 F3               OUT  (MMU),A            ; remove ROM from memory map 
0343   DA03 C3 06 F8            JP   VIOSTART           ; and jump to video driver
0344   DA06             
0345   DA06             ; Handle the Examine memory "E" command
0346   DA06             ;
0347   DA06 CD 3E DE    cmdE:   CALL getHex             ; get address from user
0348   DA09 CD 13 DE    j61:    CALL crlf
0349   DA0C CD 31 DE            CALL pHex16             ; print address + space 
0350   DA0F CD 20 DA            CALL j62                ; print byte, prompt for new value
0351   DA12 2B                  DEC  HL                 ; point to previous address
0352   DA13 FE 0A               CP   0Ah                ; if user pressed <enter>
0353   DA15 C8                  RET  Z                  ; then quit
0354   DA16 FE 2D               CP   02Dh               ; if user pressed "-"
0355   DA18 CA 09 DA            JP   Z,j61              ; then show value at previous addr
0356   DA1B 23                  INC  HL                 ; otherwise to go next address
0357   DA1C 23                  INC  HL 
0358   DA1D C3 09 DA            JP   j61                ; and show it
0359   DA20             
0360   DA20             ; the following routine shows hex value at HL and allows user to change it.
0361   DA20             ;
0362   DA20 7E          j62:    LD   A,(HL)             ; get memory byte
0363   DA21 5F                  LD   E,A                ; save value in E
0364   DA22 CD 36 DE            CALL pHexSp             ; print it in hex, followed by space
0365   DA25 EB                  EX   DE,HL              ; temp save HL
0366   DA26 CD 41 DE            CALL j45                ; get new value into L
0367   DA29 EB                  EX   DE,HL              ; restore HL, new value now in E
0368   DA2A 73                  LD   (HL),E             ; put value back in HL
0369   DA2B C9                  RET 
0370   DA2C             
0371   DA2C             ; Handle the Display/Dump memory "D" command:
0372   DA2C             ; parameters are start address (HL) and optional end address in DE
0373   DA2C             ; if no end address, just one byte is printed.
0374   DA2C             ; after 24 lines print, it will wait for keypress before continuing
0375   DA2C             
0376   DA2C             
0377   DA2C CD E7 DC    cmdD:   CALL param2             ; get start addr in HL and count in BC
0378   DA2F 1E 18       j04:    LD   E,18h              ; E = max line counter
0379   DA31 E5                  PUSH HL                 ; start start addr on stack
0380   DA32 53          j81:    LD   D,E                ; reset D to line counter
0381   DA33             
0382   DA33                     ; printing of a line of byte values starts here
0383   DA33                     ; first job is to clear scratchpad area for ASCII characters
0384   DA33             
0385   DA33 D5          j80:    PUSH DE                 ; save current line counter on stack
0386   DA34 16 11               LD   D,11h              ; set up a counter for 17 bytes   
0387   DA36 21 F4 A8            LD   HL,m02             ; pointing to space between m01 and m02
0388   DA39 AF                  XOR  A                  ; A=0
0389   DA3A 2B          j60:    DEC  HL                 ; going backwards
0390   DA3B 77                  LD   (HL),A             ; clear ASCII char scratchpad area
0391   DA3C 15                  DEC  D                  
0392   DA3D C2 3A DA            JP   NZ,j60             ; after loop done, HL points to m01 scratchpad area
0393   DA40 D1                  POP  DE                 ; restore line counter
0394   DA41 E3                  EX   (SP),HL            ; swap start address and ASCII store area
0395   DA42             
0396   DA42                     ; the line begins with printing the memory address
0397   DA42             
0398   DA42 CD 13 DE            CALL crlf               ; start a new line
0399   DA45 CD 31 DE            CALL pHex16             ; with address shown
0400   DA48 CD 39 DE            CALL space              ; followed by a space 
0401   DA4B             
0402   DA4B                     ; printing of each hex value in the line starts here
0403   DA4B             
0404   DA4B CD 84 DD    j84:    CALL getCh              ; does user want to stop output?
0405   DA4E C2 8F DA            JP   NZ,j79             ; yep, so quit
0406   DA51 7E                  LD   A,(HL)             ; get byte at current address
0407   DA52 CD 36 DE            CALL pHexSp             ; and print hex digits + space
0408   DA55 7E                  LD   A,(HL)             ; reload character
0409   DA56 23                  INC  HL                 ; increment the current address
0410   DA57             
0411   DA57                     ; before going to the next byte, store an ASCII representation of the value 
0412   DA57                     ; in the scratchpad area, replacing nonprintable values with '.'
0413   DA57             
0414   DA57 E3                  EX   (SP),HL            ; swap in scrathpad address
0415   DA58 77                  LD   (HL),A             ; store byte value as potential character
0416   DA59 FE 20               CP   20h                ; is value a control character?
0417   DA5B DA 63 DA            JP   C,j82              ; yes, so replace with '.'
0418   DA5E FE 7F               CP   7Fh                ; is value above ASCII?
0419   DA60 DA 65 DA            JP   C,j83              ; if not, it a printable character
0420   DA63 36 2E       j82:    LD   (HL),2Eh           ; replace nonprintable char with '.'
0421   DA65 23          j83:    INC  HL                 ; go to next location in ASCII string
0422   DA66 0B                  DEC  BC                 ; decrement byte counter
0423   DA67 78                  LD   A,B 
0424   DA68 B1                  OR   C                  ; is it zero (all done)?
0425   DA69 CA 74 DA            JP   Z,j78              ; exit if done
0426   DA6C             
0427   DA6C                     ; Evaluate if there are more bytes to show in this line
0428   DA6C             
0429   DA6C E3                  EX   (SP),HL            ; swap current addr back in
0430   DA6D 7D                  LD   A,L                ; look at lower byte
0431   DA6E E6 0F               AND  0Fh                ; are we at xxx0?
0432   DA70 C2 4B DA            JP   NZ,j84             ; if not loop
0433   DA73             
0434   DA73                     ; All 16 bytes have been printed as hex values, so print the ASCII string
0435   DA73             
0436   DA73 E3                  EX   (SP),HL            ; swap addr back out
0437   DA74 CD 39 DE    j78:    CALL space              ; print a space  
0438   DA77 21 E3 A8            LD   HL,m01             ; load address of ASCII string
0439   DA7A CD A2 DD            CALL putStr             ; and print it
0440   DA7D             
0441   DA7D                     ; Evaluate if there are more lines to print, and loop accordingly
0442   DA7D             
0443   DA7D 78                  LD   A,B 
0444   DA7E B1                  OR   C                  ; if byte counter is zero,
0445   DA7F CA 8F DA            JP   Z,j79              ; then quit
0446   DA82 15                  DEC  D                  ; decrement line counter
0447   DA83 C2 33 DA            JP   NZ,j80             ; do next line if still space on screen
0448   DA86 CD 7D DD            CALL getCh1             ; have shown 24 lines, so wait for user
0449   DA89 CD 13 DE            CALL crlf               ; start next line
0450   DA8C C3 32 DA            JP   j81                ; with reset of line counter
0451   DA8F E1          j79:    POP  HL                 ; get rid of start addr pushed on stack
0452   DA90 C3 13 DE            JP   crlf 
0453   DA93             
0454   DA93             ;  Tape Loader: Read input in Intel Hex format.  If a checksum error is found
0455   DA93             ;  then C will be output.  If an invalid character is found then 'T' will be output
0456   DA93             ;  and the operation will be terminated.
0457   DA93             
0458   DA93 CD E8 DD    cmdL:   CALL getCh2             ; get next character with processing
0459   DA96 D6 3A               SUB  3Ah                ; is it a ":"?
0460   DA98 C2 93 DA            JP   NZ,cmdL            ; no, so keep reading
0461   DA9B 57                  LD   D,A                ; start of new line, set checksum counter to 0
0462   DA9C CD C0 DA            CALL j41                ; read next 2 hex digits, convert to number (byte counter)
0463   DA9F C8                  RET  Z                  ; if zero, then complete file had been read
0464   DAA0 43                  LD   B,E                ; otherwise, result is #byte in this line
0465   DAA1 CD C0 DA            CALL j41                ; read next 2 hex digits, convert to number 
0466   DAA4 63                  LD   H,E                ; put result in H
0467   DAA5 CD C0 DA            CALL j41                ; read in 2 hex digits, convert to number 
0468   DAA8 6B                  LD   L,E                ; put result in L.  Now we have address to store data
0469   DAA9 CD C0 DA            CALL j41                ; read in 2 hex digits, convert to number
0470   DAAC CD C0 DA    j42:    CALL j41                ; read in 2 hex digits, convert to number (data byte)
0471   DAAF 73                  LD   (HL),E             ; put data byte into memory pointed
0472   DAB0 23                  INC  HL                 ; go to next memory address
0473   DAB1 05                  DEC  B                  ; decrement byte counter
0474   DAB2 C2 AC DA            JP   NZ,j42             ; loop until entire line read
0475   DAB5 CD C0 DA            CALL j41                ; read in 2 hex digits, convert to number (checksum)
0476   DAB8 CA 93 DA            JP   Z,cmdL             ; loop to read next line if checksum is OK
0477   DABB 3E 43               LD   A,43h              ; otherwise, 
0478   DABD C3 AF DD            JP   putCh              ; print "C" = checksum error
0479   DAC0             
0480   DAC0 CD E8 DD    j41:    CALL getCh2             ; get next character with processing
0481   DAC3 CD 57 DE            CALL isHex              ; convert ASCII to hex digit
0482   DAC6 DA DC DA            JP   C,j40              ; jump is not hex
0483   DAC9 87                  ADD  A,A                ; first digit, so muliply x 16.
0484   DACA 87                  ADD  A,A 
0485   DACB 87                  ADD  A,A
0486   DACC 87                  ADD  A,A 
0487   DACD 5F                  LD   E,A                ; store result in E
0488   DACE CD E8 DD            CALL getCh2             ; get next character with processing
0489   DAD1 CD 57 DE            CALL isHex              ; is char a hex digit? (NC=true)
0490   DAD4 DA DC DA            JP   C,j40              ; if not, jump.
0491   DAD7 83                  ADD  A,E                ; combine first and second digits
0492   DAD8 5F                  LD   E,A                ; store result in E
0493   DAD9 82                  ADD  A,D                ; add result to reg D
0494   DADA 57                  LD   D,A                ; where a running total is kept
0495   DADB C9                  RET
0496   DADC 3E 54       j40:    LD   A,54h 
0497   DADE CD AF DD            CALL putCh              ; print "T" = invalid character received
0498   DAE1 C3 6A D8            JP   j54                ; restart monitor
0499   DAE4             
0500   DAE4             ; Handle the Test Memory "T" command
0501   DAE4             ;
0502   DAE4 CD E7 DC    cmdT:   CALL param2             ; get start addr in HL and count in BC
0503   DAE7 0B                  DEC  BC 
0504   DAE8 AF          j90:    XOR  A                  ; start with byte pattern = 00
0505   DAE9 56                  LD   D,(HL)             ; save actual byte in D
0506   DAEA 77          j91:    LD   (HL),A             ; store pattern to memory
0507   DAEB BE                  CP   (HL)               ; and read it back.  Same?
0508   DAEC C2 00 DB            JP   NZ,j64             ; if not, show address & contents
0509   DAEF 3D                  DEC  A                  ; go to next byte pattern
0510   DAF0 C2 EA DA            JP   NZ,j91             ; and loop through all patterns
0511   DAF3 72                  LD   (HL),D             ; restore original byte to memory
0512   DAF4 CD 84 DD            CALL getCh              ; check to see if user wants to quit
0513   DAF7 C0                  RET  NZ                 ; quit now if so.
0514   DAF8 23                  INC  HL                 ; go to next memory location
0515   DAF9 0B                  DEC  BC                 ; and decrement the location counter
0516   DAFA 78                  LD   A,B 
0517   DAFB B1                  OR   C                  ; finished with all addresses (BC=0)?
0518   DAFC C2 E8 DA            JP   NZ,j90             ; no, so go to next address to test
0519   DAFF C9                  RET
0520   DB00             
0521   DB00 23          j64:    INC  HL 
0522   DB01 5F                  LD   E,A                ; save current byte pattern
0523   DB02 CD 70 DE            CALL showAB             ; display an address (HL-1) and its byte contents
0524   DB05 7B                  LD   A,E                ; restore current byte pattern
0525   DB06 C3 6C DE            JP   j93                ; show expected byte pattern
0526   DB09             
0527   DB09             ; Handle the Move Memory "M" command
0528   DB09             ; call with <start addr>,<end addr>,<destination addr>
0529   DB09             ;
0530   DB09 CD 0A DD    cmdM:   CALL param3             ; load parameters into HL, DE, and BC
0531   DB0C C3 90 DB    j56:    JP   memcpy
0532   DB0F             
0533   DB0F             ; Handle the Fill Memory "F" command
0534   DB0F             ; call with <start addr>, <end addr>, <fill character>
0535   DB0F             ;
0536   DB0F CD 0A DD    cmdF:   CALL param3             ; load parameters into HL, DE, and BC
0537   DB12 7B                  LD   A,E                ; fill character in DE moved to A
0538   DB13 77                  LD   (HL),A             ; load first one to start address
0539   DB14 0B                  DEC  BC                 ; count one done.
0540   DB15 54                  LD   D,H                ; DE = HL
0541   DB16 5D                  LD   E,L 
0542   DB17 13                  INC  DE                 ; set destination = start + 1
0543   DB18 C3 0C DB            JP   j56                ; and do memory copy
0544   DB1B             
0545   DB1B             ; Handle the Input Port "I" command
0546   DB1B             ;
0547   DB1B 05          cmdI:   DEC  B                  ; falls through to next routine
0548   DB1C             
0549   DB1C             ; Handle the Output Port "O" command
0550   DB1C             ;
0551   DB1C CD 10 DD    cmdO:   CALL getHD              ; get port# in HL, 2nd in DE
0552   DB1F 78                  LD   A,B                ; A=0 for IN, 1 for OUT
0553   DB20 07                  RLCA                    ; 3 rotates set up A to contain I/O opcode
0554   DB21 07                  RLCA
0555   DB22 07                  RLCA                    ; now A=0 for IN, 08 for OUT
0556   DB23 EE DB               XOR  0DBh               ; now A=DB for IN, D3 for OUT
0557   DB25 55                  LD   D,L                ; put port# in D
0558   DB26 2A F8 A8            LD   HL,(m06)           ; get address for direct I/O
0559   DB29 77                  LD   (HL),A             ; store instruction (IN or OUT)
0560   DB2A BE                  CP   (HL)               ; did it stick?
0561   DB2B C0                  RET  NZ                 ; nope, so cant use this memory
0562   DB2C E5                  PUSH HL                 ; save this address
0563   DB2D 23                  INC  HL 
0564   DB2E 72                  LD   (HL),D             ; after IN/OUT, add add Port#
0565   DB2F 23                  INC  HL 
0566   DB30 36 C9               LD   (HL),0C9h          ; after port#, add a RET instruction
0567   DB32 31 3A DB            LD   SP,j52             ; put return address on stack?
0568   DB35 E3                  EX   (SP),HL 
0569   DB36 78                  LD   A,B 
0570   DB37 B7                  OR   A 
0571   DB38 7B                  LD   A,E 
0572   DB39 E9                  JP  (HL)                ; execute the I/O instruction
0573   DB3A CA 36 DE    j52:    JP  Z,pHexSp
0574   DB3D C9                  RET 
0575   DB3E             
0576   DB3E             ; Handle the Change direct I/O address "Y" command
0577   DB3E             ;
0578   DB3E CD 3E DE    cmdY:   CALL getHex             ; get address from user into HL
0579   DB41 7C                  LD   A,H 
0580   DB42 B5                  OR   L                  ; is HL=0?
0581   DB43 C2 49 DB            JP   NZ,j53             ; no, use the user input
0582   DB46 21 FA A8            LD   HL,m07             ; yes, reset to original location m07
0583   DB49 22 F8 A8    j53:    LD   (m06),HL           ; put new address into m06
0584   DB4C C9                  RET 
0585   DB4D             
0586   DB4D             ; Handle the Verify memory "V" command. 
0587   DB4D             ; The parameters are start (HL), destination (DE), and count (BC)  
0588   DB4D             ;
0589   DB4D CD 0A DD    cmdV:   CALL param3             ; load parameters into HL, DE, and BC
0590   DB50 1A          j74:    LD   A,(DE)             ; A = destination byte
0591   DB51 BE                  CP   (HL)               ; is it the same as start byte?
0592   DB52 23                  INC  HL                 ; go to next start byte
0593   DB53 13                  INC  DE                 ; go to next dest byte
0594   DB54 CA 5F DB            JP   Z,j73              ; if same, continue the verify
0595   DB57 CD 70 DE            CALL showAB             ; show source address and byte contents
0596   DB5A EB                  EX   DE,HL              ; flip to DE
0597   DB5B CD 73 DE            CALL j47                ; show destination address and its contents
0598   DB5E EB                  EX   DE,HL              ; flip back
0599   DB5F 0B          j73:    DEC  BC                 ; decrement counter
0600   DB60 78                  LD   A,B
0601   DB61 B1                  OR   C                  ; is count 0 yet?
0602   DB62 C8                  RET  Z                  ; quit if it is
0603   DB63 CD 84 DD            CALL getCh              ; check for keyboard input
0604   DB66 C0                  RET  NZ                 ; allow user to stop execution
0605   DB67 C3 50 DB            JP   j74                ; otherwise, keep going!
0606   DB6A             
0607   DB6A             ; Handle Search Memory "S" command
0608   DB6A             ; Parameters are start addr (HL), value to find (DE), byte counter (BC), optional mask (SP)
0609   DB6A             ;
0610   DB6A CD 0A DD    cmdS:   CALL param3             ; load parameters into HL, DE, and BC 
0611   DB6D E5                  PUSH HL                 ; put start address on stack
0612   DB6E 21 FF FF            LD   HL,0FFFFh          ; assume full 16-bit compare (mask FFFF)
0613   DB71 FE 0A               CP   0Ah                ; if no 4th parameter 
0614   DB73 C4 3E DE            CALL NZ,getHex          ; otherwise, get mask into HL 
0615   DB76 E3                  EX   (SP),HL            ; swap mask and start addr.
0616   DB77 7E          j77:    LD   A,(HL)             ; grab byte at current address
0617   DB78 E3                  EX   (SP),HL            ; swap mask into HL
0618   DB79 A4                  AND  H                  ; apply mask to current byte
0619   DB7A BA                  CP   D                  ; do compare with search value
0620   DB7B E3                  EX   (SP),HL            ; swap mask out
0621   DB7C 23                  INC  HL                 ; point to next byte to check
0622   DB7D C2 88 DB            JP   NZ,j76             ; no match, so continue search
0623   DB80 7E                  LD   A,(HL)             ; MSB matches, so check LSB now
0624   DB81 E3                  EX   (SP),HL            ; swap in mask
0625   DB82 A5                  AND  L                  ; apply mask to LSB
0626   DB83 BB                  CP   E                  ; and compare it to seach LSB
0627   DB84 E3                  EX   (SP),HL            ; swap make back out
0628   DB85 CC 68 DE            CALL Z,showAW           ; if match, show address (HL-1) and word contents
0629   DB88 0B          j76:    DEC  BC                 ; decrement counter
0630   DB89 78                  LD   A,B                ; check the byte counter
0631   DB8A B1                  OR   C                  ; is it zero?
0632   DB8B C2 77 DB            JP   NZ,j77             ; not done yet, grab next byte
0633   DB8E C1                  POP  BC                 ; get rid of mask pushed on stack
0634   DB8F C9                  RET
0635   DB90             
0636   DB90             ; Copy Memory from source (HL) to destination (DE)
0637   DB90             ; BC = number of bytes to copy
0638   DB90             ;
0639   DB90 78          memcpy: LD   A,B 
0640   DB91 B1                  OR   C                  ; is BC=0 yet?
0641   DB92 C8                  RET  Z                  ; if so, we are done.
0642   DB93 7E                  LD   A,(HL)             ; get byte from source address
0643   DB94 12                  LD   (DE),A             ; and copy to destination address
0644   DB95 0B                  DEC  BC                 ; decrement counter
0645   DB96 23                  INC  HL                 ; go to next source addr
0646   DB97 13                  INC  DE                 ; go to next destination addr
0647   DB98 C3 90 DB            JP   memcpy             ; loop until done.
0648   DB9B             
0649   DB9B             ; Handle the Boot to Floppy "B" command
0650   DB9B             ;
0651   DB9B CD 13 DE    cmdB:   CALL crlf               
0652   DB9E CD 8F D8            CALL diskOK             ; check disk, get return code
0653   DBA1 3D                  DEC  A                  ; status=1 is success.
0654   DBA2 CA E1 D8            JP   Z,bootFD           ; disk found, so boot with jump to 0000.
0655   DBA5             
0656   DBA5             ; Handle a floppy disk error by printing the result code
0657   DBA5             ;
0658   DBA5 E6 F0       fdErr:  AND  0F0h               ; look at upper 4 bits of disk status 
0659   DBA7 21 BD DB            LD   HL,st2
0660   DBAA FE A0               CP   0A0h               ; if status = A1h
0661   DBAC CA A2 DD            JP   Z,putStr           ; print "NOT READY" message
0662   DBAF 21 C7 DB            LD   HL,st3             ; otherwise,
0663   DBB2 CD A2 DD            CALL putStr             ; print "DISK ERR" message
0664   DBB5 2A FE A8            LD   HL,(m09)           ; point to disk descriptor
0665   DBB8 23                  INC  HL                 ; result code is in 2nd byte
0666   DBB9 7E                  LD   A,(HL)             ; get the disk error #
0667   DBBA C3 1D DE            JP   pHex               ; and print it
0668   DBBD             
0669   DBBD 4E 4F 54 20 st2:    .db "NOT READY",0
0669   DBC1 52 45 41 44 
0669   DBC5 59 00 
0670   DBC7 44 49 53 4B st3:    .db "DISK ERR- ",0 
0670   DBCB 20 45 52 52 
0670   DBCF 2D 20 00 
0671   DBD2             
0672   DBD2             
0673   DBD2             ; initDD: initializes 9 bytes FDC disc descriptor at A8E3-A8EB.
0674   DBD2             ; first byte contains command (2=read) in upper nibble and
0675   DBD2             ; unit (1=drive0, 2=drive1, 4=drive2, 8=drive3) in lower nibble
0676   DBD2             ;  21 00 00 00 01 00 00 00 00
0677   DBD2             ;
0678   DBD2 21 EB A8    initDD: LD   HL,m01+8            ; zero out a block of 9 bytes         
0679   DBD5 06 08               LD   B,8
0680   DBD7 2B          j70:    DEC  HL
0681   DBD8 36 00               LD   (HL),0
0682   DBDA 05                  DEC  B                  
0683   DBDB C2 D7 DB            JP   NZ,j70             
0684   DBDE 36 21               LD   (HL),21h           ; store 21 (Read Drive #0) as FDCMD
0685   DBE0 3E 01               LD   A,1 
0686   DBE2 32 E7 A8            LD   (m01+FDSEC),A      ; store 01 (Sector 1) as FDSEC
0687   DBE5 C9                  RET 
0688   DBE6             
0689   DBE6             ; Handle the "N" command
0690   DBE6             ; This command is not described in the VIO manual
0691   DBE6             ; It lets the user change the location of the disc descriptor, normally at 0080h.
0692   DBE6             ;
0693   DBE6 CD 3E DE    cmdN:   CALL getHex             ; get address from user 
0694   DBE9 7C                  LD   A,H 
0695   DBEA B5                  OR   L                  ; is it zero?
0696   DBEB C2 F0 DB            JP   NZ,j69             ; no, use it
0697   DBEE 2E 80               LD   L,80h              ; yes, use default value of 0080h.
0698   DBF0 22 FE A8    j69:    LD   (m09),HL           ; and store value at m09
0699   DBF3 C9                  RET 
0700   DBF4             
0701   DBF4             ; fdExec: copy DD to its destination, then issue FDC commands to recognize DD, 
0702   DBF4             ; execute the disk operation, and receive the result code.
0703   DBF4             ;
0704   DBF4 2A FE A8    fdExec: LD   HL,(m09)           ; HL = disk descriptor address
0705   DBF7 11 E3 A8            LD   DE,m01             ; copy of disk descriptor in scratchpad
0706   DBFA 06 07               LD   B,7                ; copies descriptor to its address
0707   DBFC EB          j85:    EX   DE,HL 
0708   DBFD 7E                  LD   A,(HL)             ; get a byte
0709   DBFE EB                  EX   DE,HL
0710   DBFF 77                  LD   (HL),A             ; and store it
0711   DC00 23                  INC  HL 
0712   DC01 13                  INC  DE 
0713   DC02 05                  DEC  B 
0714   DC03 C2 FC DB            JP   NZ,j85             ; loop until done.
0715   DC06 3A F5 A8            LD   A,(m03)            ; checks video stuff
0716   DC09 3C                  INC  A 
0717   DC0A C2 11 DC            JP   NZ,j65
0718   DC0D 3E F8               LD   A,0F8h 
0719   DC0F D3 FE               OUT  (WP),A 
0720   DC11 3E 10       j65:    LD   A,10h              ; FDC cmd 10h = set disk descriptor
0721   DC13 CD 86 DC            CALL fdSend             ; send it
0722   DC16 2A FE A8            LD   HL,(m09)           ; get descriptor address (usually 0080)
0723   DC19 7D                  LD   A,L                
0724   DC1A CD 86 DC            CALL fdSend             ; send LSB first
0725   DC1D 7C                  LD   A,H 
0726   DC1E CD 86 DC            CALL fdSend             ; thn send MSB
0727   DC21 AF                  XOR  A                  ; FDC cmd 0h = disk I/O
0728   DC22 CD 86 DC            CALL fdSend             ; send it
0729   DC25             
0730   DC25                     ; now that a command has been sent to the controller, poll the result
0731   DC25                     ; byte for a response.  Return as soon as a response is received, but
0732   DC25                     ; time out after 128K attempts.
0733   DC25                     
0734   DC25 11 00 00            LD   DE,0000h           ; DE & B used as time-out counter
0735   DC28 06 02               LD   B,2
0736   DC2A 2A FE A8            LD   HL,(m09)           ; point to disk descriptor
0737   DC2D 23                  INC  HL                 ; now point to FDC result code
0738   DC2E 7E          j88:    LD   A,(HL)             ; get result code from FDC
0739   DC2F B7                  OR   A                  ; is it zero? 
0740   DC30 C0                  RET  NZ                 ; return when FDC returns a results
0741   DC31 15                  DEC  D 
0742   DC32 C2 2E DC            JP   NZ,j88             ; wait loop x 256 reads
0743   DC35 1D                  DEC  E 
0744   DC36 C2 2E DC            JP   NZ,j88             ; wait loop x 64K
0745   DC39 05                  DEC  B 
0746   DC3A C2 2E DC            JP   NZ,j88             ; wait loop x 128K
0747   DC3D C9                  RET                     ; don't wait forever!
0748   DC3E             
0749   DC3E             ; Handle Read from Diskette "R" command
0750   DC3E             ;
0751   DC3E CD D2 DB    cmdR:   CALL initDD             ; initialize disc descriptor with Read on Disk 0
0752   DC41 C3 49 DC            JP   diskIO             ; do it
0753   DC44             
0754   DC44             ; Handle Write to Diskette "W" command
0755   DC44             ; call with <track>,<sector>,<buffer addr>,<Unit#>  (last 2 optional)       
0756   DC44             ;
0757   DC44 CD D2 DB    cmdW:   CALL initDD             ; initialize disc descriptor at A8E3-A8EB
0758   DC47 36 11               LD   (HL),11h           ; change command byte to 11h = Write on Disk 0.
0759   DC49             
0760   DC49 CD 10 DD    diskIO: CALL getHD              ; get 1st param in HL, 2nd in DE
0761   DC4C 32 FD A8            LD   (m08),A            ; temp save last char
0762   DC4F 7D                  LD   A,L 
0763   DC50 B3                  OR   E                  ; was it zero/invalid?
0764   DC51 CA C7 DC            JP   Z,err1             ; return with "INVALID" message
0765   DC54 22 E6 A8            LD   (m01+FDTRK),HL     ; store first param as track #
0766   DC57 7B                  LD   A,E 
0767   DC58 32 E7 A8            LD   (m01+FDSEC),A      ; store 2nd param as sector #
0768   DC5B 3A FD A8            LD   A,(m08)            ; retrieve last char
0769   DC5E FE 0A               CP   0Ah                ; was it <enter>?
0770   DC60 CA 7E DC            JP   Z,j71              ; use default DMA & unit
0771   DC63 CD 10 DD            CALL getHD              ; otherwise get DMA in HL, Unit in DE
0772   DC66 22 E8 A8            LD   (m01+FDDMA),HL     ; store DMA buffer address 
0773   DC69             
0774   DC69                     ; The Drive# (0-3) must be converted into a bit pattern.
0775   DC69                     ; For drive 0, bit 0 is set, etc.
0776   DC69             
0777   DC69 7B                  LD   A,E                ; get unit #
0778   DC6A E6 03               AND  03h                ; must be 0-3
0779   DC6C 3C                  INC  A                  ; convert 0-3 to 1-4
0780   DC6D 5F                  LD   E,A                ; use this as a rotation counter
0781   DC6E AF                  XOR  A 
0782   DC6F 37                  SCF                     ; start with A=0 plus carry set
0783   DC70 17          j72:    RLA                     ; rotate carry to bit0 
0784   DC71 1D                  DEC  E 
0785   DC72 C2 70 DC            JP   NZ,j72             ; set drive bit by rotating
0786   DC75             
0787   DC75                     ; The first byte in the disc descriptor contains the disk command & unit info.
0788   DC75                     ; the upper 4 bits are the command and the lower 4 bits are the unit.
0789   DC75                     ; add the new drive info to the existing command byte 
0790   DC75             
0791   DC75 5F                  LD   E,A                ; copy drive info to E
0792   DC76 21 E3 A8            LD   HL,m01+FDCMD       ; address for command/unit byte
0793   DC79 7E                  LD   A,(HL)             ; get old drive command/unit value
0794   DC7A E6 F0               AND  0F0h               ; mask out unit
0795   DC7C B3                  OR   E                  ; add in new unit
0796   DC7D 77                  LD  (HL),A              ; and save new command/unit 
0797   DC7E             
0798   DC7E                     ; Now the disc descriptor contains the command &  user input parameters
0799   DC7E             
0800   DC7E CD F4 DB    j71:    CALL fdExec             ; send command to FC controller & get result
0801   DC81 3D                  DEC  A                  ; was result code 1=success?
0802   DC82 C8                  RET  Z                  ; return if so with A=0
0803   DC83 C3 A5 DB            JP   fdErr              ; otherwise print the disk error code
0804   DC86             
0805   DC86             ; fdSend: send a byte to the Floppy Disk Controller
0806   DC86             ;
0807   DC86 32 FD A8    fdSend: LD   (m08),A            ; temp store byte to send
0808   DC89 3A F4 A8            LD   A,(m02)            ; get controller type
0809   DC8C FE 04               CP   04h                ; is it type 4?
0810   DC8E CA B6 DC            JP   Z,j48              ; yes, execute FDC command in m08
0811   DC91 D6 01               SUB  01h                ; otherwise continue below.
0812   DC93 07                  RLCA 
0813   DC94 07                  RLCA
0814   DC95 E5                  PUSH HL                 ; save HL on stack
0815   DC96 D5                  PUSH DE                 ; save DE on stack
0816   DC97 57                  LD   D,A 
0817   DC98 3A F5 A8            LD   A,(m03)
0818   DC9B 3C                  INC  A 
0819   DC9C 07                  RLCA 
0820   DC9D 82                  ADD  A,D                ; A provides index into table
0821   DC9E 21 AE DC            LD   HL,fddat           ; point to FD controller address table
0822   DCA1 CD 25 DD            CALL j89                ; adds A to HL
0823   DCA4 5E                  LD   E,(HL)             
0824   DCA5 23                  INC  HL 
0825   DCA6 56                  LD   D,(HL)             ; load controller address into DE
0826   DCA7 EB                  EX   DE,HL              ; put it back into HL
0827   DCA8 D1                  POP  DE                 ; restore original DE
0828   DCA9 E3                  EX   (SP),HL            ; restore original HL, put controller address on stack
0829   DCAA 3A FD A8            LD   A,(m08)            ; restore byte back into A
0830   DCAD C9                  RET                     ; jump to controller address
0831   DCAE             
0832   DCAE 09 F0 09 E0 fddat:  .dw 0F009h, 0E009h, 0F006h, 0E006h       
0832   DCB2 06 F0 06 E0 
0833   DCB6             
0834   DCB6             ; This is the only call to the FDC port
0835   DCB6             ; There are only two commands:  10h to set up disk descriptor
0836   DCB6             ; and 00h to execute the descriptor
0837   DCB6             ;
0838   DCB6 3A FD A8    j48:    LD   A,(m08)            ; get FDC command in m08
0839   DCB9 D3 FD               OUT  (FDC),A            ; and sent it to floppy disk (FIF) controller
0840   DCBB C9                  RET 
0841   DCBC             
0842   DCBC             ; This might be a bit of orphaned code, obsoleted by fdSend above.  
0843   DCBC             ; Nothing jumps here.
0844   DCBC FE 02               CP   02h                
0845   DCBE 3A FD A8            LD   A,(m08)            ; get the disk command
0846   DCC1 CA 06 E0            JP   Z,0E006h           ; and jump to this controller
0847   DCC4 C3 09 E0            JP   0E009h             ; or this one
0848   DCC7             
0849   DCC7 21 CD DC    err1:   LD   HL,st1 
0850   DCCA C3 A2 DD            JP   putStr             ; print "INVALID" message     
0851   DCCD 49 4E 56 41 st1:    .db "INVALID",0
0851   DCD1 4C 49 44 00 
0852   DCD5             
0853   DCD5 21 F4 A8    cmdD2:  LD   HL,m02             ; show FD type and allow user to change it
0854   DCD8 C3 20 DA            JP   j62
0855   DCDB             
0856   DCDB 21 F6 A8    cmdI2:  LD   HL,m04             ; show input device bitmap & allow user to change
0857   DCDE C3 20 DA            JP   j62
0858   DCE1             
0859   DCE1 21 F7 A8    cmdO2:  LD   HL,m05             ; show output device bitmap & allow user to change
0860   DCE4 C3 20 DA            JP   j62 
0861   DCE7             
0862   DCE7             ; Param2 gets <start address> in HL and <end address> in DE
0863   DCE7             ; Then calculates the number of bytes between them as BC = ED - HL + 1
0864   DCE7                     
0865   DCE7 CD F4 DC    param2: CALL j67                ; get up to 2 parameters in HL,DE
0866   DCEA F5                  PUSH AF                 ; save A
0867   DCEB 7B                  LD   A,E                ; do 16-bit math (BC=ED-HL) as two 8-bit ops               
0868   DCEC 95                  SUB  L                  
0869   DCED 4F                  LD   C,A                ; now C = E - L
0870   DCEE 7A                  LD   A,D 
0871   DCEF 9C                  SBC  A,H 
0872   DCF0 47                  LD   B,A                ; now B = D - H
0873   DCF1 03                  INC  BC                 ; add one
0874   DCF2 F1                  POP  AF                 ; restore A
0875   DCF3 C9                  RET
0876   DCF4             
0877   DCF4             ; This is a helper function for param2.  It gets start and end addresses from the user,
0878   DCF4             ; which can be separated by either a comma or space, and puts results into HL and DE.
0879   DCF4             
0880   DCF4 CD 3E DE    j67:    CALL getHex             ; get console input into HL 
0881   DCF7 54                  LD   D,H 
0882   DCF8 5D                  LD   E,L                ; save to DE
0883   DCF9 FE 0A       j68:    CP   0Ah                ; was input just <enter>?
0884   DCFB C8                  RET  Z                  ; return if so.
0885   DCFC FE 20               CP   20h                ; was last char a space ' '?
0886   DCFE CA 04 DD            JP   Z,j66
0887   DD01 FE 2C               CP   2Ch                ; was last char a comma ','?
0888   DD03 C0                  RET  NZ 
0889   DD04 EB          j66:    EX   DE,HL              ; if space or comma then 
0890   DD05 CD 3E DE            CALL getHex             ; get second hex input
0891   DD08 EB                  EX   DE,HL              ; 1st input in HL, 2nd input in DE
0892   DD09 C9                  RET 
0893   DD0A             
0894   DD0A             ; Param 3 gets three parameters from user: start address, end address, and X.
0895   DD0A             ; At the end, HL contains start address, DE contains X, and BC contains byte count.
0896   DD0A             
0897   DD0A CD E7 DC    param3: CALL param2             ; get start addr in HL and count in BC
0898   DD0D C3 04 DD            JP   j66                ; gets 3rd parameter in DE
0899   DD10             
0900   DD10             
0901   DD10             ; Next routine gets one parameter into HL, and a second optional parameter in DE.
0902   DD10             ;
0903   DD10 CD 3E DE    getHD:  CALL getHex             ; get console input into HL 
0904   DD13 11 00 00            LD   DE,0000h 
0905   DD16 C3 F9 DC            JP   j68                ; get optional 2nd parameter
0906   DD19             
0907   DD19             ; Check to see if VIO firmware is present.
0908   DD19             ; The firmware signature is "VIO".  Zero flag set if firmware present.
0909   DD19             ;
0910   DD19 21 FD FF    vidOK:  LD   HL,VIOSIG          ; point to VIO signature in firmware
0911   DD1C 3E 56               LD   A,56h         
0912   DD1E BE                  CP   (HL)               ; is it a 'V'?
0913   DD1F C0                  RET  NZ                 ; return if not
0914   DD20 23                  INC  HL                 ; go to next byte
0915   DD21 3E 49               LD   A,49h              ; is it an 'I'?
0916   DD23 BE                  CP   (HL)               ; return with Z flag set
0917   DD24 C9                  RET 
0918   DD25             
0919   DD25 85          j89:    ADD  A,L                ; small routine to add A to HL
0920   DD26 6F                  LD   L,A 
0921   DD27 D0                  RET  NC 
0922   DD28 24                  INC  H 
0923   DD29 C9                  RET 
0924   DD2A             
0925   DD2A             ; Search the command table
0926   DD2A             ; A = command that is being searched for
0927   DD2A             ; on return, zero flag set if not found
0928   DD2A             ; otherwise, HL contains address of the command
0929   DD2A             
0930   DD2A 47          lookup: LD   B,A                ; save command in B
0931   DD2B 7E          j59:    LD   A,(HL)             ; get next command
0932   DD2C B7                  OR   A                  ; zero = end of table
0933   DD2D C8                  RET  Z                  ; quit if end of table
0934   DD2E B8                  CP   B                  ; command match?
0935   DD2F 23                  INC  HL                 ; point to addr LSB
0936   DD30 CA 38 DD            JP   Z,j58              ; jump if found
0937   DD33 23                  INC  HL                 ; point to next table entry
0938   DD34 23                  INC  HL 
0939   DD35 C3 2B DD            JP   j59                ; and keep searching 
0940   DD38 46          j58:    LD   B,(HL)             
0941   DD39 23                  INC  HL                 ; point to addr MSB
0942   DD3A 66                  LD   H,(HL)             ; load MSB into H
0943   DD3B 68                  LD   L,B                ; load LSB into L
0944   DD3C B7                  OR   A                  ; clears Z flag 
0945   DD3D C9                  RET 
0946   DD3E             
0947   DD3E             ; SERIAL PORT (12/13) INPUT 
0948   DD3E DB 13       serIn:  IN   A,(13h)            ; check status port 13h
0949   DD40 E6 02               AND  02h                ; look at ready bit
0950   DD42 C8                  RET  Z                  ; return if not ready
0951   DD43 DB 12               IN   A,(12h)            ; ready, so get char from port 12h
0952   DD45 C9                  RET                    
0953   DD46             
0954   DD46             ; SYSTEM SERIAL PORT (2/3) INPUT 
0955   DD46 DB 03       sysIn:  IN   A,(CONSTAT)        ; check serial uart status
0956   DD48 E6 02               AND  02h                ; look at Rx-ready bit only
0957   DD4A C8                  RET  Z                  ; returns 0 when not ready
0958   DD4B DB 02               IN   A,(CONIO)          ; otherwise get character into reg A
0959   DD4D C9                  RET                     
0960   DD4E             
0961   DD4E             ; PARALLEL PORT (14/15) INPUT
0962   DD4E DB 15       parIn:  IN   A,(15h)            ; get status byte from port 15h
0963   DD50 E6 02               AND  02h                ; look at only bit 1
0964   DD52 C8                  RET  Z                  ; not ready
0965   DD53 DB 14               IN   A,(14h)            ; read byte from port 14h
0966   DD55 C9                  RET 
0967   DD56             
0968   DD56             ; SERIAL PORT (12/13) OUTPUT       
0969   DD56 DB 13       serOut: IN   A,(13h)            ; get status byte
0970   DD58 E6 01               AND  01h                ; look only at bit 0
0971   DD5A CA 56 DD            JP   Z,serOut
0972   DD5D 3A FD A8            LD   A,(m08)            ; get character to send
0973   DD60 D3 12               OUT  (12h),A            ; and output to port 12h
0974   DD62 C9                  RET 
0975   DD63             
0976   DD63             ; SYSTEM SERIAL PORT (2/3) OUTPUT  
0977   DD63 DB 03       sysOut: IN   A,(CONSTAT)        ; check serial status
0978   DD65 E6 01               AND  01h                ; look at Tx-ready bit only
0979   DD67 CA 63 DD            JP   Z,sysOut           ; wait until ready
0980   DD6A 3A FD A8            LD   A,(m08)            ; get character to transmit
0981   DD6D D3 02               OUT  (CONIO),A          ; and transmit it
0982   DD6F C9                  RET
0983   DD70             
0984   DD70             ; PARALLEL IN/ SYSTEM SERIAL OUT
0985   DD70 DB 15       piso:   IN   A,(15h)            ; check status port 15h
0986   DD72 E6 01               AND  01h                ; and look at ready bit
0987   DD74 CA 63 DD            JP   Z,sysOut 
0988   DD77 3A FD A8            LD   A,(m08)            ; get char to transmit
0989   DD7A D3 02               OUT  (CONIO),A          ; and transmit it to console
0990   DD7C C9                  RET 
0991   DD7D             
0992   DD7D CD 84 DD    getCh1: CALL getCh              ; get character, waiting for input
0993   DD80 CA 7D DD            JP   Z,getCh1           ; loop until character is received.
0994   DD83 C9                  RET 
0995   DD84             
0996   DD84 3A F6 A8    getCh:  LD   A,(m04)            ; m04 controls where to look for input
0997   DD87 E6 02               AND  02h                ; if bit 1 set,
0998   DD89 C4 4E DD            CALL NZ,parIn           ; look for input from parallel port 14/15h
0999   DD8C C0                  RET  NZ                 ; return if something found
1000   DD8D 3A F6 A8            LD   A,(m04)            ; otherwise keep looking     
1001   DD90 E6 04               AND  04h                ; if bit 2 set,     
1002   DD92 C4 46 DD            CALL NZ,sysIn           ; try getting char from serial port 2/3h
1003   DD95 C0                  RET  NZ                 ; return if something found
1004   DD96 3A F6 A8            LD   A,(m04)            ; otherwise keep looking
1005   DD99 E6 01               AND  01h                ; if bit 0 set,
1006   DD9B C4 3E DD            CALL NZ,serIn           ; look for input from serial port 12/13h
1007   DD9E C9                  RET                     ; return, even if character not available
1008   DD9F             
1009   DD9F CD 13 DE            CALL crlf               ; start a new line
1010   DDA2 7E          putStr: LD   A,(HL)             ; load next char in string
1011   DDA3 B7                  OR   A                  ; is it a zero?
1012   DDA4 C8                  RET  Z                  ; if so, we are done
1013   DDA5 C5                  PUSH BC 
1014   DDA6 47                  LD   B,A 
1015   DDA7 CD AF DD            CALL putCh              ; sent character to console etc
1016   DDAA C1                  POP  BC 
1017   DDAB 23                  INC  HL                 ; point to next character to send
1018   DDAC C3 A2 DD            JP   putStr             ; and loop until done
1019   DDAF             
1020   DDAF 32 FD A8    putCh:  LD   (m08),A            ; save character to output
1021   DDB2 E5                  PUSH HL
1022   DDB3 21 F7 A8            LD   HL,m05             ; get output locations       
1023   DDB6 7E                  LD   A,(HL)
1024   DDB7 E6 01               AND  01h                ; if bit 0 set,
1025   DDB9 C4 56 DD            CALL NZ,serOut          ; output to port 12h
1026   DDBC 7E                  LD   A,(HL)
1027   DDBD E6 02               AND  02h                ; if bit 1 set,
1028   DDBF C4 70 DD            CALL NZ,piso            ; output to console
1029   DDC2 7E                  LD   A,(HL)
1030   DDC3 E6 04               AND  04h                ; if bit 2 set,
1031   DDC5 C4 63 DD            CALL NZ,sysOut          ; send char to console
1032   DDC8 7E                  LD   A,(HL) 
1033   DDC9 E6 10               AND  10h                ; if bit 4 set
1034   DDCB 3A FD A8            LD   A,(m08) 
1035   DDCE C4 03 F8            CALL NZ,VIOOUT          ; send it to video output
1036   DDD1 3A F7 A8            LD   A,(m05)
1037   DDD4 E6 20               AND  20h                ; if bit 5 set
1038   DDD6 3A FD A8            LD   A,(m08)
1039   DDD9 C4 DE DD            CALL NZ,j34             ; send it to video output
1040   DDDC E1                  POP  HL
1041   DDDD C9                  RET 
1042   DDDE             
1043   DDDE 3E FF       j34:    LD   A,0FFh 
1044   DDE0 D3 FE               OUT  (WP),A             ; adjust mem write protection
1045   DDE2 3A FD A8            LD   A,(m08)            ; get output char
1046   DDE5 C3 03 F8            JP   VIOOUT             ; and send to video
1047   DDE8             
1048   DDE8                                             ; Gets a character, processing <enter>,<esc>,lower case.
1049   DDE8 CD 7D DD    getCh2: CALL getCh1             ; get char, waiting until received
1050   DDEB E6 7F               AND  7Fh                ; strip off MSB  (7-bit ASCII only)
1051   DDED FE 0D               CP   0Dh                ; was it <enter>?
1052   DDEF CA 13 DE            JP   Z,crlf             ; if so, send <cr><lf> 
1053   DDF2 FE 03               CP   03h                ; was it Ctrl-C?
1054   DDF4 CA 67 D8            JP   Z,wboot            ; yes, do a warm boot
1055   DDF7 FE 15               CP   15h                ; was it Ctrl-Z?
1056   DDF9 CA 67 D8            JP   Z,wboot            ; yes, do a warm boot
1057   DDFC CD AF DD            CALL putCh              ; echo character to console
1058   DDFF FE 1B               CP   1Bh                ; was it <esc>?
1059   DE01 C2 0A DE            JP   NZ,j36             ; no, so continue evaluation below
1060   DE04 CD E8 DD            CALL getCh2             ; yes, so get next character
1061   DE07 C3 E8 DD            JP   getCh2
1062   DE0A FE 61       j36:    CP   61h                ; was it upper-case?
1063   DE0C D8                  RET  C                  ; no, so return with it.
1064   DE0D FE 5B               CP   5Bh                ; 
1065   DE0F D0                  RET  NC                 ; 
1066   DE10 EE 20               XOR  20h                ; convert input to upper case.
1067   DE12 C9                  RET 
1068   DE13             
1069   DE13             ; crlf issues a two byte carriage return/line feed combo to output devices
1070   DE13             ; 
1071   DE13 3E 0D       crlf:   LD   A,0Dh              
1072   DE15 CD AF DD            CALL putCh              ; output CR
1073   DE18 3E 0A               LD   A,0Ah              
1074   DE1A C3 AF DD            JP   putCh              ; output LF
1075   DE1D             
1076   DE1D F5          pHex:   PUSH AF                 ; print byte in hexademical
1077   DE1E 0F                  RRCA                    ; rotate first digit into lower 4 bits
1078   DE1F 0F                  RRCA
1079   DE20 0F                  RRCA
1080   DE21 0F                  RRCA 
1081   DE22 CD 26 DE            CALL j35                ; convert first digit to ASCII
1082   DE25 F1                  POP  AF                 ; restore value & continue with 2nd digit
1083   DE26 E6 0F       j35:    AND  0Fh                ; consider only lower 4 bits
1084   DE28 C6 90               ADD  A,90h              ; convert value to ASCII
1085   DE2A 27                  DAA                     ; via clever textbook routine
1086   DE2B CE 40               ADC  A,40h 
1087   DE2D 27                  DAA 
1088   DE2E C3 AF DD            JP   putCh              ; output hex digit
1089   DE31             
1090   DE31             ; pHex16 prints the word in HL as a four-digit hexadecimal, followed by a space
1091   DE31             ; for example, value 0A8EEh is printed as two ASCII characters "A8EE "
1092   DE31             ;
1093   DE31 7C          pHex16: LD   A,H                ; get upper byte 
1094   DE32 CD 1D DE            CALL pHex               ; and print it          
1095   DE35 7D                  LD   A,L                ; get lower byte
1096   DE36 CD 1D DE    pHexSp: CALL pHex               ; print hex digit, followed by a space
1097   DE39             
1098   DE39 3E 20       space:  LD   A,20h 
1099   DE3B C3 AF DD            JP   putCh              ; print a space
1100   DE3E             
1101   DE3E             ; getHex reads hexadecimal characters from the console and stops when a
1102   DE3E             ; non-hex digit is encountered.  The input could be any number of characters.
1103   DE3E             ; On exit, HL contains the value of the entered value, and A contains non-hex char
1104   DE3E             ; that stopped the routine.  
1105   DE3E             
1106   DE3E 21 00 00    getHex: LD   HL,0000h           ; get console input into HL, default 0
1107   DE41 CD E8 DD    j45:    CALL getCh2             ; get next character with processing
1108   DE44 F5                  PUSH AF                 ; save entered character
1109   DE45 CD 57 DE            CALL isHex              ; is char a hex digit?
1110   DE48 D2 4D DE            JP   NC,j44             ; jump if yes
1111   DE4B F1                  POP  AF                 ; restore entered character in A
1112   DE4C C9                  RET                     ; return on non-hex input
1113   DE4D 29          j44:    ADD  HL,HL              ; HL x 16 (shift it left one digit)
1114   DE4E 29                  ADD  HL,HL 
1115   DE4F 29                  ADD  HL,HL 
1116   DE50 29                  ADD  HL,HL
1117   DE51 85                  ADD  A,L                ; 
1118   DE52 6F                  LD   L,A                ; add in A
1119   DE53 F1                  POP  AF 
1120   DE54 C3 41 DE            JP   j45 
1121   DE57             
1122   DE57             ; isHex returned carry cleared for ASCII characters (A-F,0-9), but set otherwise.
1123   DE57             ; On exit, A contains value of the character.  For example, reg A=0Ah for "A" input
1124   DE57             ;
1125   DE57 D6 30       isHex:  SUB  30h                ; is it a control/special char?
1126   DE59 D8                  RET  C                  ; yes, return with carry set
1127   DE5A FE 0A               CP   0Ah                ; is it a numeric digit?
1128   DE5C DA 66 DE            JP   C,j39              ; yes, return with carry clear  
1129   DE5F D6 11               SUB  11h                ; is it ':' thru '@'?
1130   DE61 D8                  RET  C                  ; yes, return with carry set
1131   DE62 C6 0A               ADD  A,0Ah              ; A->10h; B->11h; etc.
1132   DE64 FE 10               CP   10h                ; set carry for A-F
1133   DE66 3F          j39:    CCF                     ; clears carry for A-F
1134   DE67 C9                  RET 
1135   DE68             
1136   DE68             ; showAW displays an address (HL-1) and it word contents
1137   DE68             ;
1138   DE68 CD 70 DE    showAW: CALL showAB             ; display address (HL-1) & its byte contents
1139   DE6B 7E                  LD   A,(HL) 
1140   DE6C CD 1D DE    j93:    CALL pHex               ; and also contents at next address
1141   DE6F C9                  RET 
1142   DE70             
1143   DE70             ; showAB displays an address (HL-1) and it byte contents
1144   DE70             ;
1145   DE70 CD 13 DE    showAB: CALL crlf               ; new line
1146   DE73 2B          j47:    DEC  HL 
1147   DE74 CD 31 DE            CALL pHex16             ; display an address (HL-1)
1148   DE77 7E                  LD   A,(HL)
1149   DE78 CD 36 DE            CALL pHexSp             ; and its contents
1150   DE7B 23                  INC  HL 
1151   DE7C C9                  RET 
1152   DE7D             
1153   DE7D             ;  Baud Table #1: timing values and associated baud rates
1154   DE7D             ;  used for automatic baud rate determination
1155   DE7D             ;
1156   DE7D 03 96       baudT1: .db  03h, 96h           ; 9600 baud
1157   DE7F 06 49               .db  06h, 49h           ; 4900 baud (?)
1158   DE81 0B 24               .db  0Bh, 24h           ; 2400 baud
1159   DE83 17 12               .db  17h, 12h           ; 1200 baud
1160   DE85 2E 06               .db  2Eh, 06h           ; 600 baud
1161   DE87 5E 03               .db  5Eh, 03h           ; 300 baud
1162   DE89 FF 01               .db 0FFh, 01h           ; 110 baud
1163   DE8B 00                  .db 00h
1164   DE8C             
1165   DE8C             ; Baud Table #2: rates "96"=9600, etc and their associated timer0 
1166   DE8C             ; count values, calculated as count = 2000000/(16*baud)
1167   DE8C             ;
1168   DE8C 96          baudT2: .db 96h \ .dw 000Dh     ; 9600 baud
1168   DE8D 0D 00       
1169   DE8F 01                  .db 01h \ .dw 0470h     ;  110 baud
1169   DE90 70 04       
1170   DE92 03                  .db 03h \ .dw 01A0h     ;  300 baud
1170   DE93 A0 01       
1171   DE95 48                  .db 48h \ .dw 001Ah     ; 4800 baud
1171   DE96 1A 00       
1172   DE98 24                  .db 24h \ .dw 0034h     ; 2400 baud
1172   DE99 34 00       
1173   DE9B 12                  .db 12h \ .dw 0068h     ; 1200 baud
1173   DE9C 68 00       
1174   DE9E 06                  .db 06h \ .dw 000D0h    ;  600 baud
1174   DE9F D0 00       
1175   DEA1 00                  .db 00h
1176   DEA2                      
1177   DEA2             ; Table of Monitor commands and their jump vectors:
1178   DEA2             ;     
1179   DEA2 42          cmdTbl: .db 'B' \ .dw cmdB      ; Boot from Floppy Disk
1179   DEA3 9B DB       
1180   DEA5 43                  .db 'C' \ .dw cmdC      ; Call routine in memory
1180   DEA6 E2 D9       
1181   DEA8 44                  .db 'D' \ .dw cmdD      ; Display memory
1181   DEA9 2C DA       
1182   DEAB 45                  .db 'E' \ .dw cmdE      ; Examine & modify memory
1182   DEAC 06 DA       
1183   DEAE 46                  .db 'F' \ .dw cmdF      ; Fill memory
1183   DEAF 0F DB       
1184   DEB1 48                  .db 'H' \ .dw cmdL      ; Load Intel Hex tape
1184   DEB2 93 DA       
1185   DEB4 49                  .db 'I' \ .dw cmdI      ; Port Input
1185   DEB5 1B DB       
1186   DEB7 4A                  .db 'J' \ .dw cmdJ      ; Jump to Memory
1186   DEB8 E1 D9       
1187   DEBA 4B                  .db 'K' \ .dw cmdK      ; Kill ROM and Jump
1187   DEBB E6 D9       
1188   DEBD 4D                  .db 'M' \ .dw cmdM      ; Copy Memory
1188   DEBE 09 DB       
1189   DEC0 4E                  .db 'N' \ .dw cmdN      ; same as cmdK
1189   DEC1 E6 DB       
1190   DEC3 4F                  .db 'O' \ .dw cmdO      ; Port Output
1190   DEC4 1C DB       
1191   DEC6 51                  .db 'Q' \ .dw cmdQ      ; Switch-off ROM and Jump to VIO monitor
1191   DEC7 EE D9       
1192   DEC9 52                  .db 'R' \ .dw cmdR      ; Read from Diskette
1192   DECA 3E DC       
1193   DECC 53                  .db 'S' \ .dw cmdS      ; Search memory
1193   DECD 6A DB       
1194   DECF 54                  .db 'T' \ .dw cmdT      ; Test memory
1194   DED0 E4 DA       
1195   DED2 56                  .db 'V' \ .dw cmdV      ; Verify Memory
1195   DED3 4D DB       
1196   DED5 57                  .db 'W' \ .dw cmdW      ; Write to Diskette
1196   DED6 44 DC       
1197   DED8 59                  .db 'Y' \ .dw cmdY      ; Change Direct I/O address
1197   DED9 3E DB       
1198   DEDB 5A                  .db 'Z' \ .dw cmdZ      ; Set baud rate
1198   DEDC B8 D9       
1199   DEDE 3A                  .db ':' \ .dw cmd2      ; secondary commands follow
1199   DEDF 89 D8       
1200   DEE1 44          cmdTbl2:.db 'D' \ .dw cmdD2     ; change FD drive type
1200   DEE2 D5 DC       
1201   DEE4 49                  .db 'I' \ .dw cmdI2     ; change char input device
1201   DEE5 DB DC       
1202   DEE7 4F                  .db 'O' \ .dw cmdO2     ; change char output device
1202   DEE8 E1 DC       
1203   DEEA 00                  .db 00                  ; end of table marker
1204   DEEB             
1205   DEEB 20 20 20 20         .db "        "
1205   DEEF 20 20 20 20 
1206   DEF3 49 4D 53 41 str4:   .db "IMSAI IEEE MONITOR    VERS 1.0",0
1206   DEF7 49 20 49 45 
1206   DEFB 45 45 20 4D 
1206   DEFF 4F 4E 49 54 
1206   DF03 4F 52 20 20 
1206   DF07 20 20 56 45 
1206   DF0B 52 53 20 31 
1206   DF0F 2E 30 00 
1207   DF12 48 49 54 20 str5:   .db "HIT SPACE BAR",13,10,0
1207   DF16 53 50 41 43 
1207   DF1A 45 20 42 41 
1207   DF1E 52 0D 0A 00 
1208   DF22 49 4E 56 41 str6:   .db "INVALID BAUD",0
1208   DF26 4C 49 44 20 
1208   DF2A 42 41 55 44 
1208   DF2E 00 
1209   DF2F 42 41 55 44 str7:   .db "BAUD SERIAL",13,10,0
1209   DF33 20 53 45 52 
1209   DF37 49 41 4C 0D 
1209   DF3B 0A 00 
1210   DF3D 50 41 52 41 str8:   .db "PARALLEL",13,10,0
1210   DF41 4C 4C 45 4C 
1210   DF45 0D 0A 00 
1211   DF48 1A 1A 1A 1A         .fill 38h,1Ah
1211   DF4C 1A 1A 1A 1A 
1211   DF50 1A 1A 1A 1A 
1211   DF54 1A 1A 1A 1A 
1211   DF58 1A 1A 1A 1A 
1211   DF5C 1A 1A 1A 1A 
1211   DF60 1A 1A 1A 1A 
1211   DF64 1A 1A 1A 1A 
1211   DF68 1A 1A 1A 1A 
1211   DF6C 1A 1A 1A 1A 
1211   DF70 1A 1A 1A 1A 
1211   DF74 1A 1A 1A 1A 
1211   DF78 1A 1A 1A 1A 
1211   DF7C 1A 1A 1A 1A 
1212   DF80             
1213   DF80             .ENDtasm: Number of errors = 0
