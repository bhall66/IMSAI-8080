0001   0000             ;
0002   0000             ;   Title:   rtc5.asm
0003   0000             ;  Author:   Bruce E. Hall, w8bh
0004   0000             ;    Date:   12 Aug 2025
0005   0000             ;      HW:   IMSAI8080 emulator by TheHighNibble
0006   0000             ;      SW:   TASM compiler using Z80 mnemonics (-80 option)
0007   0000             ;            
0008   0000             ;   Descr:   Real Time Clock (RTC) Tutorial
0009   0000             ;            Learn how to handle time & date under CP/M 2.2
0010   0000             ;
0011   0000             
0012   0000             CLKCMD      .EQU    41h         ; RTC command port
0013   0000             CLKDAT      .EQU    42h         ; RTC data port
0014   0000             
0015   0100                         .ORG    100h        ; Run under CP/M
0016   0100             
0017   0100 31 00 10    start:      LD   SP,1000h       ; establish local stack  
0018   0103 CD 23 01                CALL getTime        ; get hour/min/sec/days, etc
0019   0106 CD 36 01                CALL calcDOW        ; get DOW, too!
0020   0109 21 DD 01                LD   HL,stTime 
0021   010C CD AC 01                CALL putStr         ; "The time is "
0022   010F CD 48 01                CALL pTime12        ; print time in 12-hr format
0023   0112 CD 9C 01                CALL printDOW       ; print day of week
0024   0115 3E 20                   LD   A,' '
0025   0117 CD B6 01                CALL putCh          ; followed by space
0026   011A CD 7B 01                CALL pDate          ; then print the date
0027   011D CD B9 01                CALL crlf               
0028   0120 C3 00 00    fin:        JP   0000           ; return to CP/M
0029   0123             
0030   0123             
0031   0123             ; getTime:
0032   0123             ; queries the RTC and saves time variables in memory as
0033   0123             ; sec, min, hour, days, day, month, & year
0034   0123             ;
0035   0123 06 08       getTime:    LD   B,8            ; 8 parameters to retrieve
0036   0125 21 D3 01                LD   HL,sec         ; point to first param
0037   0128 3E 08       jGT:        LD   A,8            
0038   012A 90                      SUB  B              ; A = 0 through 7
0039   012B D3 41                   OUT  (CLKCMD),A     ; send the RTC command
0040   012D DB 42                   IN   A,(CLKDAT)     ; and get the RTC result
0041   012F 77                      LD   (HL),A         ; store the result
0042   0130 23                      INC  HL             ; advance pointer
0043   0131 05                      DEC  B              ; for 8080, dont use DJNZ
0044   0132 C2 28 01                JP   NZ,jGT         ; loop until done            
0045   0135 C9                      RET 
0046   0136             
0047   0136             
0048   0136             ; Calculate the day of the week: 0=Sunday, 1=Monday, etc
0049   0136             ;
0050   0136 2A D6 01    calcDOW:    LD   HL,(days)      ; HL = days since 1/1/78
0051   0139 2B                      DEC  HL             ; dont count current day
0052   013A 11 07 00                LD   DE,7           ; divisor is 7
0053   013D AF                      XOR  A              ; clear carry for next op
0054   013E ED 52       jDW:        SBC  HL,DE          ; subtract the divisor
0055   0140 30 FC                   JR   NC,jDW         ; keep subtracting until neg
0056   0142 19                      ADD  HL,DE          ; undo last subtraction
0057   0143 7D                      LD   A,L            ; remainder now in HL
0058   0144 32 DC 01                LD   (dow),A        ; store remainder as day of week
0059   0147 C9                      RET 
0060   0148             
0061   0148             
0062   0148             ; print current local time in 12-hr (AM/PM) format
0063   0148             ; 
0064   0148 21 0E 02    pTime12:    LD   HL,stAM        ; assume AM for now
0065   014B 3A D5 01                LD   A,(hour)       ; get the hour (in BCD)
0066   014E FE 12                   CP   12h            ; hour < 12?
0067   0150 DA 5C 01                JP   C,j08          ; yes, keep hour as AM
0068   0153 CA 59 01                JP   Z,j09          ; if 12PM, don't change hour
0069   0156 D6 12                   SUB  12h            ; if hour is 13+, subtract 12
0070   0158 27                      DAA                 ; adjust result for BCD
0071   0159 21 14 02    j09:        LD   HL,stPM        ; use PM, not AM
0072   015C E5          j08:        PUSH HL             ; save AM/PM pointer
0073   015D CD C3 01                CALL pBCD           ; print hours in 12hr format
0074   0160 3E 3A                   LD   A,':'
0075   0162 CD B6 01                CALL putCh 
0076   0165 3A D4 01                LD   A,(min) 
0077   0168 CD C3 01                CALL pBCD           ; print minutes
0078   016B 3E 3A                   LD   A,':'
0079   016D CD B6 01                CALL putCh 
0080   0170 3A D3 01                LD   A,(sec) 
0081   0173 CD C3 01                CALL pBCD           ; print seconds  
0082   0176 E1                      POP  HL 
0083   0177 CD AC 01                CALL putStr         ; print AM or PM 
0084   017A C9                      RET 
0085   017B             
0086   017B             
0087   017B             ; print the date as month/day/year
0088   017B             ;
0089   017B 3A D9 01    pDate:      LD   A,(mon)
0090   017E 3C                      INC  A              ; 0-based to 1-based months
0091   017F 27                      DAA                 ; handle BCD math
0092   0180 CD C3 01                CALL pBCD           ; print month
0093   0183 3E 2F                   LD   A,'/'
0094   0185 CD B6 01                CALL putCh
0095   0188 3A D8 01                LD   A,(day) 
0096   018B CD C3 01                CALL pBCD           ; print day 
0097   018E 3E 2F                   LD   A,'/'
0098   0190 CD B6 01                CALL putCh 
0099   0193 3A DA 01                LD   A,(year)       ; has y2K error, fixed in next line
0100   0196 D6 A0                   SUB  0A0h           ; change base 1900 to 2000
0101   0198 CD C3 01                CALL pBCD           ; print year
0102   019B C9                      RET          
0103   019C             
0104   019C             ; Print the day of the week
0105   019C             ;
0106   019C 3A DC 01    printDOW:   LD   A,(dow)        ; A = day of week
0107   019F 07                      RLCA                ; A x 2 
0108   01A0 07                      RLCA                ; A x 4
0109   01A1 06 00                   LD   B,0 
0110   01A3 4F                      LD   C,A            ; offset BC = dow x 4
0111   01A4 21 F2 01                LD   HL,stDow       ; point to days of week
0112   01A7 09                      ADD  HL,BC          ; add in offset
0113   01A8 CD AC 01                CALL putStr         ; print day of week
0114   01AB C9                      RET 
0115   01AC             
0116   01AC             
0117   01AC             ; write a null-terminated ASCII string, pointed to by HL 
0118   01AC             ;
0119   01AC 7E          putStr:     LD      A,(HL)      ; load next char in string      
0120   01AD B7                      OR      A           ; is it end-of-string NULL?
0121   01AE C8                      RET     Z           ; if so, we are done
0122   01AF CD B6 01                CALL    putCh       ; send char to output device
0123   01B2 23                      INC     HL          ; point to next character in string
0124   01B3 C3 AC 01                JP      putStr      ; and loop until done
0125   01B6             
0126   01B6             
0127   01B6             ; send a character to console.
0128   01B6             ; (really one should check TxRdy status bit before sending.)
0129   01B6             ;
0130   01B6 D3 02       putCh:      OUT  (2),A          ; send char to output devices
0131   01B8 C9                      RET
0132   01B9             
0133   01B9             
0134   01B9             ; crlf issues a two byte carriage return/line feed combo to output devices
0135   01B9             ; 
0136   01B9 3E 0D       crlf:       LD   A,0DH
0137   01BB CD B6 01                CALL putCh          ; output CR
0138   01BE 3E 0A                   LD   A,0AH
0139   01C0 C3 B6 01                JP   putCh          ; output LF        
0140   01C3             
0141   01C3             
0142   01C3             ; pBCD prints the BCD byte in A as a two-digit value
0143   01C3             ; for example, value 38h is printed as two ASCII characters "38"
0144   01C3             ;
0145   01C3 F5          pBCD:       PUSH AF             ; save value
0146   01C4 0F                      RRCA                ; rotate first digit into lower 4 bits
0147   01C5 0F                      RRCA    
0148   01C6 0F                      RRCA    
0149   01C7 0F                      RRCA    
0150   01C8 CD CC 01                CALL jBC            ; convert first digit to ASCII
0151   01CB F1                      POP  AF             ; restore value & continue with 2nd digit
0152   01CC E6 0F       jBC:        AND  0FH            ; consider only lower 4 bits
0153   01CE C6 30                   ADD  A,30H          ; convert value to ASCII  
0154   01D0 C3 B6 01                JP   putCh          ; output ASCII character
0155   01D3             
0156   01D3             
0157   01D3             ; RTC variables follow
0158   01D3             ; they are loaded as a 8-byte block, so keep them together in same order
0159   01D3 00          sec:        .db 00              ; stored as BCD
0160   01D4 00          min:        .db 00              ; stored as BCD
0161   01D5 00          hour:       .db 00              ; stored as BCD
0162   01D6 00 00       days:       .dw 0000            ; stored as 16-bit word, days since 1/1/78
0163   01D8 00          day:        .db 00              ; stored as BCD
0164   01D9 00          mon:        .db 00              ; stored as BCD, Jan=0, Feb=1, etc
0165   01DA 00 00       year:       .dw 00              ; stored as pseudo-BCD with Y2K error
0166   01DC             
0167   01DC             ; addition variables follow
0168   01DC 00          dow:        .db 00
0169   01DD 54 68 65 20 stTime:     .db "The current time is ",0
0169   01E1 63 75 72 72 
0169   01E5 65 6E 74 20 
0169   01E9 74 69 6D 65 
0169   01ED 20 69 73 20 
0169   01F1 00 
0170   01F2 53 75 6E 00 stDow:      .db "Sun",0,"Mon",0,"Tue",0,"Wed",0,"Thu",0,"Fri",0,"Sat",0 
0170   01F6 4D 6F 6E 00 
0170   01FA 54 75 65 00 
0170   01FE 57 65 64 00 
0170   0202 54 68 75 00 
0170   0206 46 72 69 00 
0170   020A 53 61 74 00 
0171   020E 20 41 4D 2C stAM:       .db " AM, ",0
0171   0212 20 00 
0172   0214 20 50 4D 2C stPM:       .db " PM, ",0
0172   0218 20 00 
0173   021A             
0174   021A             .END tasm: Number of errors = 0
